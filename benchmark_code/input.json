[
  {
    "id": 1,
    "input": "Translate Python to Go:import random\nfrom typing import List, Callable, Optional\n\n\ndef modifier(x: float) -> float:\n    \n    return 2*(.5 - x) if x < 0.5 else 2*(x - .5)\n\n\ndef modified_random_distribution(modifier: Callable[[float], float],\n                                 n: int) -> List[float]:\n    \n    d: List[float] = []\n    while len(d) < n:\n        r1 = prob = random.random()\n        if random.random() < modifier(prob):\n            d.append(r1)\n    return d\n\n\nif __name__ == '__main__':\n    from collections import Counter\n\n    data = modified_random_distribution(modifier, 50_000)\n    bins = 15\n    counts = Counter(d // (1 / bins) for d in data)\n    \n    mx = max(counts.values())\n    print(\"   BIN, COUNTS, DELTA: HISTOGRAM\\n\")\n    last: Optional[float] = None\n    for b, count in sorted(counts.items()):\n        delta = 'N/A' if last is None else str(count - last)\n        print(f\"  {b / bins:5.2f},  {count:4},  {delta:>4}: \"\n              f\"{'\n        last = count\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"strings\"\n    \"time\"\n)\n\nfunc rng(modifier func(x float64) float64) float64 {\n    for {\n        r1 := rand.Float64()\n        r2 := rand.Float64()\n        if r2 < modifier(r1) {\n            return r1\n        }\n    }\n}\n\nfunc commatize(n int) string {\n    s := fmt.Sprintf(\"%d\", n)\n    if n < 0 {\n        s = s[1:]\n    }\n    le := len(s)\n    for i := le - 3; i >= 1; i -= 3 {\n        s = s[0:i] + \",\" + s[i:]\n    }\n    if n >= 0 {\n        return s\n    }\n    return \"-\" + s\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n    modifier := func(x float64) float64 {\n        if x < 0.5 {\n            return 2 * (0.5 - x)\n        }\n        return 2 * (x - 0.5)\n    }\n    const (\n        N              = 100000\n        NUM_BINS       = 20\n        HIST_CHAR      = \"■\"\n        HIST_CHAR_SIZE = 125\n    )\n    bins := make([]int, NUM_BINS) \n    binSize := 1.0 / NUM_BINS\n    for i := 0; i < N; i++ {\n        rn := rng(modifier)\n        bn := int(math.Floor(rn / binSize))\n        bins[bn]++\n    }\n\n    fmt.Println(\"Modified random distribution with\", commatize(N), \"samples in range [0, 1):\\n\")\n    fmt.Println(\"    Range           Number of samples within that range\")\n    for i := 0; i < NUM_BINS; i++ {\n        hist := strings.Repeat(HIST_CHAR, int(math.Round(float64(bins[i])/HIST_CHAR_SIZE)))\n        fi := float64(i)\n        fmt.Printf(\"%4.2f ..< %4.2f  %s %s\\n\", binSize*fi, binSize*(fi+1), hist, commatize(bins[i]))\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 2,
    "input": "Translate Python to C#:from sympy import sieve\n\nprimelist = list(sieve.primerange(2,1000000))\n\nlistlen = len(primelist)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff > old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff < old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System.Linq;\nusing System.Collections.Generic;\nusing TG = System.Tuple<int, int>;\nusing static System.Console;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int mil = (int)1e6;\n        foreach (var amt in new int[] { 1, 2, 6, 12, 18 })\n        {\n            int lmt = mil * amt, lg = 0, ng, d, ld = 0;\n            var desc = new string[] { \"A\", \"\", \"De\" };\n            int[] mx = new int[] { 0, 0, 0 },\n                  bi = new int[] { 0, 0, 0 },\n                   c = new int[] { 2, 2, 2 };\n            WriteLine(\"For primes up to {0:n0}:\", lmt);\n            var pr = PG.Primes(lmt).ToArray();\n            for (int i = 0; i < pr.Length; i++)\n            {\n                ng = pr[i].Item2; d = ng.CompareTo(lg) + 1;\n                if (ld == d)\n                    c[2 - d]++;\n                else\n                {\n                    if (c[d] > mx[d]) { mx[d] = c[d]; bi[d] = i - mx[d] - 1; }\n                    c[d] = 2;\n                }\n                ld = d; lg = ng;\n            }\n            for (int r = 0; r <= 2; r += 2)\n            {\n                Write(\"{0}scending, found run of {1} consecutive primes:\\n  {2} \",\n                    desc[r], mx[r] + 1, pr[bi[r]++].Item1);\n                foreach (var itm in pr.Skip(bi[r]).Take(mx[r]))\n                    Write(\"({0}) {1} \", itm.Item2, itm.Item1); WriteLine(r == 0 ? \"\" : \"\\n\");\n            }\n        }\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<TG> Primes(int lim)\n    {\n        bool[] flags = new bool[lim + 1];\n        int j = 3, lj = 2;\n        for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n                for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true;\n            }\n        for (; j <= lim; j += 2)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n            }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 3,
    "input": "Translate Java to Python:import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 4,
    "input": "Translate C++ to Python:#ifndef MYWIDGET_H\n#define MYWIDGET_H\n#include <QWidget>\n\nclass QPaintEvent ;\n\nclass MyWidget : public QWidget {\npublic :\n   MyWidget( ) ;\n\nprotected :\n   void paintEvent( QPaintEvent * ) ;\nprivate :\n   int width ;\n   int height ;\n   const int colornumber ;\n} ;\n#endif\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 5,
    "input": "Translate C to Go:#include <stdbool.h>\n#include <stdio.h>\n\nbool is_prime(int n) {\n    int i = 5;\n\n    if (n < 2) {\n        return false;\n    }\n\n    if (n % 2 == 0) {\n        return n == 2;\n    }\n    if (n % 3 == 0) {\n        return n == 3;\n    }\n\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i += 2;\n\n        if (n % i == 0) {\n            return false;\n        }\n        i += 4;\n    }\n\n    return true;\n}\n\nint main() {\n    const int start = 1;\n    const int stop = 1000;\n\n    int sum = 0;\n    int count = 0;\n    int sc = 0;\n    int p;\n\n    for (p = start; p < stop; p++) {\n        if (is_prime(p)) {\n            count++;\n            sum += p;\n            if (is_prime(sum)) {\n                printf(\"The sum of %3d primes in [2, %3d] is %5d which is also prime\\n\", count, p, sum);\n                sc++;\n            }\n        }\n    }\n    printf(\"There are %d summerized primes in [%d, %d)\\n\", sc, start, stop);\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nfunc main() {\n    primes := rcu.Primes(999)\n    sum, n, c := 0, 0, 0\n    fmt.Println(\"Summing the first n primes (<1,000) where the sum is itself prime:\")\n    fmt.Println(\"  n  cumulative sum\")\n    for _, p := range primes {\n        n++\n        sum += p\n        if rcu.IsPrime(sum) {\n            c++\n            fmt.Printf(\"%3d   %6s\\n\", n, rcu.Commatize(sum))\n        }\n    }\n    fmt.Println()\n    fmt.Println(c, \"such prime sums found\")\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 6,
    "input": "Translate PHP to Java:<?php\necho substr_count(\"the three truths\", \"th\"), PHP_EOL; // prints \"3\"\necho substr_count(\"ababababab\", \"abab\"), PHP_EOL; // prints \"2\"\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n",
    "input_language": "PHP",
    "output_language": "Java"
  },
  {
    "id": 7,
    "input": "Translate PHP to Python:$stack = array();\n\nempty( $stack ); // true\n\narray_push( $stack, 1 ); // or $stack[] = 1;\narray_push( $stack, 2 ); // or $stack[] = 2;\n\nempty( $stack ); // false\n\necho array_pop( $stack ); // outputs \"2\"\necho array_pop( $stack ); // outputs \"1\"\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from collections import deque\nstack = deque()\nstack.append(value) \nvalue = stack.pop()\nnot stack \n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 8,
    "input": "Translate Python to Go:\nfrom __future__ import division\nimport sys\n\nfrom PIL import Image\n\n\ndef _fpart(x):\n    return x - int(x)\n\ndef _rfpart(x):\n    return 1 - _fpart(x)\n\ndef putpixel(img, xy, color, alpha=1):\n    \n    compose_color = lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg))\n    c = compose_color(img.getpixel(xy), color)\n    img.putpixel(xy, c)\n\ndef draw_line(img, p1, p2, color):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    dx, dy = x2-x1, y2-y1\n    steep = abs(dx) < abs(dy)\n    p = lambda px, py: ((px,py), (py,px))[steep]\n\n    if steep:\n        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx\n    if x2 < x1:\n        x1, x2, y1, y2 = x2, x1, y2, y1\n\n    grad = dy/dx\n    intery = y1 + _rfpart(x1) * grad\n    def draw_endpoint(pt):\n        x, y = pt\n        xend = round(x)\n        yend = y + grad * (xend - x)\n        xgap = _rfpart(x + 0.5)\n        px, py = int(xend), int(yend)\n        putpixel(img, p(px, py), color, _rfpart(yend) * xgap)\n        putpixel(img, p(px, py+1), color, _fpart(yend) * xgap)\n        return px\n\n    xstart = draw_endpoint(p(*p1)) + 1\n    xend = draw_endpoint(p(*p2))\n\n    for x in range(xstart, xend):\n        y = int(intery)\n        putpixel(img, p(x, y), color, _rfpart(intery))\n        putpixel(img, p(x, y+1), color, _fpart(intery))\n        intery += grad\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print 'usage: python xiaolinwu.py [output-file]'\n        sys.exit(-1)\n\n    blue = (0, 0, 255)\n    yellow = (255, 255, 0)\n    img = Image.new(\"RGB\", (500,500), blue)\n    for a in range(10, 431, 60):\n        draw_line(img, (10, 10), (490, a), yellow)\n        draw_line(img, (10, 10), (a, 490), yellow)\n    draw_line(img, (10, 10), (490, 490), yellow)\n    filename = sys.argv[1]\n    img.save(filename)\n    print 'image saved to', filename\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package raster\n\nimport \"math\"\n\nfunc ipart(x float64) float64 {\n    return math.Floor(x)\n}\n\nfunc round(x float64) float64 {\n    return ipart(x + .5)\n}\n\nfunc fpart(x float64) float64 {\n    return x - ipart(x)\n}\n\nfunc rfpart(x float64) float64 {\n    return 1 - fpart(x)\n}\n\n\nfunc (g *Grmap) AaLine(x1, y1, x2, y2 float64) {\n    \n    dx := x2 - x1\n    dy := y2 - y1\n    ax := dx\n    if ax < 0 {\n        ax = -ax\n    }\n    ay := dy\n    if ay < 0 {\n        ay = -ay\n    }\n    \n    var plot func(int, int, float64)\n    if ax < ay {\n        x1, y1 = y1, x1\n        x2, y2 = y2, x2\n        dx, dy = dy, dx\n        plot = func(x, y int, c float64) {\n            g.SetPx(y, x, uint16(c*math.MaxUint16))\n        }\n    } else {\n        plot = func(x, y int, c float64) {\n            g.SetPx(x, y, uint16(c*math.MaxUint16))\n        }\n    }\n    if x2 < x1 {\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n    }\n    gradient := dy / dx\n\n    \n    xend := round(x1)\n    yend := y1 + gradient*(xend-x1)\n    xgap := rfpart(x1 + .5)\n    xpxl1 := int(xend) \n    ypxl1 := int(ipart(yend))\n    plot(xpxl1, ypxl1, rfpart(yend)*xgap)\n    plot(xpxl1, ypxl1+1, fpart(yend)*xgap)\n    intery := yend + gradient \n\n    \n    xend = round(x2)\n    yend = y2 + gradient*(xend-x2)\n    xgap = fpart(x2 + 0.5)\n    xpxl2 := int(xend) \n    ypxl2 := int(ipart(yend))\n    plot(xpxl2, ypxl2, rfpart(yend)*xgap)\n    plot(xpxl2, ypxl2+1, fpart(yend)*xgap)\n\n    \n    for x := xpxl1 + 1; x <= xpxl2-1; x++ {\n        plot(x, int(ipart(intery)), rfpart(intery))\n        plot(x, int(ipart(intery))+1, fpart(intery))\n        intery = intery + gradient\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 9,
    "input": "Translate C to Go:#include <sys/types.h>\n#include <regex.h>\n#include <stdio.h>\n\ntypedef struct {\n\tconst char *s;\n\tint len, prec, assoc;\n} str_tok_t;\n\ntypedef struct {\n\tconst char * str;\n\tint assoc, prec;\n\tregex_t re;\n} pat_t;\n\nenum assoc { A_NONE, A_L, A_R };\npat_t pat_eos = {\"\", A_NONE, 0};\n\npat_t pat_ops[] = {\n\t{\"^\\\\)\",\tA_NONE, -1},\n\t{\"^\\\\*\\\\*\",\tA_R, 3},\n\t{\"^\\\\^\",\tA_R, 3},\n\t{\"^\\\\*\",\tA_L, 2},\n\t{\"^/\",\t\tA_L, 2},\n\t{\"^\\\\+\",\tA_L, 1},\n\t{\"^-\",\t\tA_L, 1},\n\t{0}\n};\n\npat_t pat_arg[] = {\n\t{\"^[-+]?[0-9]*\\\\.?[0-9]+([eE][-+]?[0-9]+)?\"},\n\t{\"^[a-zA-Z_][a-zA-Z_0-9]*\"},\n\t{\"^\\\\(\", A_L, -1},\n\t{0}\n};\n\nstr_tok_t stack[256]; \nstr_tok_t queue[256];\nint l_queue, l_stack;\n#define qpush(x) queue[l_queue++] = x\n#define spush(x) stack[l_stack++] = x\n#define spop()   stack[--l_stack]\n\nvoid display(const char *s)\n{\n\tint i;\n\tprintf(\"\\033[1;1H\\033[JText | %s\", s);\n\tprintf(\"\\nStack| \");\n\tfor (i = 0; i < l_stack; i++)\n\t\tprintf(\"%.*s \", stack[i].len, stack[i].s); \n\tprintf(\"\\nQueue| \");\n\tfor (i = 0; i < l_queue; i++)\n\t\tprintf(\"%.*s \", queue[i].len, queue[i].s);\n\tputs(\"\\n\\n<press enter>\");\n\tgetchar();\n}\n\nint prec_booster;\n\n#define fail(s1, s2) {fprintf(stderr, \"[Error %s] %s\\n\", s1, s2); return 0;}\n\nint init(void)\n{\n\tint i;\n\tpat_t *p;\n\n\tfor (i = 0, p = pat_ops; p[i].str; i++)\n\t\tif (regcomp(&(p[i].re), p[i].str, REG_NEWLINE|REG_EXTENDED))\n\t\t\tfail(\"comp\", p[i].str);\n\n\tfor (i = 0, p = pat_arg; p[i].str; i++)\n\t\tif (regcomp(&(p[i].re), p[i].str, REG_NEWLINE|REG_EXTENDED))\n\t\t\tfail(\"comp\", p[i].str);\n\n\treturn 1;\n}\n\npat_t* match(const char *s, pat_t *p, str_tok_t * t, const char **e)\n{\n\tint i;\n\tregmatch_t m;\n\n\twhile (*s == ' ') s++;\n\t*e = s;\n\n\tif (!*s) return &pat_eos;\n\n\tfor (i = 0; p[i].str; i++) {\n\t\tif (regexec(&(p[i].re), s, 1, &m, REG_NOTEOL))\n\t\t\tcontinue;\n\t\tt->s = s;\n\t\t*e = s + (t->len = m.rm_eo - m.rm_so);\n\t\treturn p + i;\n\t}\n\treturn 0;\n}\n\nint parse(const char *s) {\n\tpat_t *p;\n\tstr_tok_t *t, tok;\n\n\tprec_booster = l_queue = l_stack = 0;\n\tdisplay(s);\n\twhile (*s) {\n\t\tp = match(s, pat_arg, &tok, &s);\n\t\tif (!p || p == &pat_eos) fail(\"parse arg\", s);\n\n\t\t\n\t\tif (p->prec == -1) {\n\t\t\tprec_booster += 100;\n\t\t\tcontinue;\n\t\t}\n\t\tqpush(tok);\n\t\tdisplay(s);\n\nre_op:\t\tp = match(s, pat_ops, &tok, &s);\n\t\tif (!p) fail(\"parse op\", s);\n\n\t\ttok.assoc = p->assoc;\n\t\ttok.prec = p->prec;\n\n\t\tif (p->prec > 0)\n\t\t\ttok.prec = p->prec + prec_booster;\n\t\telse if (p->prec == -1) {\n\t\t\tif (prec_booster < 100)\n\t\t\t\tfail(\"unmatched )\", s);\n\t\t\ttok.prec = prec_booster;\n\t\t}\n\n\t\twhile (l_stack) {\n\t\t\tt = stack + l_stack - 1;\n\t\t\tif (!(t->prec == tok.prec && t->assoc == A_L)\n\t\t\t\t\t&& t->prec <= tok.prec)\n\t\t\t\tbreak;\n\t\t\tqpush(spop());\n\t\t\tdisplay(s);\n\t\t}\n\n\t\tif (p->prec == -1) {\n\t\t\tprec_booster -= 100;\n\t\t\tgoto re_op;\n\t\t}\n\n\t\tif (!p->prec) {\n\t\t\tdisplay(s);\n\t\t\tif (prec_booster)\n\t\t\t\tfail(\"unmatched (\", s);\n\t\t\treturn 1;\n\t\t}\n\n\t\tspush(tok);\n\t\tdisplay(s);\n\t}\n\n\tif (p->prec > 0)\n\t\tfail(\"unexpected eol\", s);\n\n\treturn 1;\n}\n\nint main()\n{\n\tint i;\n\tconst char *tests[] = { \n\t\t\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\",\t\n\t\t\"123\",\t\t\t\t\t\n\t\t\"3+4 * 2 / ( 1 - 5 ) ^ 2 ^ 3.14\",\t\n\t\t\"(((((((1+2+3**(4 + 5))))))\",\t\t\n\t\t\"a^(b + c/d * .1e5)!\",\t\t\t\n\t\t\"(1**2)**3\",\t\t\t\t\n\t\t\"2 + 2 *\",\t\t\t\t\n\t\t0\n\t};\n\n\tif (!init()) return 1;\n\tfor (i = 0; tests[i]; i++) {\n\t\tprintf(\"Testing string `%s'   <enter>\\n\", tests[i]);\n\t\tgetchar();\n\n\t\tprintf(\"string `%s': %s\\n\\n\", tests[i],\n\t\t\tparse(tests[i]) ? \"Ok\" : \"Error\");\n\t}\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nvar input = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n\nvar opa = map[string]struct {\n    prec   int\n    rAssoc bool\n}{\n    \"^\": {4, true},\n    \"*\": {3, false},\n    \"/\": {3, false},\n    \"+\": {2, false},\n    \"-\": {2, false},\n}\n\nfunc main() {\n    fmt.Println(\"infix:  \", input)\n    fmt.Println(\"postfix:\", parseInfix(input))\n}\n\nfunc parseInfix(e string) (rpn string) {\n    var stack []string \n    for _, tok := range strings.Fields(e) {\n        switch tok {\n        case \"(\":\n            stack = append(stack, tok) \n        case \")\":\n            var op string\n            for {\n                \n                op, stack = stack[len(stack)-1], stack[:len(stack)-1]\n                if op == \"(\" {\n                    break \n                }\n                rpn += \" \" + op \n            }\n        default:\n            if o1, isOp := opa[tok]; isOp {\n                \n                for len(stack) > 0 {\n                    \n                    op := stack[len(stack)-1]\n                    if o2, isOp := opa[op]; !isOp || o1.prec > o2.prec ||\n                        o1.prec == o2.prec && o1.rAssoc {\n                        break\n                    }\n                    \n                    stack = stack[:len(stack)-1] \n                    rpn += \" \" + op              \n                }\n                \n                stack = append(stack, tok)\n            } else { \n                if rpn > \"\" {\n                    rpn += \" \"\n                }\n                rpn += tok \n            }\n        }\n    }\n    \n    for len(stack) > 0 {\n        rpn += \" \" + stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n    }\n    return\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 10,
    "input": "Translate C to C++:#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef int bool;\n\nchar grid[8][8];\n\nvoid placeKings() {\n    int r1, r2, c1, c2;\n    for (;;) {\n        r1 = rand() % 8;\n        c1 = rand() % 8;\n        r2 = rand() % 8;\n        c2 = rand() % 8;\n        if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1) {\n            grid[r1][c1] = 'K';\n            grid[r2][c2] = 'k';\n            return;\n        }\n    }\n}\n\nvoid placePieces(const char *pieces, bool isPawn) {\n    int n, r, c;\n    int numToPlace = rand() % strlen(pieces);\n    for (n = 0; n < numToPlace; ++n) {\n        do {\n            r = rand() % 8;\n            c = rand() % 8;\n        }\n        while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));\n        grid[r][c] = pieces[n];\n    }\n}\n\nvoid toFen() {\n    char fen[80], ch;\n    int r, c, countEmpty = 0, index = 0;\n    for (r = 0; r < 8; ++r) {\n        for (c = 0; c < 8; ++c) {\n            ch = grid[r][c];\n            printf(\"%2c \", ch == 0 ? '.' : ch);\n            if (ch == 0) {\n                countEmpty++;\n            }\n            else {\n                if (countEmpty > 0) {\n                    fen[index++] = countEmpty + 48;\n                    countEmpty = 0;               \n                }\n                fen[index++] = ch;\n            }\n        }\n        if (countEmpty > 0) {\n            fen[index++] = countEmpty + 48;\n            countEmpty = 0;\n        }\n        fen[index++]= '/';\n        printf(\"\\n\");\n    }\n    strcpy(fen + index, \" w - - 0 1\");\n    printf(\"%s\\n\", fen);\n}\n\nchar *createFen() {\n    placeKings();\n    placePieces(\"PPPPPPPP\", TRUE);\n    placePieces(\"pppppppp\", TRUE);\n    placePieces(\"RNBQBNR\", FALSE);\n    placePieces(\"rnbqbnr\", FALSE);\n    toFen();\n}\n\nint main() {\n    srand(time(NULL));\n    createFen();\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <ctime>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nclass chessBoard {\npublic:\n    void generateRNDBoard( int brds ) {\n        int a, b, i; char c;\n        for( int cc = 0; cc < brds; cc++ ) {\n            memset( brd, 0, 64 );\n            std::string pieces = \"PPPPPPPPNNBBRRQKppppppppnnbbrrqk\";\n            random_shuffle( pieces.begin(), pieces.end() );\n\n            while( pieces.length() ) {\n                i = rand() % pieces.length(); c = pieces.at( i );\n                while( true ) {\n                    a = rand() % 8; b = rand() % 8;\n                    if( brd[a][b] == 0 ) {\n                        if( c == 'P' && !b || c == 'p' && b == 7 || \n                          ( ( c == 'K' || c == 'k' ) && search( c == 'k' ? 'K' : 'k', a, b ) ) ) continue;\n                        break;\n                    }\n                }\n                brd[a][b] = c;\n                pieces = pieces.substr( 0, i ) + pieces.substr( i + 1 );\n            }\n            print();\n        }\n    }\nprivate:\n    bool search( char c, int a, int b ) {\n        for( int y = -1; y < 2; y++ ) {\n            for( int x = -1; x < 2; x++ ) {\n                if( !x && !y ) continue;\n                if( a + x > -1 && a + x < 8 && b + y >-1 && b + y < 8 ) {\n                    if( brd[a + x][b + y] == c ) return true;\n                }\n            }\n        }\n        return false;\n    }\n    void print() {\n        int e = 0;\n        for( int y = 0; y < 8; y++ ) {\n            for( int x = 0; x < 8; x++ ) {\n                if( brd[x][y] == 0 ) e++;\n                else {\n                    if( e > 0 ) { std::cout << e; e = 0; }\n                    std::cout << brd[x][y];\n                }\n            }\n            if( e > 0 ) { std::cout << e; e = 0; } \n            if( y < 7 ) std::cout << \"/\";\n        }\n        std::cout << \" w - - 0 1\\n\\n\";\n\n        for( int y = 0; y < 8; y++ ) {\n            for( int x = 0; x < 8; x++ ) {\n                if( brd[x][y] == 0 ) std::cout << \".\";\n                else std::cout << brd[x][y];\n            }\n            std::cout << \"\\n\";\n        }\n\n        std::cout << \"\\n\\n\";\n    }\n    char brd[8][8];\n};\nint main( int argc, char* argv[] ) {\n    srand( ( unsigned )time( 0 ) );\n    chessBoard c;\n    c.generateRNDBoard( 2 );\n    return 0;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 11,
    "input": "Translate C to Go:#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define TRUE 1\n#define FALSE 0\n#define TRILLION 1000000000000\n\ntypedef unsigned char bool;\ntypedef unsigned long long uint64;\n\nvoid sieve(uint64 limit, uint64 *primes, uint64 *length) {\n    uint64 i, count, p, p2;\n    bool *c = calloc(limit + 1, sizeof(bool));  \n    primes[0] = 2;\n    count  = 1;\n    \n    p = 3;\n    for (;;) {\n        p2 = p * p;\n        if (p2 > limit) break;\n        for (i = p2; i <= limit; i += 2 * p) c[i] = TRUE;\n        for (;;) {\n            p += 2;\n            if (!c[p]) break;\n        }\n    }\n    for (i = 3; i <= limit; i += 2) {\n        if (!c[i]) primes[count++] = i;\n    }\n    *length = count;\n    free(c);\n}\n\nvoid squareFree(uint64 from, uint64 to, uint64 *results, uint64 *len) {    \n    uint64 i, j, p, p2, np, count = 0, limit = (uint64)sqrt((double)to);\n    uint64 *primes = malloc((limit + 1) * sizeof(uint64));\n    bool add;\n    sieve(limit, primes, &np);\n    for (i = from; i <= to; ++i) {\n        add = TRUE;\n        for (j = 0; j < np; ++j) {\n            p = primes[j];\n            p2 = p * p;\n            if (p2 > i) break;\n            if (i % p2 == 0) {\n                add = FALSE;\n                break;\n            }\n        }\n        if (add) results[count++] = i;\n    }\n    *len = count;\n    free(primes);\n}\n\nint main() {\n    uint64 i, *sf, len;\n    \n    sf = malloc(1000000 * sizeof(uint64));\n    printf(\"Square-free integers from 1 to 145:\\n\");\n    squareFree(1, 145, sf, &len);\n    for (i = 0; i < len; ++i) {\n        if (i > 0 && i % 20 == 0) {\n            printf(\"\\n\");\n        }\n        printf(\"%4lld\", sf[i]);\n    }\n\n    printf(\"\\n\\nSquare-free integers from %ld to %ld:\\n\", TRILLION, TRILLION + 145);\n    squareFree(TRILLION, TRILLION + 145, sf, &len);\n    for (i = 0; i < len; ++i) {\n        if (i > 0 && i % 5 == 0) {\n            printf(\"\\n\");\n        }\n        printf(\"%14lld\", sf[i]);\n    }\n\n    printf(\"\\n\\nNumber of square-free integers:\\n\");\n    int a[5] = {100, 1000, 10000, 100000, 1000000};\n    for (i = 0; i < 5; ++i) {\n        squareFree(1, a[i], sf, &len);\n        printf(\"  from %d to %d = %lld\\n\", 1, a[i], len);\n    }\n    free(sf);\n    return 0;   \n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc sieve(limit uint64) []uint64 {\n    primes := []uint64{2}\n    c := make([]bool, limit+1) \n    \n    p := uint64(3)\n    for {\n        p2 := p * p\n        if p2 > limit {\n            break\n        }\n        for i := p2; i <= limit; i += 2 * p {\n            c[i] = true\n        }\n        for {\n            p += 2\n            if !c[p] {\n                break\n            }\n        }\n    }\n    for i := uint64(3); i <= limit; i += 2 {\n        if !c[i] {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc squareFree(from, to uint64) (results []uint64) {\n    limit := uint64(math.Sqrt(float64(to)))\n    primes := sieve(limit)\nouter:\n    for i := from; i <= to; i++ {\n        for _, p := range primes {\n            p2 := p * p\n            if p2 > i {\n                break\n            }\n            if i%p2 == 0 {\n                continue outer\n            }\n        }\n        results = append(results, i)\n    }\n    return\n}\n\nconst trillion uint64 = 1000000000000\n\nfunc main() {\n    fmt.Println(\"Square-free integers from 1 to 145:\")\n    sf := squareFree(1, 145)\n    for i := 0; i < len(sf); i++ {\n        if i > 0 && i%20 == 0 {\n            fmt.Println()\n        }\n        fmt.Printf(\"%4d\", sf[i])\n    }\n\n    fmt.Printf(\"\\n\\nSquare-free integers from %d to %d:\\n\", trillion, trillion+145)\n    sf = squareFree(trillion, trillion+145)\n    for i := 0; i < len(sf); i++ {\n        if i > 0 && i%5 == 0 {\n            fmt.Println()\n        }\n        fmt.Printf(\"%14d\", sf[i])\n    }\n\n    fmt.Println(\"\\n\\nNumber of square-free integers:\\n\")\n    a := [...]uint64{100, 1000, 10000, 100000, 1000000}\n    for _, n := range a {\n        fmt.Printf(\"  from %d to %d = %d\\n\", 1, n, len(squareFree(1, n)))\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 12,
    "input": "Translate C to VB:#include <stdio.h>\n\nvoid divisor_count_and_sum(unsigned int n, unsigned int* pcount,\n                           unsigned int* psum) {\n    unsigned int divisor_count = 1;\n    unsigned int divisor_sum = 1;\n    unsigned int power = 2;\n    for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n        ++divisor_count;\n        divisor_sum += power;\n    }\n    for (unsigned int p = 3; p * p <= n; p += 2) {\n        unsigned int count = 1, sum = 1;\n        for (power = p; n % p == 0; power *= p, n /= p) {\n            ++count;\n            sum += power;\n        }\n        divisor_count *= count;\n        divisor_sum *= sum;\n    }\n    if (n > 1) {\n        divisor_count *= 2;\n        divisor_sum *= n + 1;\n    }\n    *pcount = divisor_count;\n    *psum = divisor_sum;\n}\n\nint main() {\n    unsigned int arithmetic_count = 0;\n    unsigned int composite_count = 0;\n\n    for (unsigned int n = 1; arithmetic_count <= 1000000; ++n) {\n        unsigned int divisor_count;\n        unsigned int divisor_sum;\n        divisor_count_and_sum(n, &divisor_count, &divisor_sum);\n        if (divisor_sum % divisor_count != 0)\n            continue;\n        ++arithmetic_count;\n        if (divisor_count > 2)\n            ++composite_count;\n        if (arithmetic_count <= 100) {\n            printf(\"%3u \", n);\n            if (arithmetic_count % 10 == 0)\n                printf(\"\\n\");\n        }\n        if (arithmetic_count == 1000 || arithmetic_count == 10000 ||\n            arithmetic_count == 100000 || arithmetic_count == 1000000) {\n            printf(\"\\n%uth arithmetic number is %u\\n\", arithmetic_count, n);\n            printf(\"Number of composite arithmetic numbers <= %u: %u\\n\", n,\n                   composite_count);\n        }\n    }\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "\n\n\nfunction isarit_compo(i)\n     cnt=0\n     sum=0\n     for j=1 to sqr(i)\n       if (i mod j)=0 then \n          k=i\\j \n             \n         if k=j then \n            cnt=cnt+1:sum=sum+j \n         else  \n            cnt=cnt+2:sum=sum+j+k \n         end if\n       end if\n     next\n   avg= sum/cnt\n   isarit_compo= array((fix(avg)=avg),-(cnt>2))\nend function\n\nfunction rpad(a,n) rpad=right(space(n)&a,n) :end function\n\ndim s1\nsub print(s) \n  s1=s1& rpad(s,4)\n  if len(s1)=40 then wscript.stdout.writeline s1:s1=\"\"\nend sub\n\n\ncntr=0\ncntcompo=0\ni=1\nwscript.stdout.writeline \"the first 100 arithmetic numbers are:\"\ndo\n  a=isarit_compo(i)\n  if a(0) then  \n    cntcompo=cntcompo+a(1)\n    cntr=cntr+1\n    if cntr<=100 then print i\n    if cntr=1000 then wscript.stdout.writeline vbcrlf&\"1000th   : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=10000 then wscript.stdout.writeline vbcrlf& \"10000th  : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=100000 then wscript.stdout.writeline vbcrlf &\"100000th : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6):exit do\n  end if \n  i=i+1\nloop\n",
    "input_language": "C",
    "output_language": "VB"
  },
  {
    "id": 13,
    "input": "Translate C to Python:count = 1;\n while (count < 10) {\n     print(\"count is: \", count, \"\\n\");\n     count = count + 1;\n }\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def expr(p)\n    if tok is \"(\"\n        x = paren_expr()\n    elif tok in [\"-\", \"+\", \"!\"]\n        gettok()\n        y = expr(precedence of operator)\n        if operator was \"+\"\n            x = y\n        else\n            x = make_node(operator, y)\n    elif tok is an Identifier\n        x = make_leaf(Identifier, variable name)\n        gettok()\n    elif tok is an Integer constant\n        x = make_leaf(Integer, integer value)\n        gettok()\n    else\n        error()\n\n    while tok is a binary operator and precedence of tok >= p\n        save_tok = tok\n        gettok()\n        q = precedence of save_tok\n        if save_tok is not right associative\n            q += 1\n        x = make_node(Operator save_tok represents, x, expr(q))\n\n    return x\n\ndef paren_expr()\n    expect(\"(\")\n    x = expr(0)\n    expect(\")\")\n    return x\n\ndef stmt()\n    t = NULL\n    if accept(\"if\")\n        e = paren_expr()\n        s = stmt()\n        t = make_node(If, e, make_node(If, s, accept(\"else\") ? stmt() : NULL))\n    elif accept(\"putc\")\n        t = make_node(Prtc, paren_expr())\n        expect(\";\")\n    elif accept(\"print\")\n        expect(\"(\")\n        repeat\n            if tok is a string\n                e = make_node(Prts, make_leaf(String, the string))\n                gettok()\n            else\n                e = make_node(Prti, expr(0))\n\n            t = make_node(Sequence, t, e)\n        until not accept(\",\")\n        expect(\")\")\n        expect(\";\")\n    elif tok is \";\"\n        gettok()\n    elif tok is an Identifier\n        v = make_leaf(Identifier, variable name)\n        gettok()\n        expect(\"=\")\n        t = make_node(Assign, v, expr(0))\n        expect(\";\")\n    elif accept(\"while\")\n        e = paren_expr()\n        t = make_node(While, e, stmt()\n    elif accept(\"{\")\n        while tok not equal \"}\" and tok not equal end-of-file\n            t = make_node(Sequence, t, stmt())\n        expect(\"}\")\n    elif tok is end-of-file\n        pass\n    else\n        error()\n    return t\n\ndef parse()\n    t = NULL\n    gettok()\n    repeat\n        t = make_node(Sequence, t, stmt())\n    until tok is end-of-file\n    return t\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 14,
    "input": "Translate C to PHP:\n#define _CRT_SECURE_NO_WARNINGS  \n#include <stdio.h>\n\nint main(void)\n{\n    return 0 >= fputs(\"ANY STRING TO WRITE TO A FILE AT ONCE.\", \n        freopen(\"sample.txt\",\"wb\",stdout));\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "file_put_contents($filename, $data)\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 15,
    "input": "Translate C++ to VB:\nclass N{\n  uint n,i,g,e,l;\npublic:\n  N(uint n): n(n-1),i{},g{},e(1),l(n-1){}\n  bool hasNext(){\n    g=(1<<n)+e;for(i=l;i<n;++i) g+=1<<i;\n    if (l==2)             {l=--n; e=1; return true;}\n    if (e<((1<<(l-1))-1)) {++e;        return true;}\n                           e=1; --l;   return (l>0);\n  }\n  uint next() {return g;}\n};\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "\n\nFunction noncontsubseq(l)\n    Dim  i, j, g, n, r, s, w, m\n    Dim  a, b, c\n    n = Ubound(l)\n    For s = 0 To n-2\n        For g = s+1 To n-1\n            a = \"[\"\n            For i = s To g-1\n                a = a & l(i) & \", \"\n            Next \n            For w = 1 To n-g\n                r = n+1-g-w\n                For i = 1 To 2^r-1 Step 2\n                    b = a\n                    For j = 0 To r-1\n                        If i And 2^j Then b=b & l(g+w+j) & \", \"\n                    Next \n                    c = (Left(b, Len(b)-1))\n                    WScript.Echo Left(c, Len(c)-1) & \"]\"\n\t\t\t\t\tm = m+1\n                Next \n            Next \n        Next \n    Next \n    noncontsubseq = m\nEnd Function \n\nlist = Array(\"1\", \"2\", \"3\", \"4\")\nWScript.Echo \"List: [\" & Join(list, \", \") & \"]\"\nnn = noncontsubseq(list)\nWScript.Echo nn & \" non-continuous subsequences\"\n",
    "input_language": "C++",
    "output_language": "VB"
  },
  {
    "id": 16,
    "input": "Translate Python to VB:\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "\n\n\n\nGraphicsWindow.DrawText(10, 10, \"Hit any key to dump.\")\nGraphicsWindow.KeyDown = OnKeyDown\nSub OnKeyDown\n  TextWindow.WriteLine(GraphicsWindow.LastKey)\nEndSub\n",
    "input_language": "Python",
    "output_language": "VB"
  },
  {
    "id": 17,
    "input": "Translate Java to Python:import java.util.function.Function;\n\npublic class NumericalIntegrationAdaptiveSimpsons {\n\n    public static void main(String[] args) {\n        Function<Double,Double> f = x -> sin(x);\n        System.out.printf(\"integrate sin(x), x = 0 .. Pi = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, Math.PI, 1e-8), functionCount);\n        functionCount = 0;\n        System.out.printf(\"integrate sin(x), x = 0 .. 1 = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, 1, 1e-8), functionCount);\n    }\n    \n    private static double quadratureAdaptiveSimpsons(Function<Double,Double> function, double a, double b, double error) {\n        double fa = function.apply(a);\n        double fb = function.apply(b);\n        Triple t =  quadratureAdaptiveSimpsonsOne(function, a, fa, b ,fb);\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, b, fb, error, t.s, t.x, t.fx);\n    }\n    \n    private static double quadratureAdaptiveSimpsonsRecursive(Function<Double,Double> function, double a, double fa, double b, double fb, double error, double whole, double m, double fm) {\n        Triple left  = quadratureAdaptiveSimpsonsOne(function, a, fa, m, fm);\n        Triple right = quadratureAdaptiveSimpsonsOne(function, m, fm, b, fb);\n        double delta = left.s + right.s - whole;\n        if ( Math.abs(delta) <= 15*error ) {\n            return left.s + right.s + delta / 15;\n        }\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, m, fm, error/2, left.s, left.x, left.fx) +\n               quadratureAdaptiveSimpsonsRecursive(function, m, fm, b, fb, error/2, right.s, right.x, right.fx);\n    }\n    \n    private static Triple quadratureAdaptiveSimpsonsOne(Function<Double,Double> function, double a, double fa, double b, double fb) {\n        double m = (a + b) / 2;\n        double fm = function.apply(m);\n        return new Triple(m, fm, Math.abs(b-a) / 6 * (fa + 4*fm + fb));\n    }\n    \n    private static class Triple {\n        double x, fx, s;\n        private Triple(double m, double fm, double s) {\n            this.x = m;\n            this.fx = fm;\n            this.s = s;\n        }\n    }\n    \n    private static int functionCount = 0;\n    \n    private static double sin(double x) {\n        functionCount++;\n        return Math.sin(x);\n    }\n    \n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\n\n\nimport math\n\nimport collections\ntriple = collections.namedtuple('triple', 'm fm simp')\n\ndef _quad_simpsons_mem(f: callable, a: float , fa: float, b: float, fb: float)->tuple:\n    \n    m = a + (b - a) / 2\n    fm = f(m)\n    simp = abs(b - a) / 6 * (fa + 4*fm + fb)\n    return triple(m, fm, simp,)\n \ndef _quad_asr(f: callable, a: float, fa: float, b: float, fb: float, eps: float, whole: float, m: float, fm: float)->float:\n    \n    lt = _quad_simpsons_mem(f, a, fa, m, fm)\n    rt = _quad_simpsons_mem(f, m, fm, b, fb)\n    delta = lt.simp + rt.simp - whole\n    return (lt.simp + rt.simp + delta/15\n        if (abs(delta) <= eps * 15) else\n            _quad_asr(f, a, fa, m, fm, eps/2, lt.simp, lt.m, lt.fm) +\n            _quad_asr(f, m, fm, b, fb, eps/2, rt.simp, rt.m, rt.fm)\n    )\n\ndef quad_asr(f: callable, a: float, b: float, eps: float)->float:\n    \n    fa = f(a)\n    fb = f(b)\n    t = _quad_simpsons_mem(f, a, fa, b, fb)\n    return _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm)\n\ndef main():\n    (a, b,) = (0.0, 1.0,)\n    sinx = quad_asr(math.sin, a, b, 1e-09);\n    print(\"Simpson's integration of sine from {} to {} = {}\\n\".format(a, b, sinx))\n\nmain()\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 18,
    "input": "Translate Java to Python:import java.util.Random;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class GaltonBox {\n    public static void main( final String[] args ) {\n        new GaltonBox( 8, 200 ).run();\n    }\n\n    private final int        m_pinRows;\n    private final int        m_startRow;\n    private final Position[] m_balls;\n    private final Random     m_random = new Random();\n\n    public GaltonBox( final int pinRows, final int ballCount ) {\n        m_pinRows  = pinRows;\n        m_startRow = pinRows + 1;\n        m_balls    = new Position[ ballCount ];\n\n        for ( int ball = 0; ball < ballCount; ball++ )\n            m_balls[ ball ] = new Position( m_startRow, 0, 'o' );\n    }\n\n    private static class Position {\n        int  m_row;\n        int  m_col;\n        char m_char;\n\n        Position( final int row, final int col, final char ch ) {\n            m_row  = row;\n            m_col  = col;\n            m_char = ch;\n        }\n    }\n\n    public void run() {\n        for ( int ballsInPlay = m_balls.length; ballsInPlay > 0;  ) {\n            ballsInPlay = dropBalls();\n            print();\n        }\n    }\n\n    private int dropBalls() {\n        int ballsInPlay = 0;\n        int ballToStart = -1;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( m_balls[ ball ].m_row == m_startRow )\n                ballToStart = ball;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( ball == ballToStart ) {\n                m_balls[ ball ].m_row = m_pinRows;\n                ballsInPlay++;\n            }\n            else if ( m_balls[ ball ].m_row > 0 && m_balls[ ball ].m_row != m_startRow ) {\n                m_balls[ ball ].m_row -= 1;\n                m_balls[ ball ].m_col += m_random.nextInt( 2 );\n                if ( 0 != m_balls[ ball ].m_row )\n                    ballsInPlay++;\n            }\n\n        return ballsInPlay;\n    }\n\n    private void print() {\n        for ( int row = m_startRow; row --> 1;  ) {\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == row )\n                    printBall( m_balls[ ball ] );\n            System.out.println();\n            printPins( row );\n        }\n        printCollectors();\n        System.out.println();\n    }\n\n    private static void printBall( final Position pos ) {\n        for ( int col = pos.m_row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = 0; col < pos.m_col; col++ )\n            System.out.print( \"  \" );\n        System.out.print( pos.m_char );\n    }\n\n    private void printPins( final int row ) {\n        for ( int col = row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = m_startRow - row; col --> 0;  )\n            System.out.print( \". \" );\n        System.out.println();\n    }\n\n    private void printCollectors() {\n        final List<List<Position>> collectors = new ArrayList<List<Position>>();\n\n        for ( int col = 0; col < m_startRow; col++ ) {\n            final List<Position> collector = new ArrayList<Position>();\n\n            collectors.add( collector );\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == 0 && m_balls[ ball ].m_col == col )\n                    collector.add( m_balls[ ball ] );\n        }\n\n        for ( int row = 0, rows = longest( collectors ); row < rows; row++ ) {\n            for ( int col = 0; col < m_startRow; col++ ) {\n                final List<Position> collector = collectors.get( col );\n                final int            pos       = row + collector.size() - rows;\n\n                System.out.print( '|' );\n                if ( pos >= 0 )\n                    System.out.print( collector.get( pos ).m_char );\n                else\n                    System.out.print( ' ' );\n            }\n            System.out.println( '|' );\n        }\n    }\n\n    private static final int longest( final List<List<Position>> collectors ) {\n        int result = 0;\n\n        for ( final List<Position> collector : collectors )\n            result = Math.max( collector.size(), result );\n\n        return result;\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\nimport sys, os\nimport random\nimport time\n\ndef print_there(x, y, text):\n     sys.stdout.write(\"\\x1b7\\x1b[%d;%df%s\\x1b8\" % (x, y, text))\n     sys.stdout.flush()\n\n\nclass Ball():\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        \n    def update(self):\n        self.x += random.randint(0,1)\n        self.y += 1\n\n    def fall(self):\n        self.y +=1\n\n\nclass Board():\n    def __init__(self, width, well_depth, N):\n        self.balls = []\n        self.fallen = [0] * (width + 1)\n        self.width = width\n        self.well_depth = well_depth\n        self.N = N\n        self.shift = 4\n        \n    def update(self):\n        for ball in self.balls:\n            if ball.y < self.width:\n                ball.update()\n            elif ball.y < self.width + self.well_depth - self.fallen[ball.x]:\n                ball.fall()\n            elif ball.y == self.width + self.well_depth - self.fallen[ball.x]:\n                self.fallen[ball.x] += 1\n            else:\n                pass\n                \n    def balls_on_board(self):\n        return len(self.balls) - sum(self.fallen)\n                \n    def add_ball(self):\n        if(len(self.balls) <= self.N):\n            self.balls.append(Ball())\n\n    def print_board(self):\n        for y in range(self.width + 1):\n            for x in range(y):\n                print_there( y + 1 ,self.width - y + 2*x + self.shift + 1, \"\n    def print_ball(self, ball):\n        if ball.y <= self.width:\n            x = self.width - ball.y + 2*ball.x + self.shift\n        else:\n            x = 2*ball.x + self.shift\n        y = ball.y + 1\n        print_there(y, x, \"*\")\n         \n    def print_all(self):\n        print(chr(27) + \"[2J\")\n        self.print_board();\n        for ball in self.balls:\n            self.print_ball(ball)\n\n\ndef main():\n    board = Board(width = 15, well_depth = 5, N = 10)\n    board.add_ball() \n    while(board.balls_on_board() > 0):\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.add_ball()\n\n\nif __name__==\"__main__\":\n    main()\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 19,
    "input": "Translate Python to Go:\n\nfrom collections import Counter\n\ndef decompose_sum(s):\n    return [(a,s-a) for a in range(2,int(s/2+1))]\n\n\nall_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100)\n\n\nproduct_counts = Counter(c*d for c,d in all_pairs)\nunique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)\ns_pairs = [(a,b) for a,b in all_pairs if\n    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))]\n\n\nproduct_counts = Counter(c*d for c,d in s_pairs)\np_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1]\n\n\nsum_counts = Counter(c+d for c,d in p_pairs)\nfinal_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1]\n\nprint(final_pairs)\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\ntype pair struct{ x, y int }\n\nfunc main() {\n\t\n\t\n\t\n\tconst max = 1685\n\tvar all []pair\n\tfor a := 2; a < max; a++ {\n\t\tfor b := a + 1; b < max-a; b++ {\n\t\t\tall = append(all, pair{a, b})\n\t\t}\n\t}\n\tfmt.Println(\"There are\", len(all), \"pairs where a+b <\", max, \"(and a<b)\")\n\tproducts := countProducts(all)\n\n\t\n\t\n\tvar sPairs []pair\npairs:\n\tfor _, p := range all {\n\t\ts := p.x + p.y\n\t\t\n\t\tfor a := 2; a < s/2+s&1; a++ {\n\t\t\tb := s - a\n\t\t\tif products[a*b] == 1 {\n\t\t\t\t\n\t\t\t\tcontinue pairs\n\t\t\t}\n\t\t}\n\t\tsPairs = append(sPairs, p)\n\t}\n\tfmt.Println(\"S starts with\", len(sPairs), \"possible pairs.\")\n\t\n\tsProducts := countProducts(sPairs)\n\n\t\n\t\n\tvar pPairs []pair\n\tfor _, p := range sPairs {\n\t\tif sProducts[p.x*p.y] == 1 {\n\t\t\tpPairs = append(pPairs, p)\n\t\t}\n\t}\n\tfmt.Println(\"P then has\", len(pPairs), \"possible pairs.\")\n\t\n\tpSums := countSums(pPairs)\n\n\t\n\tvar final []pair\n\tfor _, p := range pPairs {\n\t\tif pSums[p.x+p.y] == 1 {\n\t\t\tfinal = append(final, p)\n\t\t}\n\t}\n\n\t\n\tswitch len(final) {\n\tcase 1:\n\t\tfmt.Println(\"Answer:\", final[0].x, \"and\", final[0].y)\n\tcase 0:\n\t\tfmt.Println(\"No possible answer.\")\n\tdefault:\n\t\tfmt.Println(len(final), \"possible answers:\", final)\n\t}\n}\n\nfunc countProducts(list []pair) map[int]int {\n\tm := make(map[int]int)\n\tfor _, p := range list {\n\t\tm[p.x*p.y]++\n\t}\n\treturn m\n}\n\nfunc countSums(list []pair) map[int]int {\n\tm := make(map[int]int)\n\tfor _, p := range list {\n\t\tm[p.x+p.y]++\n\t}\n\treturn m\n}\n\n\nfunc decomposeSum(s int) []pair {\n\tpairs := make([]pair, 0, s/2)\n\tfor a := 2; a < s/2+s&1; a++ {\n\t\tpairs = append(pairs, pair{a, s - a})\n\t}\n\treturn pairs\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 20,
    "input": "Translate Python to Go:\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc xor(a, b byte) byte {\n    return a&(^b) | b&(^a)\n}\n\nfunc ha(a, b byte) (s, c byte) {\n    return xor(a, b), a & b\n}\n\nfunc fa(a, b, c0 byte) (s, c1 byte) {\n    sa, ca := ha(a, c0)\n    s, cb := ha(sa, b)\n    c1 = ca | cb\n    return\n}\n\nfunc add4(a3, a2, a1, a0, b3, b2, b1, b0 byte) (v, s3, s2, s1, s0 byte) {\n    s0, c0 := fa(a0, b0, 0)\n    s1, c1 := fa(a1, b1, c0)\n    s2, c2 := fa(a2, b2, c1)\n    s3, v = fa(a3, b3, c2)\n    return\n}\n\nfunc main() {\n    \n    fmt.Println(add4(1, 0, 1, 0, 1, 0, 0, 1))\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 21,
    "input": "Translate C to Python:#include<string.h>\n#include<stdlib.h>\n#include<ctype.h>\n#include<stdio.h>\n\n#define UNITS_LENGTH 13\n\nint main(int argC,char* argV[])\n{\n\tint i,reference;\n\tchar *units[UNITS_LENGTH] = {\"kilometer\",\"meter\",\"centimeter\",\"tochka\",\"liniya\",\"diuym\",\"vershok\",\"piad\",\"fut\",\"arshin\",\"sazhen\",\"versta\",\"milia\"};\n    double factor, values[UNITS_LENGTH] = {1000.0,1.0,0.01,0.000254,0.00254,0.0254,0.04445,0.1778,0.3048,0.7112,2.1336,1066.8,7467.6};\n\t\n\tif(argC!=3)\n\t\tprintf(\"Usage : %s followed by length as <value> <unit>\");\n\telse{\n\t\tfor(i=0;argV[2][i]!=00;i++)\n\t\t\targV[2][i] = tolower(argV[2][i]);\n\t\t\n\t\tfor(i=0;i<UNITS_LENGTH;i++){\n\t\t\tif(strstr(argV[2],units[i])!=NULL){\n\t\t\t\treference = i;\n\t\t\t\tfactor = atof(argV[1])*values[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%s %s is equal in length to : \\n\",argV[1],argV[2]);\n\t\t\n\t\tfor(i=0;i<UNITS_LENGTH;i++){\n\t\t\tif(i!=reference)\n\t\t\t\tprintf(\"\\n%lf %s\",factor/values[i],units[i]);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from sys import argv\n \nunit2mult = {\"arshin\": 0.7112, \"centimeter\": 0.01,     \"diuym\":   0.0254,\n             \"fut\":    0.3048, \"kilometer\":  1000.0,   \"liniya\":  0.00254,\n             \"meter\":  1.0,    \"milia\":      7467.6,   \"piad\":    0.1778,\n             \"sazhen\": 2.1336, \"tochka\":     0.000254, \"vershok\": 0.04445,\n             \"versta\": 1066.8}\n \nif __name__ == '__main__':\n    assert len(argv) == 3, 'ERROR. Need two arguments - number then units'\n    try:\n        value = float(argv[1])\n    except:\n        print('ERROR. First argument must be a (float) number')\n        raise\n    unit = argv[2]\n    assert unit in unit2mult, ( 'ERROR. Only know the following units: ' \n                                + ' '.join(unit2mult.keys()) )\n\n    print(\"%g %s to:\" % (value, unit))\n    for unt, mlt in sorted(unit2mult.items()):\n        print('  %10s: %g' % (unt, value * unit2mult[unit] / mlt))\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 22,
    "input": "Translate C to C#:#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nint main(void) {\n    int nprimes =  1000000;\n    int nmax =    ceil(nprimes*(log(nprimes)+log(log(nprimes))-0.9385));  \n      \n      \n    int i, j, m, k; int *a;\n    k = (nmax-2)/2; \n    a = (int *)calloc(k + 1, sizeof(int));\n    for(i = 0; i <= k; i++)a[i] = 2*i+1; \n    for (i = 1; (i+1)*i*2 <= k; i++)\n        for (j = i; j <= (k-i)/(2*i+1); j++) {\n            m = i + j + 2*i*j;\n            if(a[m]) a[m] = 0;\n            }            \n        \n    for (i = 1, j = 0; i <= k; i++) \n       if (a[i]) {\n           if(j%10 == 0 && j <= 100)printf(\"\\n\");\n           j++; \n           if(j <= 100)printf(\"%3d \", a[i]);\n           else if(j == nprimes){\n               printf(\"\\n%d th prime is %d\\n\",j,a[i]);\n               break;\n               }\n           }\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nclass Program\n{\n    static string fmt(int[] a)\n    {\n        var sb = new System.Text.StringBuilder();\n        for (int i = 0; i < a.Length; i++)\n            sb.Append(string.Format(\"{0,5}{1}\",\n              a[i], i % 10 == 9 ? \"\\n\" : \" \"));\n        return sb.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        var pr = PG.Sundaram(15_500_000).Take(1_000_000).ToArray();\n        sw.Stop();\n        Write(\"The first 100 odd prime numbers:\\n{0}\\n\",\n          fmt(pr.Take(100).ToArray()));\n        Write(\"The millionth odd prime number: {0}\", pr.Last());\n        Write(\"\\n{0} ms\", sw.Elapsed.TotalMilliseconds);\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<int> Sundaram(int n)\n    {\n        \n        int i = 1, k = (n + 1) >> 1, t = 1, v = 1, d = 1, s = 1;\n        var comps = new bool[k + 1];\n        for (; t < k; t = ((++i + (s += d += 2)) << 1) - d - 2)\n            while ((t += d + 2) < k)\n                comps[t] = true;\n        for (; v < k; v++)\n            if (!comps[v])\n                yield return (v << 1) + 1;\n    }\n}\n",
    "input_language": "C",
    "output_language": "C#"
  },
  {
    "id": 23,
    "input": "Translate C to Go:#include <stdio.h>\n\nvoid transpose(void *dest, void *src, int src_h, int src_w)\n{\n\tint i, j;\n\tdouble (*d)[src_h] = dest, (*s)[src_w] = src;\n\tfor (i = 0; i < src_h; i++)\n\t\tfor (j = 0; j < src_w; j++)\n\t\t\td[j][i] = s[i][j];\n}\n\nint main()\n{\n\tint i, j;\n\tdouble a[3][5] = {{ 0, 1, 2, 3, 4 },\n\t\t\t  { 5, 6, 7, 8, 9 },\n\t\t\t  { 1, 0, 0, 0, 42}};\n\tdouble b[5][3];\n\ttranspose(b, a, 3, 5);\n\n\tfor (i = 0; i < 5; i++)\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tprintf(\"%g%c\", b[i][j], j == 2 ? '\\n' : ' ');\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n\n    \"gonum.org/v1/gonum/mat\"\n)\n\nfunc main() {\n    m := mat.NewDense(2, 3, []float64{\n        1, 2, 3,\n        4, 5, 6,\n    })\n    fmt.Println(mat.Formatted(m))\n    fmt.Println()\n    fmt.Println(mat.Formatted(m.T()))\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 24,
    "input": "Translate C# to VB:using System;\n\nstatic class YCombinator<T, TResult>\n{\n    \n    private delegate Func<T, TResult> RecursiveFunc(RecursiveFunc r);\n\n    public static Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>> Fix { get; } =\n        f => ((RecursiveFunc)(g => f(x => g(g)(x))))(g => f(x => g(g)(x)));\n}\n\nstatic class Program\n{\n    static void Main()\n    {\n        var fac = YCombinator<int, int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));\n        var fib = YCombinator<int, int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));\n\n        Console.WriteLine(fac(10));\n        Console.WriteLine(fib(10));\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Private Function call_fn(f As String, n As Long) As Long\n    call_fn = Application.Run(f, f, n)\nEnd Function\n \nPrivate Function Y(f As String) As String\n    Y = f\nEnd Function\n \nPrivate Function fac(self As String, n As Long) As Long\n    If n > 1 Then\n        fac = n * call_fn(self, n - 1)\n    Else\n        fac = 1\n    End If\nEnd Function\n \nPrivate Function fib(self As String, n As Long) As Long\n    If n > 1 Then\n        fib = call_fn(self, n - 1) + call_fn(self, n - 2)\n    Else\n        fib = n\n    End If\nEnd Function\n \nPrivate Sub test(name As String)\n    Dim f As String: f = Y(name)\n    Dim i As Long\n    Debug.Print name\n    For i = 1 To 10\n        Debug.Print call_fn(f, i);\n    Next i\n    Debug.Print\nEnd Sub\n\nPublic Sub main()\n    test \"fac\"\n    test \"fib\"\nEnd Sub\n",
    "input_language": "C#",
    "output_language": "VB"
  },
  {
    "id": 25,
    "input": "Translate Java to Python:import java.io.*;\n\npublic class FileIODemo {\n  public static void main(String[] args) {\n    try {\n      FileInputStream in = new FileInputStream(\"input.txt\");\n      FileOutputStream out = new FileOutputStream(\"ouput.txt\");\n      int c;\n      while ((c = in.read()) != -1) {\n        out.write(c);\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e){\n      e.printStackTrace();\n    }\n  }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import shutil\nshutil.copyfile('input.txt', 'output.txt')\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 26,
    "input": "Translate Java to Go:import com.sun.javafx.application.PlatformImpl;\nimport java.io.File;\nimport java.util.Scanner;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javafx.scene.media.Media;\nimport javafx.scene.media.MediaPlayer;\n\npublic class AudioAlarm {\n\n    public static void main(String[] args) throws InterruptedException {\n        Scanner input = new Scanner(System.in);\n\n        System.out.print(\"Enter a number of seconds: \");\n        int seconds = Integer.parseInt(input.nextLine());\n\n        System.out.print(\"Enter a filename (must end with .mp3 or .wav): \");\n        String audio = input.nextLine();\n\n        TimeUnit.SECONDS.sleep(seconds);\n\n        Media media = new Media(new File(audio).toURI().toString());\n        AtomicBoolean stop = new AtomicBoolean();\n        Runnable onEnd = () -> stop.set(true);\n\n        PlatformImpl.startup(() -> {}); \n\n        MediaPlayer player = new MediaPlayer(media);\n        player.setOnEndOfMedia(onEnd);\n        player.setOnError(onEnd);\n        player.setOnHalted(onEnd);\n        player.play();\n\n        while (!stop.get()) {\n            Thread.sleep(100);\n        }\n        System.exit(0); \n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"os/exec\"\n    \"strconv\"\n    \"time\"\n)\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    number := 0\n    for number < 1 {\n        fmt.Print(\"Enter number of seconds delay > 0 : \")\n        scanner.Scan()\n        input := scanner.Text()\n        if err := scanner.Err(); err != nil {\n            log.Fatal(err)\n        }\n        number, _ = strconv.Atoi(input)\n    }\n\n    filename := \"\"\n    for filename == \"\" {\n        fmt.Print(\"Enter name of .mp3 file to play (without extension) : \")\n        scanner.Scan()\n        filename = scanner.Text()\n        if err := scanner.Err(); err != nil {\n            log.Fatal(err)\n        }\n    }\n\n    cls := \"\\033[2J\\033[0;0H\" \n    fmt.Printf(\"%sAlarm will sound in %d seconds...\", cls, number)\n    time.Sleep(time.Duration(number) * time.Second)\n    fmt.Printf(cls)\n    cmd := exec.Command(\"play\", filename+\".mp3\")\n    if err := cmd.Run(); err != nil {\n        log.Fatal(err)\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 27,
    "input": "Translate Java to Python:public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": ">>> from itertools import product\n>>> nuggets = set(range(101))\n>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):\n\tnuggets.discard(6*s + 9*n + 20*t)\n\n\t\n>>> max(nuggets)\n43\n>>>\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 28,
    "input": "Translate Python to Go:print('\\n'.join((f'{x[0]}: {\" \".join(sorted(x[1]))}' if len(x[1]) < 30 else f'{x[0]}: {len(x[1])} words' for x in\n      (x for x in ((n, [x[1] for x in l if x[0] == n]) for n in range(maxlen, -1, -1)) if x[1]))) if (maxlen := max(l := [(len(c), w)\n      for w in [l for l in [l.rstrip() for l in open('unixdict.txt')] if len(l) > 10 and all(c >= 'a' and c <= 'z' for c in l)]\n      if sorted(c := w.replace('a', '').replace('e', '').replace('i', '').replace('o', '').replace('u', '')) == sorted(set(c))])[0]) else None)\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"unicode/utf8\"\n)\n\nfunc contains(list []int, value int) bool {\n    for _, v := range list {\n        if v == value {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    wordList := \"unixdict.txt\"\n    b, err := ioutil.ReadFile(wordList)\n    if err != nil {\n        log.Fatal(\"Error reading file\")\n    }\n    bwords := bytes.Fields(b)\n    var words []string\n    for _, bword := range bwords {\n        s := string(bword)\n        if utf8.RuneCountInString(s) > 10 {\n            words = append(words, s)\n        }\n    }\n    vowelIndices := []int{0, 4, 8, 14, 20}\n    wordGroups := make([][]string, 12)\n    for _, word := range words {\n        letters := make([]int, 26)\n        for _, c := range word {\n            index := c - 97\n            if index >= 0 && index < 26 {\n                letters[index]++\n            }\n        }\n        eligible := true\n        uc := 0 \n        for i := 0; i < 26; i++ {\n            if !contains(vowelIndices, i) {\n                if letters[i] > 1 {\n                    eligible = false\n                    break\n                } else if letters[i] == 1 {\n                    uc++\n                }\n            }\n        }\n        if eligible {\n            wordGroups[uc] = append(wordGroups[uc], word)\n        }\n    }\n\n    for i := 11; i >= 0; i-- {\n        count := len(wordGroups[i])\n        if count > 0 {\n            s := \"s\"\n            if count == 1 {\n                s = \"\"\n            }\n            fmt.Printf(\"%d word%s found with %d unique consonants:\\n\", count, s, i)\n            for j := 0; j < count; j++ {\n                fmt.Printf(\"%-15s\", wordGroups[i][j])\n                if j > 0 && (j+1)%5 == 0 {\n                    fmt.Println()\n                }\n            }\n            fmt.Println()\n            if count%5 != 0 {\n                fmt.Println()\n            }\n        }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 29,
    "input": "Translate C++ to C#:#include <algorithm>\n#include <iostream>\n#include <iterator>\n\ntemplate <typename RandomAccessIterator>\nvoid bubble_sort(RandomAccessIterator begin, RandomAccessIterator end) {\n  bool swapped = true;\n  while (begin != end-- && swapped) {\n    swapped = false;\n    for (auto i = begin; i != end; ++i) {\n      if (*(i + 1) < *i) {\n        std::iter_swap(i, i + 1);\n        swapped = true;\n      }\n    }\n  }\n}\n\nint main() {\n  int a[] = {100, 2, 56, 200, -52, 3, 99, 33, 177, -199};\n  bubble_sort(std::begin(a), std::end(a));\n  copy(std::begin(a), std::end(a), std::ostream_iterator<int>(std::cout, \" \"));\n  std::cout << \"\\n\";\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 30,
    "input": "Translate PHP to C#:$myObj = new Object();\n$serializedObj = serialize($myObj);\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Runtime.Serialization.Formatters.Binary;\n\nnamespace Object_serialization\n{\n  [Serializable] public class Being\n  {\n    public bool Alive { get; set; }\n  }\n\n  [Serializable] public class Animal: Being\n  {\n    public Animal() { }\n\n    public Animal(long id, string name, bool alive = true)\n    {\n      Id = id;\n      Name = name;\n      Alive = alive;\n    }\n\n    public long Id { get; set; }\n    public string Name { get; set; }\n\n    public void Print() { Console.WriteLine(\"{0}, id={1} is {2}\",\n      Name, Id, Alive ? \"alive\" : \"dead\"); }\n  }\n\n\n  internal class Program\n  {\n    private static void Main()\n    {\n      string path = \n        Environment.GetFolderPath(Environment.SpecialFolder.Desktop)+\"\\\\objects.dat\";\n\n      var n = new List<Animal>\n              {\n                new Animal(1, \"Fido\"),\n                new Animal(2, \"Lupo\"),\n                new Animal(7, \"Wanda\"),\n                new Animal(3, \"Kiki\", alive: false)\n              };\n\n      foreach(Animal animal in n)\n        animal.Print();\n\n      using(var stream = new FileStream(path, FileMode.Create, FileAccess.Write))\n        new BinaryFormatter().Serialize(stream, n);\n\n      n.Clear();\n      Console.WriteLine(\"---------------\");\n      List<Animal> m;\n\n      using(var stream = new FileStream(path, FileMode.Open, FileAccess.Read))\n        m = (List<Animal>) new BinaryFormatter().Deserialize(stream);\n\n      foreach(Animal animal in m)\n        animal.Print();\n    }\n  }\n}\n",
    "input_language": "PHP",
    "output_language": "C#"
  },
  {
    "id": 31,
    "input": "Translate PHP to Python:<?php\n$a = fgets(STDIN);\n$b = fgets(STDIN);\n\necho\n    \"sum:                 \", $a + $b, \"\\n\",\n    \"difference:          \", $a - $b, \"\\n\",\n    \"product:             \", $a * $b, \"\\n\",\n    \"truncating quotient: \", (int)($a / $b), \"\\n\",\n    \"flooring quotient:   \", floor($a / $b), \"\\n\",\n    \"remainder:           \", $a % $b, \"\\n\",\n    \"power:               \", $a ** $b, \"\\n\"; // PHP 5.6+ only\n?>\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 32,
    "input": "Translate C to C#:#include <stdio.h>\n\n\nint mul_inv(int a, int b)\n{\n\tint b0 = b, t, q;\n\tint x0 = 0, x1 = 1;\n\tif (b == 1) return 1;\n\twhile (a > 1) {\n\t\tq = a / b;\n\t\tt = b, b = a % b, a = t;\n\t\tt = x0, x0 = x1 - q * x0, x1 = t;\n\t}\n\tif (x1 < 0) x1 += b0;\n\treturn x1;\n}\n\nint chinese_remainder(int *n, int *a, int len)\n{\n\tint p, i, prod = 1, sum = 0;\n\n\tfor (i = 0; i < len; i++) prod *= n[i];\n\n\tfor (i = 0; i < len; i++) {\n\t\tp = prod / n[i];\n\t\tsum += a[i] * mul_inv(p, n[i]) * p;\n\t}\n\n\treturn sum % prod;\n}\n\nint main(void)\n{\n\tint n[] = { 3, 5, 7 };\n\tint a[] = { 2, 3, 2 };\n\n\tprintf(\"%d\\n\", chinese_remainder(n, a, sizeof(n)/sizeof(n[0])));\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Linq;\n\nnamespace ChineseRemainderTheorem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] n = { 3, 5, 7 };\n            int[] a = { 2, 3, 2 };\n\n            int result = ChineseRemainderTheorem.Solve(n, a);\n\n            int counter = 0;\n            int maxCount = n.Length - 1;\n            while (counter <= maxCount)\n            {\n                Console.WriteLine($\"{result} ≡ {a[counter]} (mod {n[counter]})\");\n                counter++;\n            }\n        }\n    }\n\n    public static class ChineseRemainderTheorem\n    {\n        public static int Solve(int[] n, int[] a)\n        {\n            int prod = n.Aggregate(1, (i, j) => i * j);\n            int p;\n            int sm = 0;\n            for (int i = 0; i < n.Length; i++)\n            {\n                p = prod / n[i];\n                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;\n            }\n            return sm % prod;\n        }\n\n        private static int ModularMultiplicativeInverse(int a, int mod)\n        {\n            int b = a % mod;\n            for (int x = 1; x < mod; x++)\n            {\n                if ((b * x) % mod == 1)\n                {\n                    return x;\n                }\n            }\n            return 1;\n        }\n    }\n}\n",
    "input_language": "C",
    "output_language": "C#"
  },
  {
    "id": 33,
    "input": "Translate C to PHP:#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double x, y; } vec;\ntypedef struct { int n; vec* v; } polygon_t, *polygon;\n\n#define BIN_V(op, xx, yy) vec v##op(vec a,vec b){vec c;c.x=xx;c.y=yy;return c;}\n#define BIN_S(op, r) double v##op(vec a, vec b){ return r; }\nBIN_V(sub, a.x - b.x, a.y - b.y);\nBIN_V(add, a.x + b.x, a.y + b.y);\nBIN_S(dot, a.x * b.x + a.y * b.y);\nBIN_S(cross, a.x * b.y - a.y * b.x);\n\n\nvec vmadd(vec a, double s, vec b)\n{\n\tvec c;\n\tc.x = a.x + s * b.x;\n\tc.y = a.y + s * b.y;\n\treturn c;\n}\n\n\nint intersect(vec x0, vec x1, vec y0, vec y1, double tol, vec *sect)\n{\n\tvec dx = vsub(x1, x0), dy = vsub(y1, y0);\n\tdouble d = vcross(dy, dx), a;\n\tif (!d) return 0; \n\n\ta = (vcross(x0, dx) - vcross(y0, dx)) / d;\n\tif (sect)\n\t\t*sect = vmadd(y0, a, dy);\n\n\tif (a < -tol || a > 1 + tol) return -1;\n\tif (a < tol || a > 1 - tol) return 0;\n\n\ta = (vcross(x0, dy) - vcross(y0, dy)) / d;\n\tif (a < 0 || a > 1) return -1;\n\n\treturn 1;\n}\n\n\ndouble dist(vec x, vec y0, vec y1, double tol)\n{\n\tvec dy = vsub(y1, y0);\n\tvec x1, s;\n\tint r;\n\n\tx1.x = x.x + dy.y; x1.y = x.y - dy.x;\n\tr = intersect(x, x1, y0, y1, tol, &s);\n\tif (r == -1) return HUGE_VAL;\n\ts = vsub(s, x);\n\treturn sqrt(vdot(s, s));\n}\n\n#define for_v(i, z, p) for(i = 0, z = p->v; i < p->n; i++, z++)\n\nint inside(vec v, polygon p, double tol)\n{\n\t\n\tint i, k, crosses, intersectResult;\n\tvec *pv;\n\tdouble min_x, max_x, min_y, max_y;\n\n\tfor (i = 0; i < p->n; i++) {\n\t\tk = (i + 1) % p->n;\n\t\tmin_x = dist(v, p->v[i], p->v[k], tol);\n\t\tif (min_x < tol) return 0;\n\t}\n\n\tmin_x = max_x = p->v[0].x;\n\tmin_y = max_y = p->v[1].y;\n\n\t\n\tfor_v(i, pv, p) {\n\t\tif (pv->x > max_x) max_x = pv->x;\n\t\tif (pv->x < min_x) min_x = pv->x;\n\t\tif (pv->y > max_y) max_y = pv->y;\n\t\tif (pv->y < min_y) min_y = pv->y;\n\t}\n\tif (v.x < min_x || v.x > max_x || v.y < min_y || v.y > max_y)\n\t\treturn -1;\n\n\tmax_x -= min_x; max_x *= 2;\n\tmax_y -= min_y; max_y *= 2;\n\tmax_x += max_y;\n\n\tvec e;\n\twhile (1) {\n\t\tcrosses = 0;\n\t\t\n\t\te.x = v.x + (1 + rand() / (RAND_MAX + 1.)) * max_x;\n\t\te.y = v.y + (1 + rand() / (RAND_MAX + 1.)) * max_x;\n\n\t\tfor (i = 0; i < p->n; i++) {\n\t\t\tk = (i + 1) % p->n;\n\t\t\tintersectResult = intersect(v, e, p->v[i], p->v[k], tol, 0);\n\n\t\t\t\n\t\t\tif (!intersectResult) break;\n\n\t\t\tif (intersectResult == 1) crosses++;\n\t\t}\n\t\tif (i == p->n) break;\n\t}\n\treturn (crosses & 1) ? 1 : -1;\n}\n\nint main()\n{\n\tvec vsq[] = {\t{0,0}, {10,0}, {10,10}, {0,10},\n\t\t\t{2.5,2.5}, {7.5,0.1}, {7.5,7.5}, {2.5,7.5}};\n\n\tpolygon_t sq = { 4, vsq }, \n\t\tsq_hole = { 8, vsq }; \n\n\tvec c = { 10, 5 }; \n\tvec d = { 5, 5 };\n\n\tprintf(\"%d\\n\", inside(c, &sq, 1e-10));\n\tprintf(\"%d\\n\", inside(c, &sq_hole, 1e-10));\n\n\tprintf(\"%d\\n\", inside(d, &sq, 1e-10));\t\n\tprintf(\"%d\\n\", inside(d, &sq_hole, 1e-10));  \n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\n\nfunction contains($bounds, $lat, $lng)\n{\n    $count = 0;\n    $bounds_count = count($bounds);\n    for ($b = 0; $b < $bounds_count; $b++) {\n        $vertex1 = $bounds[$b];\n        $vertex2 = $bounds[($b + 1) % $bounds_count];\n        if (west($vertex1, $vertex2, $lng, $lat))\n            $count++;\n    }\n\n    return $count % 2;\n}\n\nfunction west($A, $B, $x, $y)\n{\n    if ($A['y'] <= $B['y']) {\n        if ($y <= $A['y'] || $y > $B['y'] ||\n            $x >= $A['x'] && $x >= $B['x']) {\n            return false;\n        }\n        if ($x < $A['x'] && $x < $B['x']) {\n            return true;\n        }\n        if ($x == $A['x']) {\n            if ($y == $A['y']) {\n                $result1 = NAN;\n            } else {\n                $result1 = INF;\n            }\n        } else {\n            $result1 = ($y - $A['y']) / ($x - $A['x']);\n        }\n        if ($B['x'] == $A['x']) {\n            if ($B['y'] == $A['y']) {\n                $result2 = NAN;\n            } else {\n                $result2 = INF;\n            }\n        } else {\n            $result2 = ($B['y'] - $A['y']) / ($B['x'] - $A['x']);\n        }\n        return $result1 > $result2;\n    }\n\n    return west($B, $A, $x, $y);\n}\n\n$square = [\n    'name' => 'square',\n    'bounds' => [['x' => 0, 'y' => 0], ['x' => 20, 'y' => 0], ['x' => 20, 'y' => 20], ['x' => 0, 'y' => 20]]\n];\n$squareHole = [\n    'name' => 'squareHole',\n    'bounds' => [['x' => 0, 'y' => 0], ['x' => 20, 'y' => 0], ['x' => 20, 'y' => 20], ['x' => 0, 'y' => 20], ['x' => 5, 'y' => 5], ['x' => 15, 'y' => 5], ['x' => 15, 'y' => 15], ['x' => 5, 'y' => 15]]\n];\n$strange = [\n    'name' => 'strange',\n    'bounds' => [['x' => 0, 'y' => 0], ['x' => 5, 'y' => 5], ['x' => 0, 'y' => 20], ['x' => 5, 'y' => 15], ['x' => 15, 'y' => 15], ['x' => 20, 'y' => 20], ['x' => 20, 'y' => 0]]\n];\n$hexagon = [\n    'name' => 'hexagon',\n    'bounds' => [['x' => 6, 'y' => 0], ['x' => 14, 'y' => 0], ['x' => 20, 'y' => 10], ['x' => 14, 'y' => 20], ['x' => 6, 'y' => 20], ['x' => 0, 'y' => 10]]\n];\n \n$shapes = [$square, $squareHole, $strange, $hexagon];\n\n$testPoints = [\n    ['lng' => 10, 'lat' => 10],\n    ['lng' => 10, 'lat' => 16],\n    ['lng' => -20, 'lat' => 10],\n    ['lng' => 0, 'lat' => 10],\n    ['lng' => 20, 'lat' => 10],\n    ['lng' => 16, 'lat' => 10],\n    ['lng' => 20, 'lat' => 20]\n];\n \nfor ($s = 0; $s < count($shapes); $s++) {\n    $shape = $shapes[$s];\n    for ($tp = 0; $tp < count($testPoints); $tp++) {\n        $testPoint = $testPoints[$tp];\n        echo json_encode($testPoint) . \"\\tin \" . $shape['name'] . \"\\t\" . contains($shape['bounds'], $testPoint['lat'], $testPoint['lng']) . PHP_EOL;\n    }\n}\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 34,
    "input": "Translate C to Java:#include <stdio.h>\n\n\nint mul_inv(int a, int b)\n{\n\tint b0 = b, t, q;\n\tint x0 = 0, x1 = 1;\n\tif (b == 1) return 1;\n\twhile (a > 1) {\n\t\tq = a / b;\n\t\tt = b, b = a % b, a = t;\n\t\tt = x0, x0 = x1 - q * x0, x1 = t;\n\t}\n\tif (x1 < 0) x1 += b0;\n\treturn x1;\n}\n\nint chinese_remainder(int *n, int *a, int len)\n{\n\tint p, i, prod = 1, sum = 0;\n\n\tfor (i = 0; i < len; i++) prod *= n[i];\n\n\tfor (i = 0; i < len; i++) {\n\t\tp = prod / n[i];\n\t\tsum += a[i] * mul_inv(p, n[i]) * p;\n\t}\n\n\treturn sum % prod;\n}\n\nint main(void)\n{\n\tint n[] = { 3, 5, 7 };\n\tint a[] = { 2, 3, 2 };\n\n\tprintf(\"%d\\n\", chinese_remainder(n, a, sizeof(n)/sizeof(n[0])));\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import static java.util.Arrays.stream;\n\npublic class ChineseRemainderTheorem {\n\n    public static int chineseRemainder(int[] n, int[] a) {\n\n        int prod = stream(n).reduce(1, (i, j) -> i * j);\n\n        int p, sm = 0;\n        for (int i = 0; i < n.length; i++) {\n            p = prod / n[i];\n            sm += a[i] * mulInv(p, n[i]) * p;\n        }\n        return sm % prod;\n    }\n\n    private static int mulInv(int a, int b) {\n        int b0 = b;\n        int x0 = 0;\n        int x1 = 1;\n\n        if (b == 1)\n            return 1;\n\n        while (a > 1) {\n            int q = a / b;\n            int amb = a % b;\n            a = b;\n            b = amb;\n            int xqx = x1 - q * x0;\n            x1 = x0;\n            x0 = xqx;\n        }\n\n        if (x1 < 0)\n            x1 += b0;\n\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        int[] n = {3, 5, 7};\n        int[] a = {2, 3, 2};\n        System.out.println(chineseRemainder(n, a));\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 35,
    "input": "Translate C++ to Java:#include <iostream>\n#include <functional>\n#include <map>\n#include <vector>\n\nstruct Node {\n    int length;\n    std::map<char, int> edges;\n    int suffix;\n\n    Node(int l) : length(l), suffix(0) {\n        \n    }\n\n    Node(int l, const std::map<char, int>& m, int s) : length(l), edges(m), suffix(s) {\n        \n    }\n};\n\nconstexpr int evenRoot = 0;\nconstexpr int oddRoot = 1;\n\nstd::vector<Node> eertree(const std::string& s) {\n    std::vector<Node> tree = {\n        Node(0, {}, oddRoot),\n        Node(-1, {}, oddRoot)\n    };\n    int suffix = oddRoot;\n    int n, k;\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        for (n = suffix; ; n = tree[n].suffix) {\n            k = tree[n].length;\n            int b = i - k - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n\n        auto it = tree[n].edges.find(c);\n        auto end = tree[n].edges.end();\n        if (it != end) {\n            suffix = it->second;\n            continue;\n        }\n        suffix = tree.size();\n        tree.push_back(Node(k + 2));\n        tree[n].edges[c] = suffix;\n        if (tree[suffix].length == 1) {\n            tree[suffix].suffix = 0;\n            continue;\n        }\n        while (true) {\n            n = tree[n].suffix;\n            int b = i - tree[n].length - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n        tree[suffix].suffix = tree[n].edges[c];\n    }\n\n    return tree;\n}\n\nstd::vector<std::string> subPalindromes(const std::vector<Node>& tree) {\n    std::vector<std::string> s;\n\n    std::function<void(int, std::string)> children;\n    children = [&children, &tree, &s](int n, std::string p) {\n        auto it = tree[n].edges.cbegin();\n        auto end = tree[n].edges.cend();\n        for (; it != end; it = std::next(it)) {\n            auto c = it->first;\n            auto m = it->second;\n\n            std::string pl = c + p + c;\n            s.push_back(pl);\n            children(m, pl);\n        }\n    };\n    children(0, \"\");\n\n    auto it = tree[1].edges.cbegin();\n    auto end = tree[1].edges.cend();\n    for (; it != end; it = std::next(it)) {\n        auto c = it->first;\n        auto n = it->second;\n\n        std::string ct(1, c);\n        s.push_back(ct);\n\n        children(n, ct);\n    }\n\n    return s;\n}\n\nint main() {\n    using namespace std;\n\n    auto tree = eertree(\"eertree\");\n    auto pal = subPalindromes(tree);\n\n    auto it = pal.cbegin();\n    auto end = pal.cend();\n\n    cout << \"[\";\n    if (it != end) {\n        cout << it->c_str();\n        it++;\n    }\n    while (it != end) {\n        cout << \", \" << it->c_str();\n        it++;\n    }\n    cout << \"]\" << endl;\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Eertree {\n    public static void main(String[] args) {\n        List<Node> tree = eertree(\"eertree\");\n        List<String> result = subPalindromes(tree);\n        System.out.println(result);\n    }\n\n    private static class Node {\n        int length;\n        Map<Character, Integer> edges = new HashMap<>();\n        int suffix;\n\n        public Node(int length) {\n            this.length = length;\n        }\n\n        public Node(int length, Map<Character, Integer> edges, int suffix) {\n            this.length = length;\n            this.edges = edges != null ? edges : new HashMap<>();\n            this.suffix = suffix;\n        }\n    }\n\n    private static final int EVEN_ROOT = 0;\n    private static final int ODD_ROOT = 1;\n\n    private static List<Node> eertree(String s) {\n        List<Node> tree = new ArrayList<>();\n        tree.add(new Node(0, null, ODD_ROOT));\n        tree.add(new Node(-1, null, ODD_ROOT));\n        int suffix = ODD_ROOT;\n        int n, k;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            for (n = suffix; ; n = tree.get(n).suffix) {\n                k = tree.get(n).length;\n                int b = i - k - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            if (tree.get(n).edges.containsKey(c)) {\n                suffix = tree.get(n).edges.get(c);\n                continue;\n            }\n            suffix = tree.size();\n            tree.add(new Node(k + 2));\n            tree.get(n).edges.put(c, suffix);\n            if (tree.get(suffix).length == 1) {\n                tree.get(suffix).suffix = 0;\n                continue;\n            }\n            while (true) {\n                n = tree.get(n).suffix;\n                int b = i - tree.get(n).length - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            tree.get(suffix).suffix = tree.get(n).edges.get(c);\n        }\n        return tree;\n    }\n\n    private static List<String> subPalindromes(List<Node> tree) {\n        List<String> s = new ArrayList<>();\n        subPalindromes_children(0, \"\", tree, s);\n        for (Map.Entry<Character, Integer> cm : tree.get(1).edges.entrySet()) {\n            String ct = String.valueOf(cm.getKey());\n            s.add(ct);\n            subPalindromes_children(cm.getValue(), ct, tree, s);\n        }\n        return s;\n    }\n\n    \n    private static void subPalindromes_children(final int n, final String p, final List<Node> tree, List<String> s) {\n        for (Map.Entry<Character, Integer> cm : tree.get(n).edges.entrySet()) {\n            Character c = cm.getKey();\n            Integer m = cm.getValue();\n            String pl = c + p + c;\n            s.add(pl);\n            subPalindromes_children(m, pl, tree, s);\n        }\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 36,
    "input": "Translate C++ to C#:#include <iostream>\n#include <sstream>\n\ntypedef long long bigInt;\n\nusing namespace std;\n\nclass number\n{\npublic:\n    number()                                { s = \"0\"; neg = false; }\n    number( bigInt a )                      { set( a ); }\n    number( string a )                      { set( a ); }\n    void set( bigInt a )                    { neg = false; if( a < 0 ) { a = -a; neg = true; } ostringstream o; o << a; s = o.str(); clearStr(); }\n    void set( string a )                    { neg = false; s = a; if( s.length() > 1 && s[0] == '-' ) { neg = true; } clearStr(); }\n    number operator *  ( const number& b )  { return this->mul( b ); }\n    number& operator *= ( const number& b ) { *this = *this * b; return *this; }\n    number& operator = ( const number& b )  { s = b.s; return *this; }\n    friend ostream& operator << ( ostream& out, const number& a ) { if( a.neg ) out << \"-\"; out << a.s; return out; }\n    friend istream& operator >> ( istream& in, number& a ){ string b; in >> b; a.set( b ); return in; }\n\nprivate:\n    number mul( const number& b )\n    {\n\tnumber a; bool neg = false;\n\tstring r, bs = b.s; r.resize( 2 * max( b.s.length(), s.length() ), '0' );\n\tint xx, ss, rr, t, c, stp = 0;\n\tstring::reverse_iterator xi = bs.rbegin(), si, ri;\n\tfor( ; xi != bs.rend(); xi++ )\n\t{\n\t    c = 0; ri = r.rbegin() + stp;\n\t    for( si = s.rbegin(); si != s.rend(); si++ )\n\t    {\n\t\txx = ( *xi ) - 48; ss = ( *si ) - 48; rr = ( *ri ) - 48;\n\t\tss = ss * xx + rr + c; t = ss % 10; c = ( ss - t ) / 10;\n\t\t( *ri++ ) = t + 48;\n\t    }\n\t    if( c > 0 ) ( *ri ) = c + 48;\n\t    stp++;\n\t}\n\ttrimLeft( r ); t = b.neg ? 1 : 0; t += neg ? 1 : 0;\n\tif( t & 1 ) a.s = \"-\" + r;\n\telse a.s = r;\n\treturn a;\n    }\n\n    void trimLeft( string& r )\n    {\n\tif( r.length() < 2 ) return;\n\tfor( string::iterator x = r.begin(); x != ( r.end() - 1 ); )\n\t{\n\t    if( ( *x ) != '0' ) return;\n\t    x = r.erase( x );\n\t}\n    }\n\n    void clearStr()\n    {\n\tfor( string::iterator x = s.begin(); x != s.end(); )\n\t{\n\t    if( ( *x ) < '0' || ( *x ) > '9' ) x = s.erase( x );\n\t    else x++;\n\t}\n    }\n    string s;\n    bool neg;\n};\n\nint main( int argc, char* argv[] )\n{\n    number a, b;\n    a.set( \"18446744073709551616\" ); b.set( \"18446744073709551616\" );\n    cout << a * b << endl << endl;\n\n    cout << \"Factor 1 = \"; cin >> a;\n    cout << \"Factor 2 = \"; cin >> b;\n    cout << \"Product: = \" << a * b << endl << endl;\n    return system( \"pause\" );\n}\n\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n  static decimal mx = 1E28M, hm = 1E14M, a;\n\n  \n  struct bi { public decimal hi, lo; }\n\n  \n  static bi set4sq(decimal a) { bi r; r.hi = Math.Floor(a / hm); r.lo = a % hm; return r; }\n\n  \n  static string toStr(bi a, bool comma = false) {\n    string r = a.hi == 0 ? string.Format(\"{0:0}\", a.lo) :\n                           string.Format(\"{0:0}{1:\" + new string('0', 28) + \"}\", a.hi, a.lo);\n    if (!comma) return r;  string rc = \"\";\n    for (int i = r.Length - 3; i > 0; i -= 3) rc = \",\" + r.Substring(i, 3) + rc;\n    return r.Substring(0, ((r.Length + 2) % 3) + 1) + rc; }\n\n  \n  static decimal Pow_dec(decimal bas, uint exp) {\n    if (exp == 0) return 1M; decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 0) return tmp; return tmp * bas; }\n\n  static void Main(string[] args) {\n    for (uint p = 64; p < 95; p += 30) {        \n      bi x = set4sq(a = Pow_dec(2M, p)), y;     \n      WriteLine(\"The square of (2^{0}):                    {1,38:n0}\", p, a); BI BS = BI.Pow((BI)a, 2);\n      y.lo = x.lo * x.lo; y.hi = x.hi * x.hi;   \n      a = x.hi * x.lo * 2M;                     \n      y.hi += Math.Floor(a / hm);               \n      y.lo += (a % hm) * hm;                    \n      while (y.lo > mx) { y.lo -= mx; y.hi++; } \n      WriteLine(\" is {0,75} (which {1} match the BigInteger computation)\\n\", toStr(y, true),\n          BS.ToString() == toStr(y) ? \"does\" : \"fails to\"); } }\n\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 37,
    "input": "Translate C to C++:#include <stdlib.h>\n#include <stdio.h>\n\n#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))\n\nint jacobi(unsigned long a, unsigned long n) {\n\tif (a >= n) a %= n;\n\tint result = 1;\n\twhile (a) {\n\t\twhile ((a & 1) == 0) {\n\t\t\ta >>= 1;\n\t\t\tif ((n & 7) == 3 || (n & 7) == 5) result = -result;\n\t\t}\n\t\tSWAP(a, n);\n\t\tif ((a & 3) == 3 && (n & 3) == 3) result = -result;\n\t\ta %= n;\n\t}\n\tif (n == 1) return result;\n\treturn 0;\n}\n\nvoid print_table(unsigned kmax, unsigned nmax) {\n\tprintf(\"n\\\\k|\");\n\tfor (int k = 0; k <= kmax; ++k) printf(\"%'3u\", k);\n\tprintf(\"\\n----\");\n\tfor (int k = 0; k <= kmax; ++k) printf(\"---\");\n\tputchar('\\n');\n\tfor (int n = 1; n <= nmax; n += 2) {\n\t\tprintf(\"%-2u |\", n);\n\t\tfor (int k = 0; k <= kmax; ++k)\n\t\t\tprintf(\"%'3d\", jacobi(k, n));\n\t\tputchar('\\n');\n\t}\n}\n\nint main() {\n\tprint_table(20, 21);\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <algorithm>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n\nint jacobi(int n, int k) {\n    assert(k > 0 && k % 2 == 1);\n    n %= k;\n    int t = 1;\n    while (n != 0) {\n        while (n % 2 == 0) {\n            n /= 2;\n            int r = k % 8;\n            if (r == 3 || r == 5)\n                t = -t;\n        }\n        std::swap(n, k);\n        if (n % 4 == 3 && k % 4 == 3)\n            t = -t;\n        n %= k;\n    }\n    return k == 1 ? t : 0;\n}\n\nvoid print_table(std::ostream& out, int kmax, int nmax) {\n    out << \"n\\\\k|\";\n    for (int k = 0; k <= kmax; ++k)\n        out << ' ' << std::setw(2) << k;\n    out << \"\\n----\";\n    for (int k = 0; k <= kmax; ++k)\n        out << \"---\";\n    out << '\\n';\n    for (int n = 1; n <= nmax; n += 2) {\n        out << std::setw(2) << n << \" |\";\n        for (int k = 0; k <= kmax; ++k)\n            out << ' ' << std::setw(2) << jacobi(k, n);\n        out << '\\n';\n    }\n}\n\nint main() {\n    print_table(std::cout, 20, 21);\n    return 0;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 38,
    "input": "Translate Go to VB:package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 1; i <= 10; i++ {\n        fmt.Printf(\"%d\", i)\n        if i%5 == 0 {\n            fmt.Printf(\"\\n\")\n            continue\n        }\n        fmt.Printf(\", \")\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "For i = 1 To 10\n    Console.Write(i)\n    If i Mod 5 = 0 Then\n        Console.WriteLine()\n    Else\n        Console.Write(\", \")\n    End If\nNext\n",
    "input_language": "Go",
    "output_language": "VB"
  },
  {
    "id": 39,
    "input": "Translate Java to VB:public class LongMult {\n\n\tprivate static byte[] stringToDigits(String num) {\n\t\tbyte[] result = new byte[num.length()];\n\t\tfor (int i = 0; i < num.length(); i++) {\n\t\t\tchar c = num.charAt(i);\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid digit \" + c\n\t\t\t\t\t\t+ \" found at position \" + i);\n\t\t\t}\n\t\t\tresult[num.length() - 1 - i] = (byte) (c - '0');\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static String longMult(String num1, String num2) {\n\t\tbyte[] left = stringToDigits(num1);\n\t\tbyte[] right = stringToDigits(num2);\n\t\tbyte[] result = new byte[left.length + right.length];\n\t\tfor (int rightPos = 0; rightPos < right.length; rightPos++) {\n\t\t\tbyte rightDigit = right[rightPos];\n\t\t\tbyte temp = 0;\n\t\t\tfor (int leftPos = 0; leftPos < left.length; leftPos++) {\n\t\t\t\ttemp += result[leftPos + rightPos];\n\t\t\t\ttemp += rightDigit * left[leftPos];\n\t\t\t\tresult[leftPos + rightPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\tint destPos = rightPos + left.length;\n\t\t\twhile (temp != 0) {\n\t\t\t\ttemp += result[destPos] & 0xFFFFFFFFL;\n\t\t\t\tresult[destPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t\tdestPos++;\n\t\t\t}\n\t\t}\n\t\tStringBuilder stringResultBuilder = new StringBuilder(result.length);\n\t\tfor (int i = result.length - 1; i >= 0; i--) {\n\t\t\tbyte digit = result[i];\n\t\t\tif (digit != 0 || stringResultBuilder.length() > 0) {\n\t\t\t\tstringResultBuilder.append((char) (digit + '0'));\n\t\t\t}\n\t\t}\n\t\treturn stringResultBuilder.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(longMult(\"18446744073709551616\",\n\t\t\t\t\"18446744073709551616\"));\n\t}\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Imports System\nImports System.Console\nImports BI = System.Numerics.BigInteger\n\nModule Module1\n\n    Dim a As Decimal, mx As Decimal = 1E28D, hm As Decimal = 1E14D\n\n    \n    Structure bd\n        Public hi, lo As Decimal\n    End Structure\n\n    \n    Function toStr(ByVal a As bd, ByVal Optional comma As Boolean = False) As String\n        Dim r As String = If(a.hi = 0, String.Format(\"{0:0}\", a.lo),\n                                       String.Format(\"{0:0}{1:\" & New String(\"0\"c, 28) & \"}\", a.hi, a.lo))\n        If Not comma Then Return r \n        Dim rc As String = \"\"\n        For i As Integer = r.Length - 3 To 0 Step -3\n            rc = \",\" & r.Substring(i, 3) & rc : Next\n        toStr = r.Substring(0, r.Length Mod 3) & rc\n            toStr = toStr.Substring(If(toStr.Chars(0) = \",\" , 1, 0))\n    End Function\n\n    \n    Function Pow_dec(ByVal bas As Decimal, ByVal exp As UInteger) As Decimal\n        If exp = 0 Then Pow_dec = 1D else Pow_dec = Pow_dec(bas, exp >> 1) : _\n        Pow_dec *= Pow_dec : If (exp And 1) <> 0 Then Pow_dec *= bas\n    End Function\n\n    Sub Main(ByVal args As String())\n         For p As UInteger = 64 To 95 - 1 Step 30                 \n            Dim y As bd, x As bd : a = Pow_dec(2D, p)             \n            WriteLine(\"The square of (2^{0}):                    {1,38:n0}\", p, a)\n            x.hi = Math.Floor(a / hm) : x.lo = a Mod hm           \n            Dim BS As BI = BI.Pow(CType(a, BI), 2)                \n            y.lo = x.lo * x.lo : y.hi = x.hi * x.hi               \n            a = x.hi * x.lo * 2D                                  \n            y.hi += Math.Floor(a / hm) : y.lo += (a Mod hm) * hm  \n            While y.lo > mx : y.lo -= mx : y.hi += 1 : End While  \n            WriteLine(\" is {0,75} (which {1} match the BigInteger computation)\" & vbLf,\n                toStr(y, True), If(BS.ToString() = toStr(y), \"does\", \"fails to\"))\n        Next\n    End Sub\n\nEnd Module\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 40,
    "input": "Translate C++ to Java:#include <iostream>\n#include <chrono>\n#include <atomic>\n#include <mutex>\n#include <random>\n#include <thread>\n\nstd::mutex cout_lock;\n\nclass Latch\n{\n    std::atomic<int> semafor;\n  public:\n    Latch(int limit) : semafor(limit) {}\n\n    void wait()\n    {\n        semafor.fetch_sub(1);\n        while(semafor.load() > 0)\n            std::this_thread::yield();\n    }\n};\n\nstruct Worker\n{\n    static void do_work(int how_long, Latch& barrier, std::string name)\n    {\n        std::this_thread::sleep_for(std::chrono::milliseconds(how_long));\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished work\\n\";   }\n        barrier.wait();\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished assembly\\n\";   }\n    }\n};\n\nint main()\n{\n    Latch latch(5);\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_int_distribution<> dist(300, 3000);\n    std::thread threads[] {\n        std::thread(&Worker::do_work, dist(rng), std::ref(latch), \"John\"),\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Henry\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Smith\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Jane\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Mary\"},\n    };\n    for(auto& t: threads) t.join();\n    std::cout << \"Assembly is finished\";\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.Scanner;\nimport java.util.Random;\n\npublic class CheckpointSync{\n\tpublic static void main(String[] args){\n\t\tSystem.out.print(\"Enter number of workers to use: \");\n\t\tScanner in = new Scanner(System.in);\n\t\tWorker.nWorkers = in.nextInt();\n\t\tSystem.out.print(\"Enter number of tasks to complete:\");\n\t\trunTasks(in.nextInt());\n\t}\n\t\n\t\n\tprivate static void runTasks(int nTasks){\n\t\tfor(int i = 0; i < nTasks; i++){\n\t\t\tSystem.out.println(\"Starting task number \" + (i+1) + \".\");\n\t\t\trunThreads();\n\t\t\tWorker.checkpoint();\n\t\t}\n\t}\n\t\n\t\n\tprivate static void runThreads(){\n\t\tfor(int i = 0; i < Worker.nWorkers; i ++){\n\t\t\tnew Thread(new Worker(i+1)).start();\n\t\t}\n\t}\n\t\n\t\n\tpublic static class Worker implements Runnable{\n\t\tpublic Worker(int threadID){\n\t\t\tthis.threadID = threadID;\n\t\t}\n\t\tpublic void run(){\n\t\t\twork();\n\t\t}\n\t\t\n\t\t\n\t\tprivate synchronized void work(){\n\t\t\ttry {\n\t\t\t\tint workTime = rgen.nextInt(900) + 100;\n\t\t\t\tSystem.out.println(\"Worker \" + threadID + \" will work for \" + workTime + \" msec.\");\n\t\t\t\tThread.sleep(workTime); \n\t\t\t\tnFinished++; \n\t\t\t\tSystem.out.println(\"Worker \" + threadID + \" is ready\");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.err.println(\"Error: thread execution interrupted\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static synchronized void checkpoint(){\n\t\t\twhile(nFinished != nWorkers){\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(10);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tSystem.err.println(\"Error: thread execution interrupted\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnFinished = 0;\n\t\t}\n\t\n\t\t\n\t\tprivate int threadID;\n\t\t\n\t\t\n\t\tprivate static Random rgen = new Random();\n\t\tprivate static int nFinished = 0;\n\t\tpublic static int nWorkers = 0;\n\t}\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 41,
    "input": "Translate Java to Go:import java.util.ArrayList;\nimport java.util.List;\n\npublic class SquareFree\n{\n    private static List<Long> sieve(long limit) {\n        List<Long> primes = new ArrayList<Long>();\n        primes.add(2L);\n        boolean[] c = new boolean[(int)limit + 1]; \n        \n        long p = 3;\n        for (;;) {\n            long p2 = p * p;\n            if (p2 > limit) break;\n            for (long i = p2; i <= limit; i += 2 * p) c[(int)i] = true;\n            for (;;) {\n                p += 2;\n                if (!c[(int)p]) break;\n            }\n        }\n        for (long i = 3; i <= limit; i += 2) {\n            if (!c[(int)i]) primes.add(i);\n        }\n        return primes;\n    }\n\n    private static List<Long> squareFree(long from, long to) {\n        long limit = (long)Math.sqrt((double)to);\n        List<Long> primes = sieve(limit);\n        List<Long> results = new ArrayList<Long>();\n\n        outer: for (long i = from; i <= to; i++) {\n            for (long p : primes) {\n                long p2 = p * p;\n                if (p2 > i) break;\n                if (i % p2 == 0) continue outer;\n            }\n            results.add(i);\n        }\n        return results;\n    }\n\n    private final static long TRILLION = 1000000000000L;\n\n    public static void main(String[] args) {\n        System.out.println(\"Square-free integers from 1 to 145:\");\n        List<Long> sf = squareFree(1, 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 20 == 0) {\n                System.out.println();\n            }\n            System.out.printf(\"%4d\", sf.get(i));\n        }\n\n        System.out.print(\"\\n\\nSquare-free integers\");\n        System.out.printf(\" from %d to %d:\\n\", TRILLION, TRILLION + 145);\n        sf = squareFree(TRILLION, TRILLION + 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 5 == 0) System.out.println();\n            System.out.printf(\"%14d\", sf.get(i));\n        }\n\n        System.out.println(\"\\n\\nNumber of square-free integers:\\n\");\n        long[] tos = {100, 1000, 10000, 100000, 1000000};\n        for (long to : tos) {\n            System.out.printf(\"  from %d to %d = %d\\n\", 1, to, squareFree(1, to).size());\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc sieve(limit uint64) []uint64 {\n    primes := []uint64{2}\n    c := make([]bool, limit+1) \n    \n    p := uint64(3)\n    for {\n        p2 := p * p\n        if p2 > limit {\n            break\n        }\n        for i := p2; i <= limit; i += 2 * p {\n            c[i] = true\n        }\n        for {\n            p += 2\n            if !c[p] {\n                break\n            }\n        }\n    }\n    for i := uint64(3); i <= limit; i += 2 {\n        if !c[i] {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc squareFree(from, to uint64) (results []uint64) {\n    limit := uint64(math.Sqrt(float64(to)))\n    primes := sieve(limit)\nouter:\n    for i := from; i <= to; i++ {\n        for _, p := range primes {\n            p2 := p * p\n            if p2 > i {\n                break\n            }\n            if i%p2 == 0 {\n                continue outer\n            }\n        }\n        results = append(results, i)\n    }\n    return\n}\n\nconst trillion uint64 = 1000000000000\n\nfunc main() {\n    fmt.Println(\"Square-free integers from 1 to 145:\")\n    sf := squareFree(1, 145)\n    for i := 0; i < len(sf); i++ {\n        if i > 0 && i%20 == 0 {\n            fmt.Println()\n        }\n        fmt.Printf(\"%4d\", sf[i])\n    }\n\n    fmt.Printf(\"\\n\\nSquare-free integers from %d to %d:\\n\", trillion, trillion+145)\n    sf = squareFree(trillion, trillion+145)\n    for i := 0; i < len(sf); i++ {\n        if i > 0 && i%5 == 0 {\n            fmt.Println()\n        }\n        fmt.Printf(\"%14d\", sf[i])\n    }\n\n    fmt.Println(\"\\n\\nNumber of square-free integers:\\n\")\n    a := [...]uint64{100, 1000, 10000, 100000, 1000000}\n    for _, n := range a {\n        fmt.Printf(\"  from %d to %d = %d\\n\", 1, n, len(squareFree(1, n)))\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 42,
    "input": "Translate Python to Go:from itertools import izip\n\ndef gen_row(w, s):\n    \n    def gen_seg(o, sp):\n        if not o:\n            return [[2] * sp]\n        return [[2] * x + o[0] + tail\n                for x in xrange(1, sp - len(o) + 2)\n                for tail in gen_seg(o[1:], sp - x)]\n\n    return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]\n\n\ndef deduce(hr, vr):\n    \n    def allowable(row):\n        return reduce(lambda a, b: [x | y for x, y in izip(a, b)], row)\n\n    def fits(a, b):\n        return all(x & y for x, y in izip(a, b))\n\n    def fix_col(n):\n        \n        c = [x[n] for x in can_do]\n        cols[n] = [x for x in cols[n] if fits(x, c)]\n        for i, x in enumerate(allowable(cols[n])):\n            if x != can_do[i][n]:\n                mod_rows.add(i)\n                can_do[i][n] &= x\n\n    def fix_row(n):\n        \n        c = can_do[n]\n        rows[n] = [x for x in rows[n] if fits(x, c)]\n        for i, x in enumerate(allowable(rows[n])):\n            if x != can_do[n][i]:\n                mod_cols.add(i)\n                can_do[n][i] &= x\n\n    def show_gram(m):\n        \n        \n        for x in m:\n            print \" \".join(\"x\n        print\n\n    w, h = len(vr), len(hr)\n    rows = [gen_row(w, x) for x in hr]\n    cols = [gen_row(h, x) for x in vr]\n    can_do = map(allowable, rows)\n\n    \n    mod_rows, mod_cols = set(), set(xrange(w))\n\n    while mod_cols:\n        for i in mod_cols:\n            fix_col(i)\n        mod_cols = set()\n        for i in mod_rows:\n            fix_row(i)\n        mod_rows = set()\n\n    if all(can_do[i][j] in (1, 2) for j in xrange(w) for i in xrange(h)):\n        print \"Solution would be unique\" \n    else:\n        print \"Solution may not be unique, doing exhaustive search:\"\n\n    \n    \n    \n    out = [0] * h\n\n    def try_all(n = 0):\n        if n >= h:\n            for j in xrange(w):\n                if [x[j] for x in out] not in cols[j]:\n                    return 0\n            show_gram(out)\n            return 1\n        sol = 0\n        for x in rows[n]:\n            out[n] = x\n            sol += try_all(n + 1)\n        return sol\n\n    n = try_all()\n    if not n:\n        print \"No solution.\"\n    elif n == 1:\n        print \"Unique solution.\"\n    else:\n        print n, \"solutions.\"\n    print\n\n\ndef solve(p, show_runs=True):\n    s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]\n         for l in p.splitlines()]\n    if show_runs:\n        print \"Horizontal runs:\", s[0]\n        print \"Vertical runs:\", s[1]\n    deduce(s[0], s[1])\n\n\ndef main():\n    \n    fn = \"nonogram_problems.txt\"\n    for p in (x for x in open(fn).read().split(\"\\n\\n\") if x):\n        solve(p)\n\n    print \"Extra example not solvable by deduction alone:\"\n    solve(\"B B A A\\nB B A A\")\n\n    print \"Extra example where there is no solution:\"\n    solve(\"B A A\\nA A A\")\n\nmain()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\ntype BitSet []bool\n\nfunc (bs BitSet) and(other BitSet) {\n    for i := range bs {\n        if bs[i] && other[i] {\n            bs[i] = true\n        } else {\n            bs[i] = false\n        }\n    }\n}\n\nfunc (bs BitSet) or(other BitSet) {\n    for i := range bs {\n        if bs[i] || other[i] {\n            bs[i] = true\n        } else {\n            bs[i] = false\n        }\n    }\n}\n\nfunc iff(cond bool, s1, s2 string) string {\n    if cond {\n        return s1\n    }\n    return s2\n}\n\nfunc newPuzzle(data [2]string) {\n    rowData := strings.Fields(data[0])\n    colData := strings.Fields(data[1])\n    rows := getCandidates(rowData, len(colData))\n    cols := getCandidates(colData, len(rowData))\n\n    for {\n        numChanged := reduceMutual(cols, rows)\n        if numChanged == -1 {\n            fmt.Println(\"No solution\")\n            return\n        }\n        if numChanged == 0 {\n            break\n        }\n    }\n\n    for _, row := range rows {\n        for i := 0; i < len(cols); i++ {\n            fmt.Printf(iff(row[0][i], \"# \", \". \"))\n        }\n        fmt.Println()\n    }\n    fmt.Println()\n}\n\n\nfunc getCandidates(data []string, le int) [][]BitSet {\n    var result [][]BitSet\n    for _, s := range data {\n        var lst []BitSet\n        a := []byte(s)\n        sumBytes := 0\n        for _, b := range a {\n            sumBytes += int(b - 'A' + 1)\n        }\n        prep := make([]string, len(a))\n        for i, b := range a {\n            prep[i] = strings.Repeat(\"1\", int(b-'A'+1))\n        }\n        for _, r := range genSequence(prep, le-sumBytes+1) {\n            bits := []byte(r[1:])\n            bitset := make(BitSet, len(bits))\n            for i, b := range bits {\n                bitset[i] = b == '1'\n            }\n            lst = append(lst, bitset)\n        }\n        result = append(result, lst)\n    }\n    return result\n}\n\nfunc genSequence(ones []string, numZeros int) []string {\n    le := len(ones)\n    if le == 0 {\n        return []string{strings.Repeat(\"0\", numZeros)}\n    }\n    var result []string\n    for x := 1; x < numZeros-le+2; x++ {\n        skipOne := ones[1:]\n        for _, tail := range genSequence(skipOne, numZeros-x) {\n            result = append(result, strings.Repeat(\"0\", x)+ones[0]+tail)\n        }\n    }\n    return result\n}\n\n\n\nfunc reduceMutual(cols, rows [][]BitSet) int {\n    countRemoved1 := reduce(cols, rows)\n    if countRemoved1 == -1 {\n        return -1\n    }\n    countRemoved2 := reduce(rows, cols)\n    if countRemoved2 == -1 {\n        return -1\n    }\n    return countRemoved1 + countRemoved2\n}\n\nfunc reduce(a, b [][]BitSet) int {\n    countRemoved := 0\n    for i := 0; i < len(a); i++ {\n        commonOn := make(BitSet, len(b))\n        for j := 0; j < len(b); j++ {\n            commonOn[j] = true\n        }\n        commonOff := make(BitSet, len(b))\n\n        \n        for _, candidate := range a[i] {\n            commonOn.and(candidate)\n            commonOff.or(candidate)\n        }\n\n        \n        for j := 0; j < len(b); j++ {\n            fi, fj := i, j\n            for k := len(b[j]) - 1; k >= 0; k-- {\n                cnd := b[j][k]\n                if (commonOn[fj] && !cnd[fi]) || (!commonOff[fj] && cnd[fi]) {\n                    lb := len(b[j])\n                    copy(b[j][k:], b[j][k+1:])\n                    b[j][lb-1] = nil\n                    b[j] = b[j][:lb-1]\n                    countRemoved++\n                }\n            }\n            if len(b[j]) == 0 {\n                return -1\n            }\n        }\n    }\n    return countRemoved\n}\n\nfunc main() {\n    p1 := [2]string{\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"}\n\n    p2 := [2]string{\n        \"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\",\n        \"D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\",\n    }\n\n    p3 := [2]string{\n        \"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH \" +\n            \"BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n        \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF \" +\n            \"AAAAD BDG CEF CBDB BBB FC\",\n    }\n\n    p4 := [2]string{\n        \"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G\",\n        \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ \" +\n            \"ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\",\n    }\n\n    for _, puzzleData := range [][2]string{p1, p2, p3, p4} {\n        newPuzzle(puzzleData)\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 43,
    "input": "Translate PHP to Python:<?php\n$pairs = array( \"hello\" => 1,\n\t\t\"world\" => 2,\n\t\t\"!\"     => 3 );\n\nforeach($pairs as $k => $v) {\n  echo \"(k,v) = ($k, $v)\\n\";\n}\n\nforeach(array_keys($pairs) as $key) {\n  echo \"key = $key, value = $pairs[$key]\\n\";\n}\n\nforeach($pairs as $value) {\n  echo \"values = $value\\n\";\n}\n?>\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "myDict = { \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 }\n\n\nfor key, value in myDict.items():\n    print (\"key = %s, value = %s\" % (key, value))\n\n\nfor key in myDict:\n    print (\"key = %s\" % key)\n\nfor key in myDict.keys():\n    print (\"key = %s\" % key)\n\n\nfor value in myDict.values():\n    print (\"value = %s\" % value)\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 44,
    "input": "Translate C to C#:int rand5()\n{\n\tint r, rand_max = RAND_MAX - (RAND_MAX % 5);\n\twhile ((r = rand()) >= rand_max);\n\treturn r / (rand_max / 5) + 1;\n}\n \nint rand5_7()\n{\n\tint r;\n\twhile ((r = rand5() * 5 + rand5()) >= 27);\n\treturn r / 3 - 1;\n}\n\nint main()\n{\n\tprintf(check(rand5, 5, 1000000, .05) ? \"flat\\n\" : \"not flat\\n\");\n\tprintf(check(rand7, 7, 1000000, .05) ? \"flat\\n\" : \"not flat\\n\");\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\n\npublic class SevenSidedDice\n{\n    Random random = new Random();\n\t\t\n        static void Main(string[] args)\n\t\t{\n\t\t\tSevenSidedDice sevenDice = new SevenSidedDice();\n\t\t\tConsole.WriteLine(\"Random number from 1 to 7: \"+ sevenDice.seven());\n            Console.Read();\n\t\t}\n\t\t\n\t\tint seven()\n\t\t{\n\t\t\tint v=21;\n\t\t\twhile(v>20)\n\t\t\t\tv=five()+five()*5-6;\n\t\t\treturn 1+v%7;\n\t\t}\n\t\t\n\t\tint five()\n\t\t{\n        return 1 + random.Next(5);\n\t\t}\n}\n",
    "input_language": "C",
    "output_language": "C#"
  },
  {
    "id": 45,
    "input": "Translate PHP to Go:#!/usr/bin/env php\nThe 24 Game\n \nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n \nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n \nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n<?php\n\nwhile (true) {\n    $numbers = make_numbers();\n\n    for ($iteration_num = 1; ; $iteration_num++) {\n        echo \"Expresion $iteration_num: \";\n\n        $entry = rtrim(fgets(STDIN));\n\n        if ($entry === '!') break;\n        if ($entry === 'q') exit;\n\n        $result = play($numbers, $entry);\n\n        if ($result === null) {\n            echo \"That's not valid\\n\";\n            continue;\n        }\n        elseif ($result != 24) {\n            echo \"Sorry, that's $result\\n\";\n            continue;\n        }\n        else {\n            echo \"That's right! 24!!\\n\";\n            exit;\n        }\n    }\n}\n\nfunction make_numbers() {\n    $numbers = array();\n\n    echo \"Your four digits: \";\n\n    for ($i = 0; $i < 4; $i++) {\n        $number = rand(1, 9);\n\n        if (!isset($numbers[$number])) {\n            $numbers[$number] = 0;\n        }\n        $numbers[$number]++;\n        print \"$number \";\n    }\n\n    print \"\\n\";\n\n    return $numbers;\n}\n\nfunction play($numbers, $expression) {\n    $operator = true;\n    for ($i = 0, $length = strlen($expression); $i < $length; $i++) {\n        $character = $expression[$i];\n\n        if (in_array($character, array('(', ')', ' ', \"\\t\"))) continue;\n\n        $operator = !$operator;\n\n        if (!$operator) {\n            if (!empty($numbers[$character])) {\n                $numbers[$character]--;\n                continue;\n            }\n            return;\n        }\n        elseif (!in_array($character, array('+', '-', '*', '/'))) {\n            return;\n        }\n    }\n\n    foreach ($numbers as $remaining) {\n        if ($remaining > 0) {\n            return;\n        }\n    }\n    \n    return eval(\"return $expression;\");\n}\n?>\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    n := make([]rune, 4)\n    for i := range n {\n        n[i] = rune(rand.Intn(9) + '1')\n    }\n    fmt.Printf(\"Your numbers: %c\\n\", n)\n    fmt.Print(\"Enter RPN: \")\n    var expr string\n    fmt.Scan(&expr)\n    if len(expr) != 7 {\n        fmt.Println(\"invalid. expression length must be 7.\" +\n            \" (4 numbers, 3 operators, no spaces)\")\n        return\n    }\n    stack := make([]float64, 0, 4)\n    for _, r := range expr {\n        if r >= '0' && r <= '9' {\n            if len(n) == 0 {\n                fmt.Println(\"too many numbers.\")\n                return\n            }\n            i := 0\n            for n[i] != r {\n                i++\n                if i == len(n) {\n                    fmt.Println(\"wrong numbers.\")\n                    return\n                }\n            }\n            n = append(n[:i], n[i+1:]...)\n            stack = append(stack, float64(r-'0'))\n            continue\n        }\n        if len(stack) < 2 {\n            fmt.Println(\"invalid expression syntax.\")\n            return\n        }\n        switch r {\n        case '+':\n            stack[len(stack)-2] += stack[len(stack)-1]\n        case '-':\n            stack[len(stack)-2] -= stack[len(stack)-1]\n        case '*':\n            stack[len(stack)-2] *= stack[len(stack)-1]\n        case '/':\n            stack[len(stack)-2] /= stack[len(stack)-1]\n        default:\n            fmt.Printf(\"%c invalid.\\n\", r)\n            return\n        }\n        stack = stack[:len(stack)-1]\n    }\n    if math.Abs(stack[0]-24) > 1e-6 {\n        fmt.Println(\"incorrect.\", stack[0], \"!= 24\")\n    } else {\n        fmt.Println(\"correct.\")\n    }\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 46,
    "input": "Translate PHP to Python:function stoogeSort(&$arr, $i, $j)\n{\n\tif($arr[$j] < $arr[$i])\n\t{\n\t\tlist($arr[$j],$arr[$i]) = array($arr[$i], $arr[$j]);\n\t}\n\tif(($j - $i) > 1)\n\t{\n\t\t$t = ($j - $i + 1) / 3;\n\t\tstoogesort($arr, $i, $j - $t);\n\t\tstoogesort($arr, $i + $t, $j);\n\t\tstoogesort($arr, $i, $j - $t);\n\t}\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": ">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]\n>>> def stoogesort(L, i=0, j=None):\n\tif j is None:\n\t\tj = len(L) - 1\n\tif L[j] < L[i]:\n\t\tL[i], L[j] = L[j], L[i]\n\tif j - i > 1:\n\t\tt = (j - i + 1) // 3\n\t\tstoogesort(L, i  , j-t)\n\t\tstoogesort(L, i+t, j  )\n\t\tstoogesort(L, i  , j-t)\n\treturn L\n\n>>> stoogesort(data)\n[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 47,
    "input": "Translate C to C#:#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\n#define MAX_N 20\n#define TIMES 1000000\n\ndouble factorial(int n) {\n\tdouble f = 1;\n\tint i;\n\tfor (i = 1; i <= n; i++) f *= i;\n\treturn f;\n}\n\ndouble expected(int n) {\n\tdouble sum = 0;\n\tint i;\n\tfor (i = 1; i <= n; i++)\n\t\tsum += factorial(n) / pow(n, i) / factorial(n - i);\n\treturn sum;\n}\n\nint randint(int n) {\n\tint r, rmax = RAND_MAX / n * n;\n\twhile ((r = rand()) >= rmax);\n\treturn r / (RAND_MAX / n);\n}\n\nint test(int n, int times) {\n\tint i, count = 0;\n\tfor (i = 0; i < times; i++) {\n\t\tint x = 1, bits = 0;\n\t\twhile (!(bits & x)) {\n\t\t\tcount++;\n\t\t\tbits |= x;\n\t\t\tx = 1 << randint(n);\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(void) {\n\tsrand(time(0));\n\tputs(\" n\\tavg\\texp.\\tdiff\\n-------------------------------\");\n\n\tint n;\n\tfor (n = 1; n <= MAX_N; n++) {\n\t\tint cnt = test(n, TIMES);\n\t\tdouble avg = (double)cnt / TIMES;\n\t\tdouble theory = expected(n);\n\t\tdouble diff = (avg / theory - 1) * 100;\n\t\tprintf(\"%2d %8.4f %8.4f %6.3f%%\\n\", n, avg, theory, diff);\n\t}\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "public class AverageLoopLength {\n\tprivate static int N = 100000;\n\t\n\tprivate static double analytical(int n) {\n\t\tdouble[] factorial = new double[n + 1];\n\t\tdouble[] powers = new double[n + 1];\n\t\tpowers[0] = 1.0;\n\t\tfactorial[0] = 1.0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfactorial[i] = factorial[i - 1] * i;\n\t\t\tpowers[i] = powers[i - 1] * n;\n\t\t}\n\t\tdouble sum = 0;\n\t\t\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tsum += factorial[n] / factorial[n - i] / powers[i];\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate static double average(int n) {\n\t\tRandom rnd = new Random();\n\t\tdouble sum = 0.0;\n\t\tfor (int a = 0; a < N; a++) {\n\t\t\tint[] random = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trandom[i] = rnd.Next(n);\n\t\t\t}\n\t\t\tvar seen = new HashSet<double>(n);\n\t\t\tint current = 0;\n\t\t\tint length = 0;\n\t\t\twhile (seen.Add(current)) {\n\t\t\t\tlength++;\n\t\t\t\tcurrent = random[current];\n\t\t\t}\n\t\t\tsum += length;\n\t\t}\n\t\treturn sum / N;\n\t}\n\t\n\tpublic static void Main(string[] args) {\n\tConsole.WriteLine(\" N    average    analytical    (error)\");\n\tConsole.WriteLine(\"===  =========  ============  =========\");\n\t\tfor (int i = 1; i <= 20; i++) {\n\t\t\tvar average = AverageLoopLength.average(i);\n\t\t\tvar analytical = AverageLoopLength.analytical(i);\n\t\t\tConsole.WriteLine(\"{0,3} {1,10:N4} {2,13:N4}  {3,8:N2}%\", i, average, analytical, (analytical - average) / analytical * 100);\n\t\t}\n\t}\n}\n",
    "input_language": "C",
    "output_language": "C#"
  },
  {
    "id": 48,
    "input": "Translate C# to Go:using System;\n\nnamespace Rosetta\n{\n    internal interface IFun\n    {\n        double F(int index, Vector x);\n        double df(int index, int derivative, Vector x);\n        double[] weights();\n    }\n\n    class Newton\n    {                \n        internal Vector Do(int size, IFun fun, Vector start)\n        {\n            Vector X = start.Clone();\n            Vector F = new Vector(size);\n            Matrix J = new Matrix(size, size);\n            Vector D;\n            do\n            {\n                for (int i = 0; i < size; i++)\n                    F[i] = fun.F(i, X);\n                for (int i = 0; i < size; i++)\n                    for (int j = 0; j < size; j++)\n                        J[i, j] = fun.df(i, j, X);\n                J.ElimPartial(F);\n                X -= F;\n                \n            } while (F.norm(fun.weights()) > 1e-12);\n            return X;\n        }       \n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype vector = []float64\ntype matrix []vector\ntype fun = func(vector) float64\ntype funs = []fun\ntype jacobian = []funs\n\nfunc (m1 matrix) mul(m2 matrix) matrix {\n    rows1, cols1 := len(m1), len(m1[0])\n    rows2, cols2 := len(m2), len(m2[0])\n    if cols1 != rows2 {\n        panic(\"Matrices cannot be multiplied.\")\n    }\n    result := make(matrix, rows1)\n    for i := 0; i < rows1; i++ {\n        result[i] = make(vector, cols2)\n        for j := 0; j < cols2; j++ {\n            for k := 0; k < rows2; k++ {\n                result[i][j] += m1[i][k] * m2[k][j]\n            }\n        }\n    }\n    return result\n}\n\nfunc (m1 matrix) sub(m2 matrix) matrix {\n    rows, cols := len(m1), len(m1[0])\n    if rows != len(m2) || cols != len(m2[0]) {\n        panic(\"Matrices cannot be subtracted.\")\n    }\n    result := make(matrix, rows)\n    for i := 0; i < rows; i++ {\n        result[i] = make(vector, cols)\n        for j := 0; j < cols; j++ {\n            result[i][j] = m1[i][j] - m2[i][j]\n        }\n    }\n    return result\n}\n\nfunc (m matrix) transpose() matrix {\n    rows, cols := len(m), len(m[0])\n    trans := make(matrix, cols)\n    for i := 0; i < cols; i++ {\n        trans[i] = make(vector, rows)\n        for j := 0; j < rows; j++ {\n            trans[i][j] = m[j][i]\n        }\n    }\n    return trans\n}\n\nfunc (m matrix) inverse() matrix {\n    le := len(m)\n    for _, v := range m {\n        if len(v) != le {\n            panic(\"Not a square matrix\")\n        }\n    }\n    aug := make(matrix, le)\n    for i := 0; i < le; i++ {\n        aug[i] = make(vector, 2*le)\n        copy(aug[i], m[i])\n        \n        aug[i][i+le] = 1\n    }\n    aug.toReducedRowEchelonForm()\n    inv := make(matrix, le)\n    \n    for i := 0; i < le; i++ {\n        inv[i] = make(vector, le)\n        copy(inv[i], aug[i][le:])\n    }\n    return inv\n}\n\n\nfunc (m matrix) toReducedRowEchelonForm() {\n    lead := 0\n    rowCount, colCount := len(m), len(m[0])\n    for r := 0; r < rowCount; r++ {\n        if colCount <= lead {\n            return\n        }\n        i := r\n\n        for m[i][lead] == 0 {\n            i++\n            if rowCount == i {\n                i = r\n                lead++\n                if colCount == lead {\n                    return\n                }\n            }\n        }\n\n        m[i], m[r] = m[r], m[i]\n        if div := m[r][lead]; div != 0 {\n            for j := 0; j < colCount; j++ {\n                m[r][j] /= div\n            }\n        }\n\n        for k := 0; k < rowCount; k++ {\n            if k != r {\n                mult := m[k][lead]\n                for j := 0; j < colCount; j++ {\n                    m[k][j] -= m[r][j] * mult\n                }\n            }\n        }\n        lead++\n    }\n}\n\nfunc solve(fs funs, jacob jacobian, guesses vector) vector {\n    size := len(fs)\n    var gu1 vector\n    gu2 := make(vector, len(guesses))\n    copy(gu2, guesses)\n    jac := make(matrix, size)\n    for i := 0; i < size; i++ {\n        jac[i] = make(vector, size)\n    }\n    tol := 1e-8\n    maxIter := 12\n    iter := 0\n    for {\n        gu1 = gu2\n        g := matrix{gu1}.transpose()\n        t := make(vector, size)\n        for i := 0; i < size; i++ {\n            t[i] = fs[i](gu1)\n        }\n        f := matrix{t}.transpose()\n        for i := 0; i < size; i++ {\n            for j := 0; j < size; j++ {\n                jac[i][j] = jacob[i][j](gu1)\n            }\n        }\n        g1 := g.sub(jac.inverse().mul(f))\n        gu2 = make(vector, size)\n        for i := 0; i < size; i++ {\n            gu2[i] = g1[i][0]\n        }\n        iter++\n        any := false\n        for i, v := range gu2 {\n            if math.Abs(v)-gu1[i] > tol {\n                any = true\n                break\n            }\n        }\n        if !any || iter >= maxIter {\n            break\n        }\n    }\n    return gu2\n}\n\nfunc main() {\n    \n    f1 := func(x vector) float64 { return -x[0]*x[0] + x[0] + 0.5 - x[1] }\n    f2 := func(x vector) float64 { return x[1] + 5*x[0]*x[1] - x[0]*x[0] }\n    fs := funs{f1, f2}\n    jacob := jacobian{\n        funs{\n            func(x vector) float64 { return -2*x[0] + 1 },\n            func(x vector) float64 { return -1 },\n        },\n        funs{\n            func(x vector) float64 { return 5*x[1] - 2*x[0] },\n            func(x vector) float64 { return 1 + 5*x[0] },\n        },\n    }\n    guesses := vector{1.2, 1.2}\n    sol := solve(fs, jacob, guesses)\n    fmt.Printf(\"Approximate solutions are x = %.7f,  y = %.7f\\n\", sol[0], sol[1])\n\n    \n\n    fmt.Println()\n    f3 := func(x vector) float64 { return 9*x[0]*x[0] + 36*x[1]*x[1] + 4*x[2]*x[2] - 36 }\n    f4 := func(x vector) float64 { return x[0]*x[0] - 2*x[1]*x[1] - 20*x[2] }\n    f5 := func(x vector) float64 { return x[0]*x[0] - x[1]*x[1] + x[2]*x[2] }\n    fs = funs{f3, f4, f5}\n    jacob = jacobian{\n        funs{\n            func(x vector) float64 { return 18 * x[0] },\n            func(x vector) float64 { return 72 * x[1] },\n            func(x vector) float64 { return 8 * x[2] },\n        },\n        funs{\n            func(x vector) float64 { return 2 * x[0] },\n            func(x vector) float64 { return -4 * x[1] },\n            func(x vector) float64 { return -20 },\n        },\n        funs{\n            func(x vector) float64 { return 2 * x[0] },\n            func(x vector) float64 { return -2 * x[1] },\n            func(x vector) float64 { return 2 * x[2] },\n        },\n    }\n    guesses = vector{1, 1, 0}\n    sol = solve(fs, jacob, guesses)\n    fmt.Printf(\"Approximate solutions are x = %.7f,  y = %.7f,  z = %.7f\\n\", sol[0], sol[1], sol[2])\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 49,
    "input": "Translate Python to C#:from collections import namedtuple\nimport math\n\nCircle = namedtuple('Circle', 'x, y, r')\n \ndef solveApollonius(c1, c2, c3, s1, s2, s3):\n    \n    x1, y1, r1 = c1\n    x2, y2, r2 = c2\n    x3, y3, r3 = c3\n\n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n    v14 = 2*s2*r2 - 2*s1*r1\n \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n    v24 = 2*s3*r3 - 2*s2*r2\n \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n \n    w22 = v22/v21-w12\n    w23 = v23/v21-w13\n    w24 = v24/v21-w14\n \n    P = -w23/w22\n    Q = w24/w22\n    M = -w12*P-w13\n    N = w14 - w12*Q\n \n    a = N*N + Q*Q - 1\n    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n \n    \n    D = b*b-4*a*c\n    rs = (-b-math.sqrt(D))/(2*a)\n \n    xs = M+N*rs\n    ys = P+Q*rs\n \n    return Circle(xs, ys, rs)\n\nif __name__ == '__main__':\n    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)\n    print(solveApollonius(c1, c2, c3, 1, 1, 1))    \n    print(solveApollonius(c1, c2, c3, -1, -1, -1)) \n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\n\nnamespace ApolloniusProblemCalc\n{\n    class Program\n    {\n        static float rs = 0;\n        static float xs = 0;\n        static float ys = 0;\n\n        public static void Main(string[] args)\n        {\n            float gx1;\n            float gy1;\n            float gr1;\n            float gx2;\n            float gy2;\n            float gr2;\n            float gx3;\n            float gy3;\n            float gr3;\n\n            \n            gx1 = 0;\n            gy1 = 0;\n            gr1 = 1;\n            gx2 = 4;\n            gy2 = 0;\n            gr2 = 1;\n            gx3 = 2;\n            gy3 = 4;\n            gr3 = 2;\n            \n\n            for (int i = 1; i <= 8; i++)\n            {\n                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);\n\n\n                if (i == 1)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"st solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"st solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"st Solution circle's radius: \" + rs.ToString());\n                }\n                else if (i == 2)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"ed solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"ed solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"ed Solution circle's radius: \" + rs.ToString());\n                }\n                else if(i == 3)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"rd solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"rd solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"rd Solution circle's radius: \" + rs.ToString());\n                }\n                else\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"th solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"th solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"th Solution circle's radius: \" + rs.ToString());\n                }\n\n                Console.WriteLine();\n            }\n\n\n            Console.ReadKey(true);\n        }\n\n        private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)\n        {\n            float s1 = 1;\n            float s2 = 1;\n            float s3 = 1;\n\n            if (calcCounter == 2)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 3)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 4)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 5)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = 1;\n            }\n            else if (calcCounter == 6)\n            {\n                s1 = 1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 7)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = 1;\n            }\n            else if (calcCounter == 8)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = 1;\n            }\n\n            \n            float v11 = 2 * x2 - 2 * x1;\n            float v12 = 2 * y2 - 2 * y1;\n            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;\n            float v14 = 2 * s2 * r2 - 2 * s1 * r1;\n\n            float v21 = 2 * x3 - 2 * x2;\n            float v22 = 2 * y3 - 2 * y2;\n            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;\n            float v24 = 2 * s3 * r3 - 2 * s2 * r2;\n\n            float w12 = v12 / v11;\n            float w13 = v13 / v11;\n            float w14 = v14 / v11;\n\n            float w22 = v22 / v21 - w12;\n            float w23 = v23 / v21 - w13;\n            float w24 = v24 / v21 - w14;\n\n            float P = -w23 / w22;\n            float Q = w24 / w22;\n            float M = -w12 * P - w13;\n            float N = w14 - w12 * Q;\n\n            float a = N * N + Q * Q - 1;\n            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;\n            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;\n\n            float D = b * b - 4 * a * c;\n\n            rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));\n            xs = M + N * rs;\n            ys = P + Q * rs;\n        }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 50,
    "input": "Translate C to Python:#include <unistd.h>\t\n#include <stdio.h>\t\n\nint main(void)\n{\n\tputs(isatty(fileno(stdin))\n\t\t? \"stdin is tty\"\n\t\t: \"stdin is not tty\");\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 51,
    "input": "Translate C++ to Go:#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string dog = \"Benjamin\", Dog = \"Samba\", DOG = \"Bernie\";\n    \n    cout << \"The three dogs are named \" << dog << \", \" << Dog << \", and \" << DOG << endl;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package dogs\n\nimport \"fmt\"\n\n\n\nvar dog = \"Salt\"\nvar Dog = \"Pepper\"\nvar DOG = \"Mustard\"\n\nfunc PackageSees() map[*string]int {\n    \n    fmt.Println(\"Package sees:\", dog, Dog, DOG)\n    \n    \n    \n    \n    return map[*string]int{&dog: 1, &Dog: 1, &DOG: 1}\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 52,
    "input": "Translate Java to VB:import java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Fractran{\n\n   public static void main(String []args){ \n\n       new Fractran(\"17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\", 2);\n   }\n   final int limit = 15;\n   \n\n   Vector<Integer> num = new Vector<>(); \n   Vector<Integer> den = new Vector<>(); \n   public Fractran(String prog, Integer val){\n      compile(prog);\n      dump();\n      exec(2);\n    }\n\n\n   void compile(String prog){\n      Pattern regexp = Pattern.compile(\"\\\\s*(\\\\d*)\\\\s*\\\\/\\\\s*(\\\\d*)\\\\s*(.*)\");\n      Matcher matcher = regexp.matcher(prog);\n      while(matcher.find()){\n         num.add(Integer.parseInt(matcher.group(1)));\n         den.add(Integer.parseInt(matcher.group(2)));\n         matcher = regexp.matcher(matcher.group(3));\n      }\n   }\n\n   void exec(Integer val){\n       int n = 0;\n       while(val != null && n<limit){\n           System.out.println(n+\": \"+val);\n           val = step(val);\n           n++;\n       }\n   }\n   Integer step(int val){\n       int i=0; \n       while(i<den.size() && val%den.get(i) != 0) i++;\n       if(i<den.size())\n           return num.get(i)*val/den.get(i);\n       return null;\n   }\n\n   void dump(){\n       for(int i=0; i<den.size(); i++)\n           System.out.print(num.get(i)+\"/\"+den.get(i)+\" \");\n       System.out.println();\n   }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Option Base 1\nPublic prime As Variant\nPublic nf As New Collection\nPublic df As New Collection\nConst halt = 20\nPrivate Sub init()\n    prime = [{2,3,5,7,11,13,17,19,23,29,31}]\nEnd Sub\nPrivate Function factor(f As Long) As Variant\n    Dim result(10) As Integer\n    Dim i As Integer: i = 1\n    Do While f > 1\n        Do While f Mod prime(i) = 0\n            f = f \\ prime(i)\n            result(i) = result(i) + 1\n        Loop\n        i = i + 1\n    Loop\n    factor = result\nEnd Function\nPrivate Function decrement(ByVal a As Variant, b As Variant) As Variant\n    For i = LBound(a) To UBound(a)\n        a(i) = a(i) - b(i)\n    Next i\n    decrement = a\nEnd Function\nPrivate Function increment(ByVal a As Variant, b As Variant) As Variant\n    For i = LBound(a) To UBound(a)\n        a(i) = a(i) + b(i)\n    Next i\n    increment = a\nEnd Function\nPrivate Function test(a As Variant, b As Variant)\n    flag = True\n    For i = LBound(a) To UBound(a)\n        If a(i) < b(i) Then\n            flag = False\n            Exit For\n        End If\n    Next i\n    test = flag\nEnd Function\nPrivate Function unfactor(x As Variant) As Long\n    result = 1\n    For i = LBound(x) To UBound(x)\n        result = result * prime(i) ^ x(i)\n    Next i\n    unfactor = result\nEnd Function\nPrivate Sub compile(program As String)\n    program = Replace(program, \" \", \"\")\n    programlist = Split(program, \",\")\n    For Each instruction In programlist\n        parts = Split(instruction, \"/\")\n        nf.Add factor(Val(parts(0)))\n        df.Add factor(Val(parts(1)))\n    Next instruction\nEnd Sub\nPrivate Function run(x As Long) As Variant\n    n = factor(x)\n    counter = 0\n    Do While True\n        For i = 1 To df.Count\n            If test(n, df(i)) Then\n                n = increment(decrement(n, df(i)), nf(i))\n                Exit For\n            End If\n        Next i\n        Debug.Print unfactor(n);\n        counter = counter + 1\n        If num = 31 Or counter >= halt Then Exit Do\n    Loop\n    Debug.Print\n    run = n\nEnd Function\nPrivate Function steps(x As Variant) As Variant\n    \n    For i = 1 To df.Count\n        If test(x, df(i)) Then\n            x = increment(decrement(x, df(i)), nf(i))\n            Exit For\n        End If\n    Next i\n    steps = x\nEnd Function\nPrivate Function is_power_of_2(x As Variant) As Boolean\n    flag = True\n    For i = LBound(x) + 1 To UBound(x)\n        If x(i) > 0 Then\n            flag = False\n            Exit For\n        End If\n    Next i\n    is_power_of_2 = flag\nEnd Function\nPrivate Function filter_primes(x As Long, max As Integer) As Long\n    n = factor(x)\n    i = 0: iterations = 0\n    Do While i < max\n        If is_power_of_2(steps(n)) Then\n            Debug.Print n(1);\n            i = i + 1\n        End If\n        iterations = iterations + 1\n    Loop\n    Debug.Print\n    filter_primes = iterations\nEnd Function\nPublic Sub main()\n    init\n    compile (\"17/91, 78/85, 19/51, 23/38, 29/33, 77/29, 95/23, 77/19, 1/17, 11/13, 13/11, 15/14,  15/2, 55/1\")\n    Debug.Print \"First 20 results:\"\n    output = run(2)\n    Debug.Print \"First 30 primes:\"\n    Debug.Print \"after\"; filter_primes(2, 30); \"iterations.\"\nEnd Sub\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 53,
    "input": "Translate Go to VB:package main\n\nimport \"fmt\"\n\nfunc main() {\n    list := pancake{31, 41, 59, 26, 53, 58, 97, 93, 23, 84}\n    fmt.Println(\"unsorted:\", list)\n\n    list.sort()\n    fmt.Println(\"sorted!  \", list)\n}\n\ntype pancake []int\n\nfunc (a pancake) sort() {\n    for uns := len(a) - 1; uns > 0; uns-- {\n        \n        lx, lg := 0, a[0]\n        for i := 1; i <= uns; i++ {\n            if a[i] > lg {\n                lx, lg = i, a[i]\n            }\n        }\n        \n        a.flip(lx)\n        a.flip(uns)\n    }\n}\n\nfunc (a pancake) flip(r int) {\n    for l := 0; l < r; l, r = l+1, r-1 {\n        a[l], a[r] = a[r], a[l]\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "\n\n\nPublic Sub printarray(A)\n  For i = LBound(A) To UBound(A)\n    Debug.Print A(i),\n  Next\n  Debug.Print\nEnd Sub\n\nPublic Sub Flip(ByRef A, p1, p2, trace)\n\n If trace Then Debug.Print \"we\n Cut = Int((p2 - p1 + 1) / 2)\n For i = 0 To Cut - 1\n   \n   temp = A(i)\n   A(i) = A(p2 - i)\n   A(p2 - i) = temp\n Next\nEnd Sub\n\nPublic Sub pancakesort(ByRef A(), Optional trace As Boolean = False)\n\n\nlb = LBound(A)\nub = UBound(A)\nLength = ub - lb + 1\nIf Length <= 1 Then \n  Exit Sub\nEnd If\n\nFor i = ub To lb + 1 Step -1\n  \n  P = lb\n  Maximum = A(P)\n  For j = lb + 1 To i\n    If A(j) > Maximum Then\n      P = j\n      Maximum = A(j)\n    End If\n  Next j\n  \n  If P < i Then\n    \n    If P > 1 Then\n      Flip A, lb, P, trace\n      If trace Then printarray A\n    End If\n    \n    Flip A, lb, i, trace\n    If trace Then printarray A\n  End If\nNext i\nEnd Sub\n\n\nPublic Sub TestPancake(Optional trace As Boolean = False)\nDim A()\nA = Array(5, 7, 8, 3, 1, 10, 9, 23, 50, 0)\nDebug.Print \"Initial array:\"\nprintarray A\npancakesort A, trace\nDebug.Print \"Final array:\"\nprintarray A\nEnd Sub\n",
    "input_language": "Go",
    "output_language": "VB"
  },
  {
    "id": 54,
    "input": "Translate Python to C#:from sys import stdout\nneighbours = [[-1, 0], [0, -1], [1, 0], [0, 1]]\nexists = []\nlastNumber = 0\nwid = 0\nhei = 0\n\n\ndef find_next(pa, x, y, z):\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == z:\n                return a, b\n\n    return -1, -1\n\n\ndef find_solution(pa, x, y, z):\n    if z > lastNumber:\n        return 1\n    if exists[z] == 1:\n        s = find_next(pa, x, y, z)\n        if s[0] < 0:\n            return 0\n        return find_solution(pa, s[0], s[1], z + 1)\n\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == 0:\n                pa[a][b] = z\n                r = find_solution(pa, a, b, z + 1)\n                if r == 1:\n                    return 1\n                pa[a][b] = 0\n\n    return 0\n\n\ndef solve(pz, w, h):\n    global lastNumber, wid, hei, exists\n\n    lastNumber = w * h\n    wid = w\n    hei = h\n    exists = [0 for j in range(lastNumber + 1)]\n\n    pa = [[0 for j in range(h)] for i in range(w)]\n    st = pz.split()\n    idx = 0\n    for j in range(h):\n        for i in range(w):\n            if st[idx] == \".\":\n                idx += 1\n            else:\n                pa[i][j] = int(st[idx])\n                exists[pa[i][j]] = 1\n                idx += 1\n\n    x = 0\n    y = 0\n    t = w * h + 1\n    for j in range(h):\n        for i in range(w):\n            if pa[i][j] != 0 and pa[i][j] < t:\n                t = pa[i][j]\n                x = i\n                y = j\n\n    return find_solution(pa, x, y, t + 1), pa\n\n\ndef show_result(r):\n    if r[0] == 1:\n        for j in range(hei):\n            for i in range(wid):\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n            print()\n    else:\n        stdout.write(\"No Solution!\\n\")\n\n    print()\n\n\nr = solve(\". . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17\"\n          \" . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1  2 . . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\". . . . . . . . . . 11 12 15 18 21 62 61 . .  6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37\"\n          \" .  1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\"17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . .  63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55\"\n          \" . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45\", 9, 9)\nshow_result(r)\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        numbrixMoves = {(1,0),(0,1),(-1,0),(0,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        var numbrixSolver = new Solver(numbrixMoves);\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0,  0, 46, 45,  0, 55, 74,  0,  0 },\n            {  0, 38,  0,  0, 43,  0,  0, 78,  0 },\n            {  0, 35,  0,  0,  0,  0,  0, 71,  0 },\n            {  0,  0, 33,  0,  0,  0, 59,  0,  0 },\n            {  0, 17,  0,  0,  0,  0,  0, 67,  0 },\n            {  0, 18,  0,  0, 11,  0,  0, 64,  0 },\n            {  0,  0, 24, 21,  0,  1,  2,  0,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0, 11, 12, 15, 18, 21, 62, 61,  0 },\n            {  0,  6,  0,  0,  0,  0,  0, 60,  0 },\n            {  0, 33,  0,  0,  0,  0,  0, 57,  0 },\n            {  0, 32,  0,  0,  0,  0,  0, 56,  0 },\n            {  0, 37,  0,  1,  0,  0,  0, 73,  0 },\n            {  0, 38,  0,  0,  0,  0,  0, 72,  0 },\n            {  0, 43, 44, 47, 48, 51, 76, 77,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 55,
    "input": "Translate PHP to Java:#!/usr/bin/env php\nThe 24 Game\n \nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n \nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n \nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n<?php\n\nwhile (true) {\n    $numbers = make_numbers();\n\n    for ($iteration_num = 1; ; $iteration_num++) {\n        echo \"Expresion $iteration_num: \";\n\n        $entry = rtrim(fgets(STDIN));\n\n        if ($entry === '!') break;\n        if ($entry === 'q') exit;\n\n        $result = play($numbers, $entry);\n\n        if ($result === null) {\n            echo \"That's not valid\\n\";\n            continue;\n        }\n        elseif ($result != 24) {\n            echo \"Sorry, that's $result\\n\";\n            continue;\n        }\n        else {\n            echo \"That's right! 24!!\\n\";\n            exit;\n        }\n    }\n}\n\nfunction make_numbers() {\n    $numbers = array();\n\n    echo \"Your four digits: \";\n\n    for ($i = 0; $i < 4; $i++) {\n        $number = rand(1, 9);\n\n        if (!isset($numbers[$number])) {\n            $numbers[$number] = 0;\n        }\n        $numbers[$number]++;\n        print \"$number \";\n    }\n\n    print \"\\n\";\n\n    return $numbers;\n}\n\nfunction play($numbers, $expression) {\n    $operator = true;\n    for ($i = 0, $length = strlen($expression); $i < $length; $i++) {\n        $character = $expression[$i];\n\n        if (in_array($character, array('(', ')', ' ', \"\\t\"))) continue;\n\n        $operator = !$operator;\n\n        if (!$operator) {\n            if (!empty($numbers[$character])) {\n                $numbers[$character]--;\n                continue;\n            }\n            return;\n        }\n        elseif (!in_array($character, array('+', '-', '*', '/'))) {\n            return;\n        }\n    }\n\n    foreach ($numbers as $remaining) {\n        if ($remaining > 0) {\n            return;\n        }\n    }\n    \n    return eval(\"return $expression;\");\n}\n?>\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n",
    "input_language": "PHP",
    "output_language": "Java"
  },
  {
    "id": 56,
    "input": "Translate C++ to VB:#include <iostream>\n\nint main()\n{\n  \n  auto double1 = 2.5;\n\n  \n  auto float1 = 2.5f;\n\n  \n  auto longdouble1 = 2.5l;\n\n  \n  auto double2 = 2.5e-3;\n  auto float2 = 2.5e3f;\n\n  \n  auto double3 = 0x1p4;\n  auto float3 = 0xbeefp-8f;\n\n  std::cout << \"\\ndouble1: \" << double1;\n  std::cout << \"\\nfloat1: \" << float1;\n  std::cout << \"\\nlongdouble1: \" << longdouble1;\n  std::cout << \"\\ndouble2: \" << double2;\n  std::cout << \"\\nfloat2: \" << float2;\n  std::cout << \"\\ndouble3: \" << double3;\n  std::cout << \"\\nfloat3: \" << float3;\n  std::cout << \"\\n\";\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Sub Main()\nDim d As Double \nDim s As Single \n  d = -12.3456\n  d = 1000#\n  d = 0.00001\n  d = 67#\n  d = 8.9\n  d = 0.33\n  d = 0#\n  d = 2# * 10 ^ 3\n  d = 2E+50\n  d = 2E-50\n  s = -12.3456!\n  s = 1000!\n  s = 0.00001!\n  s = 67!\n  s = 8.9!\n  s = 0.33!\n  s = 0!\n  s = 2! * 10 ^ 3\nEnd Sub\n",
    "input_language": "C++",
    "output_language": "VB"
  },
  {
    "id": 57,
    "input": "Translate C to C++:#include <stdio.h>\n\nint main() {\n  const char *extra = \"little\";\n  printf(\"Mary had a %s lamb.\\n\", extra);\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <string>\n#include <iostream>\n\nint main( ) {\n   std::string original( \"Mary had a X lamb.\" ) , toBeReplaced( \"X\" ) ,\n      replacement ( \"little\" ) ;\n   std::string newString = original.replace( original.find( \"X\" ) ,\n\t toBeReplaced.length( ) , replacement ) ;\n   std::cout << \"String after replacement: \" << newString << \" \\n\" ;\n   return 0 ;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 58,
    "input": "Translate Python to C#:def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 59,
    "input": "Translate C to Go:#include<stdio.h>\n#include<stdlib.h>\n\nint main(void) {\n    int list[3][9], i;\n    for(i=0;i<27;i++) list[i/9][i%9]=1+i;\n    for(i=0;i<9;i++) printf( \"%d%d%d  \", list[0][i], list[1][i], list[2][i] );\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    list1 := [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n    list2 := [9]int{10, 11, 12, 13, 14, 15, 16, 17, 18}\n    list3 := [9]int{19, 20, 21, 22, 23, 24, 25, 26, 27}\n    var list [9]int\n    for i := 0; i < 9; i++ {\n        list[i] = list1[i]*1e4 + list2[i]*1e2 + list3[i]\n    }\n    fmt.Println(list)\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 60,
    "input": "Translate C++ to Java:#include <string>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <sstream>\n\nstd::string mostFreqKHashing ( const std::string & input , int k ) {\n   std::ostringstream oss ;\n   std::map<char, int> frequencies ;\n   for ( char c : input ) {\n      frequencies[ c ] = std::count ( input.begin( ) , input.end( ) , c ) ;\n   }\n   std::vector<std::pair<char , int>> letters ( frequencies.begin( ) , frequencies.end( ) ) ;\n   std::sort ( letters.begin( ) , letters.end( ) , [input] ( std::pair<char, int> a ,\n\t         std::pair<char, int> b ) { char fc = std::get<0>( a ) ; char fs = std::get<0>( b ) ; \n\t         int o = std::get<1>( a ) ; int p = std::get<1>( b ) ; if ( o != p ) { return o > p ; }\n\t         else { return input.find_first_of( fc ) < input.find_first_of ( fs ) ; } } ) ;\n   for ( int i = 0 ; i < letters.size( ) ; i++ ) {\n      oss << std::get<0>( letters[ i ] ) ;\n      oss << std::get<1>( letters[ i ] ) ;\n   }\n   std::string output ( oss.str( ).substr( 0 , 2 * k ) ) ;\n   if ( letters.size( ) >= k ) {\n      return output ;\n   }\n   else {\n      return output.append( \"NULL0\" ) ;\n   }\n}\n\nint mostFreqKSimilarity ( const std::string & first , const std::string & second ) {\n   int i = 0 ;\n   while ( i < first.length( ) - 1  ) {\n      auto found = second.find_first_of( first.substr( i , 2 ) ) ;\n      if ( found != std::string::npos ) \n\t return std::stoi ( first.substr( i , 2 )) ;\n      else \n\t i += 2 ;\n   }\n   return 0 ;\n}\n\nint mostFreqKSDF ( const std::string & firstSeq , const std::string & secondSeq , int num ) {\n   return mostFreqKSimilarity ( mostFreqKHashing( firstSeq , num ) , mostFreqKHashing( secondSeq , num ) ) ;\n}\n\nint main( ) {\n   std::string s1(\"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\" ) ;\n   std::string s2( \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\" ) ;\n   std::cout << \"MostFreqKHashing( s1 , 2 ) = \" << mostFreqKHashing( s1 , 2 ) << '\\n' ;\n   std::cout << \"MostFreqKHashing( s2 , 2 ) = \" << mostFreqKHashing( s2 , 2 ) << '\\n' ;\n   return 0 ;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class SDF {\n\n    \n    public static HashMap<Character, Integer> countElementOcurrences(char[] array) {\n\n        HashMap<Character, Integer> countMap = new HashMap<Character, Integer>();\n\n        for (char element : array) {\n            Integer count = countMap.get(element);\n            count = (count == null) ? 1 : count + 1;\n            countMap.put(element, count);\n        }\n\n        return countMap;\n    }\n    \n    \n    private static <K, V extends Comparable<? super V>>\n            HashMap<K, V> descendingSortByValues(HashMap<K, V> map) { \n\tList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>(map.entrySet());\n\t\n\tCollections.sort(list, new Comparator<Map.Entry<K, V>>() {\n\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n\t\t    return o2.getValue().compareTo(o1.getValue());\n\t\t}\n\t    });\n\n\t\n\t\n\tHashMap<K, V> sortedHashMap = new LinkedHashMap<K, V>();\n\tfor (Map.Entry<K, V> entry : list) {\n\t    sortedHashMap.put(entry.getKey(), entry.getValue());\n\t} \n\treturn sortedHashMap;\n    }\n    \n    public static String mostOcurrencesElement(char[] array, int k) {\n        HashMap<Character, Integer> countMap = countElementOcurrences(array);\n        System.out.println(countMap);\n        Map<Character, Integer> map = descendingSortByValues(countMap); \n        System.out.println(map);\n        int i = 0;\n        String output = \"\";\n        for (Map.Entry<Character, Integer> pairs : map.entrySet()) {\n\t    if (i++ >= k)\n\t\tbreak;\n            output += \"\" + pairs.getKey() + pairs.getValue();\n        }\n        return output;\n    }\n    \n    public static int getDiff(String str1, String str2, int limit) {\n        int similarity = 0;\n\tint k = 0;\n\tfor (int i = 0; i < str1.length() ; i = k) {\n\t    k ++;\n\t    if (Character.isLetter(str1.charAt(i))) {\n\t\tint pos = str2.indexOf(str1.charAt(i));\n\t\t\t\t\n\t\tif (pos >= 0) {\t\n\t\t    String digitStr1 = \"\";\n\t\t    while ( k < str1.length() && !Character.isLetter(str1.charAt(k))) {\n\t\t\tdigitStr1 += str1.charAt(k);\n\t\t\tk++;\n\t\t    }\n\t\t\t\t\t\n\t\t    int k2 = pos+1;\n\t\t    String digitStr2 = \"\";\n\t\t    while (k2 < str2.length() && !Character.isLetter(str2.charAt(k2)) ) {\n\t\t\tdigitStr2 += str2.charAt(k2);\n\t\t\tk2++;\n\t\t    }\n\t\t\t\t\t\n\t\t    similarity += Integer.parseInt(digitStr2)\n\t\t\t+ Integer.parseInt(digitStr1);\n\t\t\t\t\t\n\t\t} \n\t    }\n\t}\n\treturn Math.abs(limit - similarity);\n    }\n    \n    public static int SDFfunc(String str1, String str2, int limit) {\n        return getDiff(mostOcurrencesElement(str1.toCharArray(), 2), mostOcurrencesElement(str2.toCharArray(), 2), limit);\n    }\n\n    public static void main(String[] args) {\n        String input1 = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\";\n        String input2 = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\";\n        System.out.println(SDF.SDFfunc(input1,input2,100));\n\n    }\n\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 61,
    "input": "Translate Python to C#:\n\ndef convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Numerics;\n\nnamespace CipollaAlgorithm {\n    class Program {\n        static readonly BigInteger BIG = BigInteger.Pow(10, 50) + 151;\n\n        private static Tuple<BigInteger, BigInteger, bool> C(string ns, string ps) {\n            BigInteger n = BigInteger.Parse(ns);\n            BigInteger p = ps.Length > 0 ? BigInteger.Parse(ps) : BIG;\n\n            \n            BigInteger ls(BigInteger a0) => BigInteger.ModPow(a0, (p - 1) / 2, p);\n\n            \n            if (ls(n) != 1) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            BigInteger a = 0;\n            BigInteger omega2;\n            while (true) {\n                omega2 = (a * a + p - n) % p;\n                if (ls(omega2) == p - 1) {\n                    break;\n                }\n                a += 1;\n            }\n\n            \n            BigInteger finalOmega = omega2;\n            Tuple<BigInteger, BigInteger> mul(Tuple<BigInteger, BigInteger> aa, Tuple<BigInteger, BigInteger> bb) {\n                return new Tuple<BigInteger, BigInteger>(\n                    (aa.Item1 * bb.Item1 + aa.Item2 * bb.Item2 * finalOmega) % p,\n                    (aa.Item1 * bb.Item2 + bb.Item1 * aa.Item2) % p\n                );\n            }\n\n            \n            Tuple<BigInteger, BigInteger> r = new Tuple<BigInteger, BigInteger>(1, 0);\n            Tuple<BigInteger, BigInteger> s = new Tuple<BigInteger, BigInteger>(a, 1);\n            BigInteger nn = ((p + 1) >> 1) % p;\n            while (nn > 0) {\n                if ((nn & 1) == 1) {\n                    r = mul(r, s);\n                }\n                s = mul(s, s);\n                nn >>= 1;\n            }\n\n            \n            if (r.Item2 != 0) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            if (r.Item1 * r.Item1 % p != n) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            return new Tuple<BigInteger, BigInteger, bool>(r.Item1, p - r.Item1, true);\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(C(\"10\", \"13\"));\n            Console.WriteLine(C(\"56\", \"101\"));\n            Console.WriteLine(C(\"8218\", \"10007\"));\n            Console.WriteLine(C(\"8219\", \"10007\"));\n            Console.WriteLine(C(\"331575\", \"1000003\"));\n            Console.WriteLine(C(\"665165880\", \"1000000007\"));\n            Console.WriteLine(C(\"881398088036\", \"1000000000039\"));\n            Console.WriteLine(C(\"34035243914635549601583369544560650254325084643201\", \"\"));\n        }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 62,
    "input": "Translate PHP to Python:<?php\nfor ($i = 0; $i < 10; $i++)\n    for ($j = 0; $j < 10; $j++)\n        $a[$i][$j] = rand(1, 20);\n\nforeach ($a as $row) {\n    foreach ($row as $element) {\n        echo \" $element\";\n        if ($element == 20)\n            break 2; // 2 is the number of loops we want to break out of\n    }\n    echo \"\\n\";\n}\necho \"\\n\";\n?>\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from random import randint\n\ndef do_scan(mat):\n    for row in mat:\n        for item in row:\n            print item,\n            if item == 20:\n                print\n                return\n        print\n    print\n\nmat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]\ndo_scan(mat)\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 63,
    "input": "Translate Go to VB:package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 1; i <= 5; i++ {\n        for j := 1; j <= i; j++ {\n            fmt.Printf(\"*\")\n        }\n        fmt.Printf(\"\\n\")\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Public OutConsole As Scripting.TextStream\nFor i = 0 To 4\n    For j = 0 To i\n        OutConsole.Write \"*\"\n    Next j \n    OutConsole.WriteLine\nNext i\n",
    "input_language": "Go",
    "output_language": "VB"
  },
  {
    "id": 64,
    "input": "Translate Java to Go:import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nvar board = []string{\n    \".00.00.\",\n    \"0000000\",\n    \"0000000\",\n    \".00000.\",\n    \"..000..\",\n    \"...0...\",\n}\n\nvar moves = [][2]int{\n    {-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2},\n}\n\nvar grid [][]int\n\nvar totalToFill = 0\n\nfunc solve(r, c, count int) bool {\n    if count > totalToFill {\n        return true\n    }\n    nbrs := neighbors(r, c)\n    if len(nbrs) == 0 && count != totalToFill {\n        return false\n    }\n    sort.Slice(nbrs, func(i, j int) bool {\n        return nbrs[i][2] < nbrs[j][2]\n    })\n\n    for _, nb := range nbrs {\n        r = nb[0]\n        c = nb[1]\n        grid[r][c] = count\n        if solve(r, c, count+1) {\n            return true\n        }\n        grid[r][c] = 0\n    }\n    return false\n}\n\nfunc neighbors(r, c int) (nbrs [][3]int) {\n    for _, m := range moves {\n        x := m[0]\n        y := m[1]\n        if grid[r+y][c+x] == 0 {\n            num := countNeighbors(r+y, c+x) - 1\n            nbrs = append(nbrs, [3]int{r + y, c + x, num})\n        }\n    }\n    return\n}\n\nfunc countNeighbors(r, c int) int {\n    num := 0\n    for _, m := range moves {\n        if grid[r+m[1]][c+m[0]] == 0 {\n            num++\n        }\n    }\n    return num\n}\n\nfunc printResult() {\n    for _, row := range grid {\n        for _, i := range row {\n            if i == -1 {\n                fmt.Print(\"   \")\n            } else {\n                fmt.Printf(\"%2d \", i)\n            }\n        }\n        fmt.Println()\n    }\n}\n\nfunc main() {\n    nRows := len(board) + 6\n    nCols := len(board[0]) + 6\n    grid = make([][]int, nRows)\n    for r := 0; r < nRows; r++ {\n        grid[r] = make([]int, nCols)\n        for c := 0; c < nCols; c++ {\n            grid[r][c] = -1\n        }\n        for c := 3; c < nCols-3; c++ {\n            if r >= 3 && r < nRows-3 {\n                if board[r-3][c-3] == '0' {\n                    grid[r][c] = 0\n                    totalToFill++\n                }\n            }\n        }\n    }\n    pos, r, c := -1, 0, 0\n    for {\n        for {\n            pos++\n            r = pos / nCols\n            c = pos % nCols\n            if grid[r][c] != -1 {\n                break\n            }\n        }\n        grid[r][c] = 1\n        if solve(r, c, 2) {\n            break\n        }\n        grid[r][c] = 0\n        if pos >= nRows*nCols {\n            break\n        }\n    }\n    printResult()\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 65,
    "input": "Translate PHP to Go:<?php\nfunction hashJoin($table1, $index1, $table2, $index2) {\n\n    foreach ($table1 as $s)\n        $h[$s[$index1]][] = $s;\n\n    foreach ($table2 as $r)\n    \tforeach ($h[$r[$index2]] as $s)\n\t    $result[] = array($s, $r);\n    return $result;\n}\n\n$table1 = array(array(27, \"Jonah\"),\n           array(18, \"Alan\"),\n           array(28, \"Glory\"),\n           array(18, \"Popeye\"),\n           array(28, \"Alan\"));\n$table2 = array(array(\"Jonah\", \"Whales\"),\n           array(\"Jonah\", \"Spiders\"),\n           array(\"Alan\", \"Ghosts\"),\n           array(\"Alan\", \"Zombies\"),\n           array(\"Glory\", \"Buffy\"),\n           array(\"Bob\", \"foo\"));\n\nforeach (hashJoin($table1, 1, $table2, 0) as $row)\n    print_r($row);\n?>\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    tableA := []struct {\n        value int\n        key   string\n    }{\n        {27, \"Jonah\"}, {18, \"Alan\"}, {28, \"Glory\"}, {18, \"Popeye\"},\n        {28, \"Alan\"},\n    }\n    tableB := []struct {\n        key   string\n        value string\n    }{\n        {\"Jonah\", \"Whales\"}, {\"Jonah\", \"Spiders\"},\n        {\"Alan\", \"Ghosts\"}, {\"Alan\", \"Zombies\"}, {\"Glory\", \"Buffy\"},\n    }\n    \n    h := map[string][]int{}\n    for i, r := range tableA {\n        h[r.key] = append(h[r.key], i)\n    }\n    \n    for _, x := range tableB {\n        for _, a := range h[x.key] {\n            fmt.Println(tableA[a], x)\n        }\n    }\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 66,
    "input": "Translate C# to VB:using System;\nusing System.Globalization;\n\nstruct LimitedInt : IComparable, IComparable<LimitedInt>, IConvertible, IEquatable<LimitedInt>, IFormattable\n{\n    const int MIN_VALUE = 1;\n    const int MAX_VALUE = 10;\n\n    public static readonly LimitedInt MinValue = new LimitedInt(MIN_VALUE);\n    public static readonly LimitedInt MaxValue = new LimitedInt(MAX_VALUE);\n\n    static bool IsValidValue(int value) => value >= MIN_VALUE && value <= MAX_VALUE;\n\n    readonly int _value;\n    public int Value => this._value == 0 ? MIN_VALUE : this._value; \n\n    public LimitedInt(int value)\n    {\n        if (!IsValidValue(value))\n            throw new ArgumentOutOfRangeException(nameof(value), value, $\"Value must be between {MIN_VALUE} and {MAX_VALUE}.\");\n        this._value = value;\n    }\n\n    #region IComparable\n    public int CompareTo(object obj)\n    {\n        if (obj is LimitedInt l) return this.Value.CompareTo(l);\n        throw new ArgumentException(\"Object must be of type \" + nameof(LimitedInt), nameof(obj));\n    }\n    #endregion\n\n    #region IComparable<LimitedInt>\n    public int CompareTo(LimitedInt other) => this.Value.CompareTo(other.Value);\n    #endregion\n\n    #region IConvertible\n    public TypeCode GetTypeCode() => this.Value.GetTypeCode();\n    bool IConvertible.ToBoolean(IFormatProvider provider) => ((IConvertible)this.Value).ToBoolean(provider);\n    byte IConvertible.ToByte(IFormatProvider provider) => ((IConvertible)this.Value).ToByte(provider);\n    char IConvertible.ToChar(IFormatProvider provider) => ((IConvertible)this.Value).ToChar(provider);\n    DateTime IConvertible.ToDateTime(IFormatProvider provider) => ((IConvertible)this.Value).ToDateTime(provider);\n    decimal IConvertible.ToDecimal(IFormatProvider provider) => ((IConvertible)this.Value).ToDecimal(provider);\n    double IConvertible.ToDouble(IFormatProvider provider) => ((IConvertible)this.Value).ToDouble(provider);\n    short IConvertible.ToInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToInt16(provider);\n    int IConvertible.ToInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToInt32(provider);\n    long IConvertible.ToInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToInt64(provider);\n    sbyte IConvertible.ToSByte(IFormatProvider provider) => ((IConvertible)this.Value).ToSByte(provider);\n    float IConvertible.ToSingle(IFormatProvider provider) => ((IConvertible)this.Value).ToSingle(provider);\n    string IConvertible.ToString(IFormatProvider provider) => this.Value.ToString(provider);\n    object IConvertible.ToType(Type conversionType, IFormatProvider provider) => ((IConvertible)this.Value).ToType(conversionType, provider);\n    ushort IConvertible.ToUInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt16(provider);\n    uint IConvertible.ToUInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt32(provider);\n    ulong IConvertible.ToUInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt64(provider);\n    #endregion\n\n    #region IEquatable<LimitedInt>\n    public bool Equals(LimitedInt other) => this == other;\n    #endregion\n\n    #region IFormattable\n    public string ToString(string format, IFormatProvider formatProvider) => this.Value.ToString(format, formatProvider);\n    #endregion\n\n    #region operators\n    public static bool operator ==(LimitedInt left, LimitedInt right) => left.Value == right.Value;\n    public static bool operator !=(LimitedInt left, LimitedInt right) => left.Value != right.Value;\n    public static bool operator <(LimitedInt left, LimitedInt right) => left.Value < right.Value;\n    public static bool operator >(LimitedInt left, LimitedInt right) => left.Value > right.Value;\n    public static bool operator <=(LimitedInt left, LimitedInt right) => left.Value <= right.Value;\n    public static bool operator >=(LimitedInt left, LimitedInt right) => left.Value >= right.Value;\n\n    public static LimitedInt operator ++(LimitedInt left) => (LimitedInt)(left.Value + 1);\n    public static LimitedInt operator --(LimitedInt left) => (LimitedInt)(left.Value - 1);\n\n    public static LimitedInt operator +(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value + right.Value);\n    public static LimitedInt operator -(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value - right.Value);\n    public static LimitedInt operator *(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value * right.Value);\n    public static LimitedInt operator /(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value / right.Value);\n    public static LimitedInt operator %(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value % right.Value);\n\n    public static LimitedInt operator &(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value & right.Value);\n    public static LimitedInt operator |(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value | right.Value);\n    public static LimitedInt operator ^(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value ^ right.Value);\n    public static LimitedInt operator ~(LimitedInt left) => (LimitedInt)~left.Value;\n\n    public static LimitedInt operator >>(LimitedInt left, int right) => (LimitedInt)(left.Value >> right);\n    public static LimitedInt operator <<(LimitedInt left, int right) => (LimitedInt)(left.Value << right);\n\n    public static implicit operator int(LimitedInt value) => value.Value;\n    public static explicit operator LimitedInt(int value)\n    {\n        if (!IsValidValue(value)) throw new OverflowException();\n        return new LimitedInt(value);\n    }\n    #endregion\n\n    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider provider = null)\n        => this.Value.TryFormat(destination, out charsWritten, format, provider);\n\n    public override int GetHashCode() => this.Value.GetHashCode();\n    public override bool Equals(object obj) => obj is LimitedInt l && this.Equals(l);\n    public override string ToString() => this.Value.ToString();\n\n    #region static methods\n    public static bool TryParse(ReadOnlySpan<char> s, out int result) => int.TryParse(s, out result);\n    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s, IFormatProvider provider) => int.Parse(s, provider);\n    public static int Parse(string s, NumberStyles style, IFormatProvider provider) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, ref int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s) => int.Parse(s);\n    public static int Parse(string s, NumberStyles style) => int.Parse(s, style);\n    public static int Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider provider = null) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, ref int result) => int.TryParse(s, out result);\n    #endregion\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Private mvarValue As Integer\n\nPublic Property Let Value(ByVal vData As Integer)\n    If (vData > 10) Or (vData < 1) Then\n        Error 380   \n    Else\n        mvarValue = vData\n    End If\nEnd Property\n\nPublic Property Get Value() As Integer\n    Value = mvarValue\nEnd Property\n\nPrivate Sub Class_Initialize()\n    \n    mvarValue = 1\nEnd Sub\n",
    "input_language": "C#",
    "output_language": "VB"
  },
  {
    "id": 67,
    "input": "Translate PHP to Java:$server = \"speedtest.tele2.net\";\n$user = \"anonymous\";\n$pass = \"ftptest@example.com\";\n\n$conn = ftp_connect($server);\nif (!$conn) {\n    die('unable to connect to: '. $server);\n}\n$login = ftp_login($conn, $user, $pass);\nif (!$login) {\n    echo 'unable to log in to '. $server. ' with user: '.$user.' and pass: '. $pass;\n} else{\n    echo 'connected successfully'.PHP_EOL;\n    $directory = ftp_nlist($conn,'');\n    print_r($directory);\n}\nif (ftp_get($conn, '1KB.zip', '1KB.zip', FTP_BINARY)) {\n    echo \"Successfully downloaded file\".PHP_EOL;\n} else {\n    echo \"failed to download file\";\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPFile;\nimport org.apache.commons.net.ftp.FTPReply;\n\npublic class FTPconn {\n\n    public static void main(String[] args) throws IOException {\n        String server = \"ftp.hq.nasa.gov\";\n        int port = 21;\n        String user = \"anonymous\";\n        String pass = \"ftptest@example.com\";\n\n        OutputStream output = null;\n\n        FTPClient ftpClient = new FTPClient();\n        try {\n            ftpClient.connect(server, port);\n\n            serverReply(ftpClient);\n\n            int replyCode = ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                System.out.println(\"Failure. Server reply code: \" + replyCode);\n                return;\n            }\n\n            serverReply(ftpClient);\n\n            if (!ftpClient.login(user, pass)) {\n                System.out.println(\"Could not login to the server.\");\n                return;\n            }\n\n            String dir = \"pub/issoutreach/Living in Space Stories (MP3 Files)/\";\n            if (!ftpClient.changeWorkingDirectory(dir)) {\n                System.out.println(\"Change directory failed.\");\n                return;\n            }\n\n            ftpClient.enterLocalPassiveMode();\n\n            for (FTPFile file : ftpClient.listFiles())\n                System.out.println(file);\n\n            String filename = \"Can People go to Mars.mp3\";\n            output = new FileOutputStream(filename);\n\n            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);\n            if (!ftpClient.retrieveFile(filename, output)) {\n                System.out.println(\"Retrieving file failed\");\n                return;\n            }\n\n            serverReply(ftpClient);\n\n            ftpClient.logout();\n\n        } finally {\n            if (output != null)\n                output.close();\n        }\n    }\n\n    private static void serverReply(FTPClient ftpClient) {\n        for (String reply : ftpClient.getReplyStrings()) {\n            System.out.println(reply);\n        }\n    }\n}\n",
    "input_language": "PHP",
    "output_language": "Java"
  },
  {
    "id": 68,
    "input": "Translate C++ to Go:#include <iomanip>\n#include <iostream>\n\n\n\nbool nondecimal(unsigned int n) {\n    for (; n > 0; n >>= 4) {\n        if ((n & 0xF) > 9)\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    unsigned int count = 0;\n    for (unsigned int n = 0; n < 501; ++n) {\n        if (nondecimal(n)) {\n            ++count;\n            std::cout << std::setw(3) << n << (count % 15 == 0 ? '\\n' : ' ');\n        }\n    }\n    std::cout << \"\\n\\n\" << count << \" such numbers found.\\n\";\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n)\n\nfunc main() {\n    const nondecimal = \"abcdef\"\n    c := 0\n    for i := int64(0); i <= 500; i++ {\n        hex := strconv.FormatInt(i, 16)\n        if strings.ContainsAny(nondecimal, hex) {\n            fmt.Printf(\"%3d \", i)\n            c++\n            if c%15 == 0 {\n                fmt.Println()\n            }\n        }\n    }\n    fmt.Printf(\"\\n\\n%d such numbers found.\\n\", c)\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 69,
    "input": "Translate C to Go:#include <stdio.h>\n#include <stdint.h>\n\n\nuint8_t prime(uint8_t n) {\n    uint8_t f;\n    if (n < 2) return 0;\n    for (f = 2; f < n; f++) {\n        if (n % f == 0) return 0;\n    }\n    return 1;\n}\n\n\nuint8_t digit_sum(uint8_t n, uint8_t base) {\n    uint8_t s = 0;\n    do {s += n % base;} while (n /= base);\n    return s;\n}\n\nint main() {\n    uint8_t n, s = 0;\n    for (n = 0; n < 200; n++) {\n        if (prime(digit_sum(n,2)) && prime(digit_sum(n,3))) {\n            printf(\"%4d\",n);\n            if (++s>=10) {\n                printf(\"\\n\");\n                s=0;\n            }\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nfunc main() {\n    var numbers []int\n    for i := 2; i < 200; i++ {\n        bds := rcu.DigitSum(i, 2)\n        if rcu.IsPrime(bds) {\n            tds := rcu.DigitSum(i, 3)\n            if rcu.IsPrime(tds) {\n                numbers = append(numbers, i)\n            }\n        }\n    }\n    fmt.Println(\"Numbers < 200 whose binary and ternary digit sums are prime:\")\n    for i, n := range numbers {\n        fmt.Printf(\"%4d\", n)\n        if (i+1)%14 == 0 {\n            fmt.Println()\n        }\n    }\n    fmt.Printf(\"\\n\\n%d such numbers found\\n\", len(numbers))\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 70,
    "input": "Translate C++ to Go:#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <string>\n\n#include <gmpxx.h>\n\nusing big_int = mpz_class;\n\nauto juggler(int n) {\n    assert(n >= 1);\n    int count = 0, max_count = 0;\n    big_int a = n, max = n;\n    while (a != 1) {\n        if (a % 2 == 0)\n            a = sqrt(a);\n        else\n            a = sqrt(big_int(a * a * a));\n        ++count;\n        if (a > max) {\n            max = a;\n            max_count = count;\n        }\n    }\n    return std::make_tuple(count, max_count, max, max.get_str().size());\n}\n\nint main() {\n    std::cout.imbue(std::locale(\"\"));\n    std::cout << \"n    l[n]  i[n]   h[n]\\n\";\n    std::cout << \"--------------------------------\\n\";\n    for (int n = 20; n < 40; ++n) {\n        auto [count, max_count, max, digits] = juggler(n);\n        std::cout << std::setw(2) << n << \"    \" << std::setw(2) << count\n                  << \"    \" << std::setw(2) << max_count << \"    \" << max\n                  << '\\n';\n    }\n    std::cout << '\\n';\n    std::cout << \"       n       l[n]   i[n]   d[n]\\n\";\n    std::cout << \"----------------------------------------\\n\";\n    for (int n : {113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443,\n                  275485, 1267909, 2264915, 5812827, 7110201, 56261531,\n                  92502777, 172376627, 604398963}) {\n        auto [count, max_count, max, digits] = juggler(n);\n        std::cout << std::setw(11) << n << \"    \" << std::setw(3) << count\n                  << \"    \" << std::setw(3) << max_count << \"    \" << digits\n                  << '\\n';\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \n    big \"github.com/ncw/gmp\"\n    \"rcu\"\n)\n\nvar zero = new(big.Int)\nvar one = big.NewInt(1)\nvar two = big.NewInt(2)\n\nfunc juggler(n int64) (int, int, *big.Int, int) {\n    if n < 1 {\n        log.Fatal(\"Starting value must be a positive integer.\")\n    }\n    count := 0\n    maxCount := 0\n    a := big.NewInt(n)\n    max := big.NewInt(n)\n    tmp := new(big.Int)\n    for a.Cmp(one) != 0 {\n        if tmp.Rem(a, two).Cmp(zero) == 0 {\n            a.Sqrt(a)\n        } else {\n            tmp.Mul(a, a)\n            tmp.Mul(tmp, a)\n            a.Sqrt(tmp)\n        }\n        count++\n        if a.Cmp(max) > 0 {\n            max.Set(a)\n            maxCount = count\n        }\n    }\n    return count, maxCount, max, len(max.String())\n}\n\nfunc main() {\n    fmt.Println(\"n    l[n]  i[n]  h[n]\")\n    fmt.Println(\"-----------------------------------\")\n    for n := int64(20); n < 40; n++ {\n        count, maxCount, max, _ := juggler(n)\n        cmax := rcu.Commatize(int(max.Int64()))\n        fmt.Printf(\"%2d    %2d   %2d    %s\\n\", n, count, maxCount, cmax)\n    }\n    fmt.Println()\n    nums := []int64{\n        113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909,\n        2264915, 5812827, 7110201, 56261531, 92502777, 172376627, 604398963,\n    }\n    fmt.Println(\"       n      l[n]   i[n]   d[n]\")\n    fmt.Println(\"-------------------------------------\")\n    for _, n := range nums {\n        count, maxCount, _, digits := juggler(n)\n        cn := rcu.Commatize(int(n))\n        fmt.Printf(\"%11s   %3d    %3d    %s\\n\", cn, count, maxCount, rcu.Commatize(digits))\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 71,
    "input": "Translate C++ to Python:#include <iostream>\n#include <cctype>\n#include <functional>\n\nusing namespace std;\n\nbool odd()\n{\n  function<void ()> prev = []{};\n  while(true) {\n    int c = cin.get();\n    if (!isalpha(c)) {\n      prev();\n      cout.put(c);\n      return c != '.';\n    }\n    prev = [=] { cout.put(c); prev();  };\n  }\n}\n\nbool even() \n{\n  while(true) {\n    int c;\n    cout.put(c = cin.get());\n    if (!isalpha(c)) return c != '.';\n  }\n}\n\n\nint main()\n{\n  bool e = false;\n  while( e ? odd() : even() ) e = !e;\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 72,
    "input": "Translate Java to VB:import java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class BullsAndCows{\n\tpublic static void main(String[] args){\n\t\tRandom gen= new Random();\n\t\tint target;\n\t\twhile(hasDupes(target= (gen.nextInt(9000) + 1000)));\n\t\tString targetStr = target +\"\";\n\t\tboolean guessed = false;\n\t\tScanner input = new Scanner(System.in);\n\t\tint guesses = 0;\n\t\tdo{\n\t\t\tint bulls = 0;\n\t\t\tint cows = 0;\n\t\t\tSystem.out.print(\"Guess a 4-digit number with no duplicate digits: \");\n\t\t\tint guess;\n\t\t\ttry{\n\t\t\t\tguess = input.nextInt();\n\t\t\t\tif(hasDupes(guess) || guess < 1000) continue;\n\t\t\t}catch(InputMismatchException e){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tguesses++;\n\t\t\tString guessStr = guess + \"\";\n\t\t\tfor(int i= 0;i < 4;i++){\n\t\t\t\tif(guessStr.charAt(i) == targetStr.charAt(i)){\n\t\t\t\t\tbulls++;\n\t\t\t\t}else if(targetStr.contains(guessStr.charAt(i)+\"\")){\n\t\t\t\t\tcows++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bulls == 4){\n\t\t\t\tguessed = true;\n\t\t\t}else{\n\t\t\t\tSystem.out.println(cows+\" Cows and \"+bulls+\" Bulls.\");\n\t\t\t}\n\t\t}while(!guessed);\n\t\tSystem.out.println(\"You won after \"+guesses+\" guesses!\");\n\t}\n\n\tpublic static boolean hasDupes(int num){\n\t\tboolean[] digs = new boolean[10];\n\t\twhile(num > 0){\n\t\t\tif(digs[num%10]) return true;\n\t\t\tdigs[num%10] = true;\n\t\t\tnum/= 10;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Option Explicit\n\nSub Main_Bulls_and_cows()\nDim strNumber As String, strInput As String, strMsg As String, strTemp As String\nDim boolEnd As Boolean\nDim lngCpt As Long\nDim i As Byte, bytCow As Byte, bytBull As Byte\nConst NUMBER_OF_DIGITS As Byte = 4\nConst MAX_LOOPS As Byte = 25 \n\n    strNumber = Create_Number(NUMBER_OF_DIGITS)\n    Do\n        bytBull = 0: bytCow = 0: lngCpt = lngCpt + 1\n        If lngCpt > MAX_LOOPS Then strMsg = \"Max of loops... Sorry you loose!\": Exit Do\n        strInput = AskToUser(NUMBER_OF_DIGITS)\n        If strInput = \"Exit Game\" Then strMsg = \"User abort\": Exit Do\n        For i = 1 To Len(strNumber)\n            If Mid(strNumber, i, 1) = Mid(strInput, i, 1) Then\n                bytBull = bytBull + 1\n            ElseIf InStr(strNumber, Mid(strInput, i, 1)) > 0 Then\n                bytCow = bytCow + 1\n            End If\n        Next i\n        If bytBull = Len(strNumber) Then\n            boolEnd = True: strMsg = \"You win in \" & lngCpt & \" loops!\"\n        Else\n            strTemp = strTemp & vbCrLf & \"With : \" & strInput & \" ,you have : \" & bytBull & \" bulls,\" & bytCow & \" cows.\"\n            MsgBox strTemp\n        End If\n    Loop While Not boolEnd\n    MsgBox strMsg\nEnd Sub\n\nFunction Create_Number(NbDigits As Byte) As String\nDim myColl As New Collection\nDim strTemp As String\nDim bytAlea As Byte\n\n    Randomize\n    Do\n        bytAlea = Int((Rnd * 9) + 1)\n        On Error Resume Next\n        myColl.Add CStr(bytAlea), CStr(bytAlea)\n        If Err <> 0 Then\n            On Error GoTo 0\n        Else\n            strTemp = strTemp & CStr(bytAlea)\n        End If\n    Loop While Len(strTemp) < NbDigits\n    Create_Number = strTemp\nEnd Function\n\nFunction AskToUser(NbDigits As Byte) As String\nDim boolGood As Boolean, strIn As String, i As Byte, NbDiff As Byte\n\n    Do While Not boolGood\n        strIn = InputBox(\"Enter your number (\" & NbDigits & \" digits)\", \"Number\")\n        If StrPtr(strIn) = 0 Then strIn = \"Exit Game\": Exit Do\n        If strIn <> \"\" Then\n            If Len(strIn) = NbDigits Then\n                NbDiff = 0\n                For i = 1 To Len(strIn)\n                    If Len(Replace(strIn, Mid(strIn, i, 1), \"\")) < NbDigits - 1 Then\n                        NbDiff = 1\n                        Exit For\n                    End If\n                Next i\n                If NbDiff = 0 Then boolGood = True\n            End If\n        End If\n    Loop\n    AskToUser = strIn\nEnd Function\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 73,
    "input": "Translate Python to C#:from __future__ import print_function\nimport matplotlib.pyplot as plt\n\nclass AStarGraph(object):\n\t\n\n\tdef __init__(self):\n\t\tself.barriers = []\n\t\tself.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\n\n\tdef heuristic(self, start, goal):\n\t\t\n\t\t\n\t\tD = 1\n\t\tD2 = 1\n\t\tdx = abs(start[0] - goal[0])\n\t\tdy = abs(start[1] - goal[1])\n\t\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\n\tdef get_vertex_neighbours(self, pos):\n\t\tn = []\n\t\t\n\t\tfor dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\n\t\t\tx2 = pos[0] + dx\n\t\t\ty2 = pos[1] + dy\n\t\t\tif x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\n\t\t\t\tcontinue\n\t\t\tn.append((x2, y2))\n\t\treturn n\n\n\tdef move_cost(self, a, b):\n\t\tfor barrier in self.barriers:\n\t\t\tif b in barrier:\n\t\t\t\treturn 100 \n\t\treturn 1 \n\ndef AStarSearch(start, end, graph):\n\n\tG = {} \n\tF = {} \n\n\t\n\tG[start] = 0\n\tF[start] = graph.heuristic(start, end)\n\n\tclosedVertices = set()\n\topenVertices = set([start])\n\tcameFrom = {}\n\n\twhile len(openVertices) > 0:\n\t\t\n\t\tcurrent = None\n\t\tcurrentFscore = None\n\t\tfor pos in openVertices:\n\t\t\tif current is None or F[pos] < currentFscore:\n\t\t\t\tcurrentFscore = F[pos]\n\t\t\t\tcurrent = pos\n\n\t\t\n\t\tif current == end:\n\t\t\t\n\t\t\tpath = [current]\n\t\t\twhile current in cameFrom:\n\t\t\t\tcurrent = cameFrom[current]\n\t\t\t\tpath.append(current)\n\t\t\tpath.reverse()\n\t\t\treturn path, F[end] \n\n\t\t\n\t\topenVertices.remove(current)\n\t\tclosedVertices.add(current)\n\n\t\t\n\t\tfor neighbour in graph.get_vertex_neighbours(current):\n\t\t\tif neighbour in closedVertices:\n\t\t\t\tcontinue \n\t\t\tcandidateG = G[current] + graph.move_cost(current, neighbour)\n\n\t\t\tif neighbour not in openVertices:\n\t\t\t\topenVertices.add(neighbour) \n\t\t\telif candidateG >= G[neighbour]:\n\t\t\t\tcontinue \n\n\t\t\t\n\t\t\tcameFrom[neighbour] = current\n\t\t\tG[neighbour] = candidateG\n\t\t\tH = graph.heuristic(neighbour, end)\n\t\t\tF[neighbour] = G[neighbour] + H\n\n\traise RuntimeError(\"A* failed to find a solution\")\n\nif __name__==\"__main__\":\n\tgraph = AStarGraph()\n\tresult, cost = AStarSearch((0,0), (7,7), graph)\n\tprint (\"route\", result)\n\tprint (\"cost\", cost)\n\tplt.plot([v[0] for v in result], [v[1] for v in result])\n\tfor barrier in graph.barriers:\n\t\tplt.plot([v[0] for v in barrier], [v[1] for v in barrier])\n\tplt.xlim(-1,8)\n\tplt.ylim(-1,8)\n\tplt.show()\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections.Generic;\n\nnamespace A_star\n{\n    class A_star\n    {\n        \n        public class Coordinates : IEquatable<Coordinates>\n        {\n            public int row;\n            public int col;\n\n            public Coordinates() { this.row = -1; this.col = -1; }\n            public Coordinates(int row, int col) { this.row = row; this.col = col; }\n\n            public Boolean Equals(Coordinates c)\n            {\n                if (this.row == c.row && this.col == c.col)\n                    return true;\n                else\n                    return false;\n            }\n        }\n\n        \n        \n        public class Cell\n        {\n            public int cost;\n            public int g;\n            public int f;\n            public Coordinates parent;\n        }\n\n        \n        public class Astar\n        {\n            \n            public Cell[,] cells = new Cell[8, 8];\n            \n            public List<Coordinates> path = new List<Coordinates>();\n            \n            public List<Coordinates> opened = new List<Coordinates>();\n            \n            public List<Coordinates> closed = new List<Coordinates>();\n            \n            public Coordinates startCell = new Coordinates(0, 0);\n            \n            public Coordinates finishCell = new Coordinates(7, 7);\n\n            \n            public Astar()\n            {\n                \n                for (int i = 0; i < 8; i++)\n                    for (int j = 0; j < 8; j++)\n                    {\n                        cells[i, j] = new Cell();\n                        cells[i, j].parent = new Coordinates();\n                        if (IsAWall(i, j))\n                            cells[i, j].cost = 100;\n                        else\n                            cells[i, j].cost = 1;\n                    }\n\n                \n                opened.Add(startCell);\n\n                \n                Boolean pathFound = false;\n\n                \n                do\n                {\n                    List<Coordinates> neighbors = new List<Coordinates>();\n                    \n                    Coordinates currentCell = ShorterExpectedPath();\n                    \n                    neighbors = neighborsCells(currentCell);\n                    foreach (Coordinates newCell in neighbors)\n                    {\n                        \n                        if (newCell.row == finishCell.row && newCell.col == finishCell.col)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            pathFound = true;\n                            break;\n                        }\n\n                        \n                        else if (!opened.Contains(newCell) && !closed.Contains(newCell))\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                        }\n\n                        \n                        \n                        else if (cells[newCell.row, newCell.col].g > cells[currentCell.row,\n                            currentCell.col].g + cells[newCell.row, newCell.col].cost)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                            ResetCell(newCell, closed);\n                        }\n                    }\n                    SetCell(currentCell, closed);\n                    ResetCell(currentCell, opened);\n                } while (opened.Count > 0 && pathFound == false);\n\n                if (pathFound)\n                {\n                    path.Add(finishCell);\n                    Coordinates currentCell = new Coordinates(finishCell.row, finishCell.col);\n                    \n                    while (cells[currentCell.row, currentCell.col].parent.row >= 0)\n                    {\n                        path.Add(cells[currentCell.row, currentCell.col].parent);\n                        int tmp_row = cells[currentCell.row, currentCell.col].parent.row;\n                        currentCell.col = cells[currentCell.row, currentCell.col].parent.col;\n                        currentCell.row = tmp_row;\n                    }\n\n                    \n                    for (int i = 0; i < 8; i++)\n                    {\n                        for (int j = 0; j < 8; j++)\n                        {\n                            \n                            \n                            char gr = '.';\n                            \n                            if (path.Contains(new Coordinates(i, j))) { gr = 'X'; }\n                            \n                            else if (cells[i, j].cost > 1) { gr = '\\u2588'; }\n                            System.Console.Write(gr);\n                        }\n                        System.Console.WriteLine();\n                    }\n\n                    \n                    System.Console.Write(\"\\nPath: \");\n                    for (int i = path.Count - 1; i >= 0; i--)\n                    {\n                        System.Console.Write(\"({0},{1})\", path[i].row, path[i].col);\n                    }\n\n                    \n                    System.Console.WriteLine(\"\\nPath cost: {0}\", path.Count - 1);\n\n                    \n                    String wt = System.Console.ReadLine();\n                }\n            }\n\n            \n            \n            public Coordinates ShorterExpectedPath()\n            {\n                int sep = 0;\n                if (opened.Count > 1)\n                {\n                    for (int i = 1; i < opened.Count; i++)\n                    {\n                        if (cells[opened[i].row, opened[i].col].f < cells[opened[sep].row,\n                            opened[sep].col].f)\n                        {\n                            sep = i;\n                        }\n                    }\n                }\n                return opened[sep];\n            }\n\n            \n            public List<Coordinates> neighborsCells(Coordinates c)\n            {\n                List<Coordinates> lc = new List<Coordinates>();\n                for (int i = -1; i <= 1; i++)\n                    for (int j = -1; j <= 1; j++)\n                        if (c.row+i >= 0 && c.row+i < 8 && c.col+j >= 0 && c.col+j < 8 &&\n                            (i != 0 || j != 0))\n                        {\n                            lc.Add(new Coordinates(c.row + i, c.col + j));\n                        }\n                return lc;\n            }\n\n            \n            public bool IsAWall(int row, int col)\n            {\n                int[,] walls = new int[,] { { 2, 4 }, { 2, 5 }, { 2, 6 }, { 3, 6 }, { 4, 6 },\n                    { 5, 6 }, { 5, 5 }, { 5, 4 }, { 5, 3 }, { 5, 2 }, { 4, 2 }, { 3, 2 } };\n                bool found = false;\n                for (int i = 0; i < walls.GetLength(0); i++)\n                    if (walls[i,0] == row && walls[i,1] == col)\n                        found = true;\n                return found;\n            }\n\n            \n            \n            public int Heuristic(Coordinates cell)\n            {\n                int dRow = Math.Abs(finishCell.row - cell.row);\n                int dCol = Math.Abs(finishCell.col - cell.col);\n                return Math.Max(dRow, dCol);\n            }\n\n            \n            public void SetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell) == false)\n                {\n                    coordinatesList.Add(cell);\n                }\n            }\n\n            \n            public void ResetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell))\n                {\n                    coordinatesList.Remove(cell);\n                }\n            }\n        }\n\n        \n        static void Main(string[] args)\n        {\n            Astar astar = new Astar();\n        }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 74,
    "input": "Translate C to Python:#include <windows.h>\n#include \"resource.h\"\n\nBOOL CALLBACK DlgProc( HWND hwnd, UINT msg, WPARAM wPar, LPARAM lPar ) {\n    switch( msg ) {\n\n        case WM_INITDIALOG:\n            srand( GetTickCount() );\n            SetDlgItemInt( hwnd, IDC_INPUT, 0, FALSE );\n            break;\n\n        case WM_COMMAND:\n            switch( LOWORD(wPar) ) {\n                case IDC_INCREMENT: {\n                    UINT n = GetDlgItemInt( hwnd, IDC_INPUT, NULL, FALSE );\n                    SetDlgItemInt( hwnd, IDC_INPUT, ++n, FALSE );\n                    } break;\n                case IDC_RANDOM: {\n                    int reply = MessageBox( hwnd,\n                        \"Do you really want to\\nget a random number?\",\n                        \"Random input confirmation\", MB_ICONQUESTION|MB_YESNO );\n                    if( reply == IDYES )\n                        SetDlgItemInt( hwnd, IDC_INPUT, rand(), FALSE );\n                    } break;\n                case IDC_QUIT:\n                    SendMessage( hwnd, WM_CLOSE, 0, 0 );\n                    break;\n                default: ;\n            }\n            break;\n\n        case WM_CLOSE: {\n            int reply = MessageBox( hwnd,\n                \"Do you really want to quit?\",\n                \"Quit confirmation\", MB_ICONQUESTION|MB_YESNO );\n            if( reply == IDYES )\n                EndDialog( hwnd, 0 );\n            } break;\n\n        default: ;\n    }\n\n    return 0;\n}\n\nint WINAPI WinMain( HINSTANCE hInst, HINSTANCE hPInst, LPSTR cmdLn, int show ) {\n    return DialogBox( hInst, MAKEINTRESOURCE(IDD_DLG), NULL, DlgProc );\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import random, tkMessageBox\nfrom Tkinter import *\nwindow = Tk()\nwindow.geometry(\"300x50+100+100\")\noptions = { \"padx\":5, \"pady\":5}\ns=StringVar()\ns.set(1)\ndef increase():\n    s.set(int(s.get())+1)\ndef rand():\n    if tkMessageBox.askyesno(\"Confirmation\", \"Reset to random value ?\"):\n        s.set(random.randrange(0,5000))\ndef update(e):\n    if not e.char.isdigit():\n        tkMessageBox.showerror('Error', 'Invalid input !') \n        return \"break\"\ne = Entry(text=s)\ne.grid(column=0, row=0, **options)\ne.bind('<Key>', update)\nb1 = Button(text=\"Increase\", command=increase, **options )\nb1.grid(column=1, row=0, **options)\nb2 = Button(text=\"Random\", command=rand, **options)\nb2.grid(column=2, row=0, **options)\nmainloop()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 75,
    "input": "Translate C to Go:\n#include<stdio.h> \n\n\n#define Hi printf(\"Hi There.\");\n\n\n\n#define start int main(){\n#define end return 0;}\n\nstart\n\nHi\n\n\n#warning \"Don't you have anything better to do ?\"\n\n#ifdef __unix__\n#warning \"What are you doing still working on Unix ?\"\nprintf(\"\\nThis is an Unix system.\");\n#elif _WIN32\n#warning \"You couldn't afford a 64 bit ?\"\nprintf(\"\\nThis is a 32 bit Windows system.\");\n#elif _WIN64\n#warning \"You couldn't afford an Apple ?\"\nprintf(\"\\nThis is a 64 bit Windows system.\");\n#endif\n\nend\n\n\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 76,
    "input": "Translate Java to Python:import java.io.*;\nimport java.nio.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.*;\nimport java.security.*;\nimport java.util.*;\n\npublic class DuplicateFiles {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.err.println(\"Directory name and minimum file size are required.\");\n            System.exit(1);\n        }\n        try {\n            findDuplicateFiles(args[0], Long.parseLong(args[1]));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void findDuplicateFiles(String directory, long minimumSize)\n        throws IOException, NoSuchAlgorithmException {\n        System.out.println(\"Directory: '\" + directory + \"', minimum size: \" + minimumSize + \" bytes.\");\n        Path path = FileSystems.getDefault().getPath(directory);\n        FileVisitor visitor = new FileVisitor(path, minimumSize);\n        Files.walkFileTree(path, visitor);\n        System.out.println(\"The following sets of files have the same size and checksum:\");\n        for (Map.Entry<FileKey, Map<Object, List<String>>> e : visitor.fileMap_.entrySet()) {\n            Map<Object, List<String>> map = e.getValue();\n            if (!containsDuplicates(map))\n                continue;\n            List<List<String>> fileSets = new ArrayList<>(map.values());\n            for (List<String> files : fileSets)\n                Collections.sort(files);\n            Collections.sort(fileSets, new StringListComparator());\n            FileKey key = e.getKey();\n            System.out.println();\n            System.out.println(\"Size: \" + key.size_ + \" bytes\");\n            for (List<String> files : fileSets) {\n                for (int i = 0, n = files.size(); i < n; ++i) {\n                    if (i > 0)\n                        System.out.print(\" = \");\n                    System.out.print(files.get(i));\n                }\n                System.out.println();\n            }\n        }\n    }\n\n    private static class StringListComparator implements Comparator<List<String>> {\n        public int compare(List<String> a, List<String> b) {\n            int len1 = a.size(), len2 = b.size();\n            for (int i = 0; i < len1 && i < len2; ++i) {\n                int c = a.get(i).compareTo(b.get(i));\n                if (c != 0)\n                    return c;\n            }\n            return Integer.compare(len1, len2);\n        }\n    }\n\n    private static boolean containsDuplicates(Map<Object, List<String>> map) {\n        if (map.size() > 1)\n            return true;\n        for (List<String> files : map.values()) {\n            if (files.size() > 1)\n                return true;\n        }\n        return false;\n    }\n\n    private static class FileVisitor extends SimpleFileVisitor<Path> {\n        private MessageDigest digest_;\n        private Path directory_;\n        private long minimumSize_;\n        private Map<FileKey, Map<Object, List<String>>> fileMap_ = new TreeMap<>();\n\n        private FileVisitor(Path directory, long minimumSize) throws NoSuchAlgorithmException {\n            directory_ = directory;\n            minimumSize_ = minimumSize;\n            digest_ = MessageDigest.getInstance(\"MD5\");\n        }\n\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            if (attrs.size() >= minimumSize_) {\n                FileKey key = new FileKey(file, attrs, getMD5Sum(file));\n                Map<Object, List<String>> map = fileMap_.get(key);\n                if (map == null)\n                    fileMap_.put(key, map = new HashMap<>());\n                List<String> files = map.get(attrs.fileKey());\n                if (files == null)\n                    map.put(attrs.fileKey(), files = new ArrayList<>());\n                Path relative = directory_.relativize(file);\n                files.add(relative.toString());\n            }\n            return FileVisitResult.CONTINUE;\n        }\n\n        private byte[] getMD5Sum(Path file) throws IOException {\n            digest_.reset();\n            try (InputStream in = new FileInputStream(file.toString())) {\n                byte[] buffer = new byte[8192];\n                int bytes;\n                while ((bytes = in.read(buffer)) != -1) {\n                    digest_.update(buffer, 0, bytes);\n                }\n            }\n            return digest_.digest();\n        }\n    }\n\n    private static class FileKey implements Comparable<FileKey> {\n        private byte[] hash_;\n        private long size_;\n\n        private FileKey(Path file, BasicFileAttributes attrs, byte[] hash) throws IOException {\n            size_ = attrs.size();\n            hash_ = hash;\n        }\n\n        public int compareTo(FileKey other) {\n            int c = Long.compare(other.size_, size_);\n            if (c == 0)\n                c = hashCompare(hash_, other.hash_);\n            return c;\n        }\n    }\n\n    private static int hashCompare(byte[] a, byte[] b) {\n        int len1 = a.length, len2 = b.length;\n        for (int i = 0; i < len1 && i < len2; ++i) {\n            int c = Byte.compare(a[i], b[i]);\n            if (c != 0)\n                return c;\n        }\n        return Integer.compare(len1, len2);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from __future__ import print_function\nimport os\nimport hashlib\nimport datetime\n\ndef FindDuplicateFiles(pth, minSize = 0, hashName = \"md5\"):\n    knownFiles = {}\n\n    \n    for root, dirs, files in os.walk(pth):\n        for fina in files:\n            fullFina = os.path.join(root, fina)\n            isSymLink = os.path.islink(fullFina)\n            if isSymLink:\n                continue \n            si = os.path.getsize(fullFina)\n            if si < minSize:\n                continue\n            if si not in knownFiles:\n                knownFiles[si] = {}\n            h = hashlib.new(hashName)\n            h.update(open(fullFina, \"rb\").read())\n            hashed = h.digest()\n            if hashed in knownFiles[si]:\n                fileRec = knownFiles[si][hashed]\n                fileRec.append(fullFina)\n            else:\n                knownFiles[si][hashed] = [fullFina]\n\n    \n    sizeList = list(knownFiles.keys())\n    sizeList.sort(reverse=True)\n    for si in sizeList:\n        filesAtThisSize = knownFiles[si]\n        for hashVal in filesAtThisSize:\n            if len(filesAtThisSize[hashVal]) < 2:\n                continue\n            fullFinaLi = filesAtThisSize[hashVal]\n            print (\"=======Duplicate=======\")\n            for fullFina in fullFinaLi:\n                st = os.stat(fullFina)\n                isHardLink = st.st_nlink > 1 \n                infoStr = []\n                if isHardLink:\n                    infoStr.append(\"(Hard linked)\")\n                fmtModTime = datetime.datetime.utcfromtimestamp(st.st_mtime).strftime('%Y-%m-%dT%H:%M:%SZ')\n                print (fmtModTime, si, os.path.relpath(fullFina, pth), \" \".join(infoStr))\n\nif __name__==\"__main__\":\n\n    FindDuplicateFiles('/home/tim/Dropbox', 1024*1024)\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 77,
    "input": "Translate C to Java:#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nchar text_char(char c) {\n    switch (c) {\n    case 'a': case 'b': case 'c':\n        return '2';\n    case 'd': case 'e': case 'f':\n        return '3';\n    case 'g': case 'h': case 'i':\n        return '4';\n    case 'j': case 'k': case 'l':\n        return '5';\n    case 'm': case 'n': case 'o':\n        return '6';\n    case 'p': case 'q': case 'r': case 's':\n        return '7';\n    case 't': case 'u': case 'v':\n        return '8';\n    case 'w': case 'x': case 'y': case 'z':\n        return '9';\n    default:\n        return 0;\n    }\n}\n\nbool text_string(const GString* word, GString* text) {\n    g_string_set_size(text, word->len);\n    for (size_t i = 0; i < word->len; ++i) {\n        char c = text_char(g_ascii_tolower(word->str[i]));\n        if (c == 0)\n            return false;\n        text->str[i] = c;\n    }\n    return true;\n}\n\ntypedef struct textonym_tag {\n    const char* text;\n    size_t length;\n    GPtrArray* words;\n} textonym_t;\n\nint compare_by_text_length(const void* p1, const void* p2) {\n    const textonym_t* t1 = p1;\n    const textonym_t* t2 = p2;\n    if (t1->length > t2->length)\n        return -1;\n    if (t1->length < t2->length)\n        return 1;\n    return strcmp(t1->text, t2->text);\n}\n\nint compare_by_word_count(const void* p1, const void* p2) {\n    const textonym_t* t1 = p1;\n    const textonym_t* t2 = p2;\n    if (t1->words->len > t2->words->len)\n        return -1;\n    if (t1->words->len < t2->words->len)\n        return 1;\n    return strcmp(t1->text, t2->text);\n}\n\nvoid print_words(GPtrArray* words) {\n    for (guint i = 0, n = words->len; i < n; ++i) {\n        if (i > 0)\n            printf(\", \");\n        printf(\"%s\", g_ptr_array_index(words, i));\n    }\n    printf(\"\\n\");\n}\n\nvoid print_top_words(GArray* textonyms, guint top) {\n    for (guint i = 0; i < top; ++i) {\n        const textonym_t* t = &g_array_index(textonyms, textonym_t, i);\n        printf(\"%s = \", t->text);\n        print_words(t->words);\n    }\n}\n\nvoid free_strings(gpointer ptr) {\n    g_ptr_array_free(ptr, TRUE);\n}\n\nbool find_textonyms(const char* filename, GError** error_ptr) {\n    GError* error = NULL;\n    GIOChannel* channel = g_io_channel_new_file(filename, \"r\", &error);\n    if (channel == NULL) {\n        g_propagate_error(error_ptr, error);\n        return false;\n    }\n    GHashTable* ht = g_hash_table_new_full(g_str_hash, g_str_equal,\n                                           g_free, free_strings);\n    GString* word = g_string_sized_new(64);\n    GString* text = g_string_sized_new(64);\n    guint count = 0;\n    gsize term_pos;\n    while (g_io_channel_read_line_string(channel, word, &term_pos,\n                                         &error) == G_IO_STATUS_NORMAL) {\n        g_string_truncate(word, term_pos);\n        if (!text_string(word, text))\n            continue;\n        GPtrArray* words = g_hash_table_lookup(ht, text->str);\n        if (words == NULL) {\n            words = g_ptr_array_new_full(1, g_free);\n            g_hash_table_insert(ht, g_strdup(text->str), words);\n        }\n        g_ptr_array_add(words, g_strdup(word->str));\n        ++count;\n    }\n    g_io_channel_unref(channel);\n    g_string_free(word, TRUE);\n    g_string_free(text, TRUE);\n    if (error != NULL) {\n        g_propagate_error(error_ptr, error);\n        g_hash_table_destroy(ht);\n        return false;\n    }\n\n    GArray* words = g_array_new(FALSE, FALSE, sizeof(textonym_t));\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, ht);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        GPtrArray* v = value;\n        if (v->len > 1) {\n            textonym_t textonym;\n            textonym.text = key;\n            textonym.length = strlen(key);\n            textonym.words = v;\n            g_array_append_val(words, textonym);\n        }\n    }\n\n    printf(\"There are %u words in '%s' which can be represented by the digit key mapping.\\n\",\n           count, filename);\n    guint size = g_hash_table_size(ht);\n    printf(\"They require %u digit combinations to represent them.\\n\", size);\n    guint textonyms = words->len;\n    printf(\"%u digit combinations represent Textonyms.\\n\", textonyms);\n\n    guint top = 5;\n    if (textonyms < top)\n        top = textonyms;\n\n    printf(\"\\nTop %u by number of words:\\n\", top);\n    g_array_sort(words, compare_by_word_count);\n    print_top_words(words, top);\n    \n    printf(\"\\nTop %u by length:\\n\", top);\n    g_array_sort(words, compare_by_text_length);\n    print_top_words(words, top);\n\n    g_array_free(words, TRUE);\n    g_hash_table_destroy(ht);\n    return true;\n}\n\nint main(int argc, char** argv) {\n    if (argc != 2) {\n        fprintf(stderr, \"usage: %s word-list\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n    GError* error = NULL;\n    if (!find_textonyms(argv[1], &error)) {\n        if (error != NULL) {\n            fprintf(stderr, \"%s: %s\\n\", argv[1], error->message);\n            g_error_free(error);\n        }\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class RTextonyms {\n\n  private static final Map<Character, Character> mapping;\n  private int total, elements, textonyms, max_found;\n  private String filename, mappingResult;\n  private Vector<String> max_strings;\n  private Map<String, Vector<String>> values;\n\n  static {\n    mapping = new HashMap<Character, Character>();\n    mapping.put('A', '2'); mapping.put('B', '2'); mapping.put('C', '2');\n    mapping.put('D', '3'); mapping.put('E', '3'); mapping.put('F', '3');\n    mapping.put('G', '4'); mapping.put('H', '4'); mapping.put('I', '4');\n    mapping.put('J', '5'); mapping.put('K', '5'); mapping.put('L', '5');\n    mapping.put('M', '6'); mapping.put('N', '6'); mapping.put('O', '6');\n    mapping.put('P', '7'); mapping.put('Q', '7'); mapping.put('R', '7'); mapping.put('S', '7');\n    mapping.put('T', '8'); mapping.put('U', '8'); mapping.put('V', '8');\n    mapping.put('W', '9'); mapping.put('X', '9'); mapping.put('Y', '9'); mapping.put('Z', '9');\n  }\n\n  public RTextonyms(String filename) {\n\n    this.filename = filename;\n    this.total = this.elements = this.textonyms = this.max_found = 0;\n    this.values = new HashMap<String, Vector<String>>();\n    this.max_strings = new Vector<String>();\n\n    return;\n  }\n\n  public void add(String line) {\n\n    String mapping = \"\";\n    total++;\n    if (!get_mapping(line)) {\n      return;\n    }\n    mapping = mappingResult;\n\n    if (values.get(mapping) == null) {\n      values.put(mapping, new Vector<String>());\n    }\n\n    int num_strings;\n    num_strings = values.get(mapping).size();\n    textonyms += num_strings == 1 ? 1 : 0;\n    elements++;\n\n    if (num_strings > max_found) {\n      max_strings.clear();\n      max_strings.add(mapping);\n      max_found = num_strings;\n    }\n    else if (num_strings == max_found) {\n      max_strings.add(mapping);\n    }\n\n    values.get(mapping).add(line);\n\n    return;\n  }\n\n  public void results() {\n\n    System.out.printf(\"Read %,d words from %s%n%n\", total, filename);\n    System.out.printf(\"There are %,d words in %s which can be represented by the digit key mapping.%n\", elements,\n        filename);\n    System.out.printf(\"They require %,d digit combinations to represent them.%n\", values.size());\n    System.out.printf(\"%,d digit combinations represent Textonyms.%n\", textonyms);\n    System.out.printf(\"The numbers mapping to the most words map to %,d words each:%n\", max_found + 1);\n    for (String key : max_strings) {\n      System.out.printf(\"%16s maps to: %s%n\", key, values.get(key).toString());\n    }\n    System.out.println();\n\n    return;\n  }\n\n  public void match(String key) {\n\n    Vector<String> match;\n    match = values.get(key);\n    if (match == null) {\n      System.out.printf(\"Key %s not found%n\", key);\n    }\n    else {\n      System.out.printf(\"Key %s matches: %s%n\", key, match.toString());\n    }\n\n    return;\n  }\n\n  private boolean get_mapping(String line) {\n\n    mappingResult = line;\n    StringBuilder mappingBuilder = new StringBuilder();\n    for (char cc : line.toCharArray()) {\n      if (Character.isAlphabetic(cc)) {\n        mappingBuilder.append(mapping.get(Character.toUpperCase(cc)));\n      }\n      else if (Character.isDigit(cc)) {\n        mappingBuilder.append(cc);\n      }\n      else {\n        return false;\n      }\n    }\n    mappingResult = mappingBuilder.toString();\n\n    return true;\n  }\n\n  public static void main(String[] args) {\n\n    String filename;\n    if (args.length > 0) {\n      filename = args[0];\n    }\n    else {\n      filename = \"./unixdict.txt\";\n    }\n    RTextonyms tc;\n    tc = new RTextonyms(filename);\n    Path fp = Paths.get(filename);\n    try (Scanner fs = new Scanner(fp, StandardCharsets.UTF_8.name())) {\n      while (fs.hasNextLine()) {\n        tc.add(fs.nextLine());\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n\n    List<String> numbers = Arrays.asList(\n        \"001\", \"228\", \"27484247\", \"7244967473642\",\n        \".\"\n        );\n\n    tc.results();\n    for (String number : numbers) {\n      if (number.equals(\".\")) {\n        System.out.println();\n      }\n      else {\n        tc.match(number);\n      }\n    }\n\n    return;\n  }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 78,
    "input": "Translate C++ to Java:#include <algorithm>\n#include <cctype>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n\nbool endsWithIgnoreCase(const std::string& str, const std::string& suffix) {\n    const size_t n1 = str.length();\n    const size_t n2 = suffix.length();\n    if (n1 < n2)\n        return false;\n    return std::equal(str.begin() + (n1 - n2), str.end(), suffix.begin(),\n        [](char c1, char c2) {\n            return std::tolower(static_cast<unsigned char>(c1))\n                == std::tolower(static_cast<unsigned char>(c2));\n    });\n}\n\nbool filenameHasExtension(const std::string& filename,\n                          const std::vector<std::string>& extensions) {\n    return std::any_of(extensions.begin(), extensions.end(),\n        [&filename](const std::string& extension) {\n            return endsWithIgnoreCase(filename, \".\" + extension);\n    });\n}\n\nvoid test(const std::string& filename,\n          const std::vector<std::string>& extensions) {\n    std::cout << std::setw(20) << std::left << filename\n        << \": \" << std::boolalpha\n        << filenameHasExtension(filename, extensions) << '\\n';\n}\n\nint main() {\n    const std::vector<std::string> extensions{\"zip\", \"rar\", \"7z\",\n        \"gz\", \"archive\", \"A##\", \"tar.bz2\"};\n    test(\"MyData.a##\", extensions);\n    test(\"MyData.tar.Gz\", extensions);\n    test(\"MyData.gzip\", extensions);\n    test(\"MyData.7z.backup\", extensions);\n    test(\"MyData...\", extensions);\n    test(\"MyData\", extensions);\n    test(\"MyData_v1.0.tar.bz2\", extensions);\n    test(\"MyData_v1.0.bz2\", extensions);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 79,
    "input": "Translate C to PHP:#include <stdio.h>\n#include <time.h>\n\n#define note_file \"NOTES.TXT\"\n\nint main(int argc, char**argv)\n{\n\tFILE *note = 0;\n\ttime_t tm;\n\tint i;\n\tchar *p;\n\n\tif (argc < 2) {\n\t\tif ((note = fopen(note_file, \"r\")))\n\t\t\twhile ((i = fgetc(note)) != EOF)\n\t\t\t\tputchar(i);\n\n\t} else if ((note = fopen(note_file, \"a\"))) {\n\t\ttm = time(0);\n\t\tp = ctime(&tm);\n\n\t\t\n\t\twhile (*p) fputc(*p != '\\n'?*p:'\\t', note), p++;\n\n\t\tfor (i = 1; i < argc; i++)\n\t\t\tfprintf(note, \"%s%c\", argv[i], 1 + i - argc ? ' ' : '\\n');\n\t}\n\n\tif (note) fclose(note);\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "#!/usr/bin/php\n<?php\nif ($argc > 1)\n    file_put_contents(\n        'notes.txt', \n        date('r').\"\\n\\t\".implode(' ', array_slice($argv, 1)).\"\\n\",\n        FILE_APPEND\n    );\nelse\n    @readfile('notes.txt');\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 80,
    "input": "Translate C++ to VB:\n\n#include <QImage>\n#include <QPainter>\n\nint main() {\n    const QColor black(0, 0, 0);\n    const QColor white(255, 255, 255);\n\n    const int size = 300;\n    const double diameter = 0.6 * size;\n\n    QImage image(size, size, QImage::Format_RGB32);\n    QPainter painter(&image);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    QLinearGradient linearGradient(0, 0, 0, size);\n    linearGradient.setColorAt(0, white);\n    linearGradient.setColorAt(1, black);\n\n    QBrush brush(linearGradient);\n    painter.fillRect(QRect(0, 0, size, size), brush);\n\n    QPointF point1(0.4 * size, 0.4 * size);\n    QPointF point2(0.45 * size, 0.4 * size);\n    QRadialGradient radialGradient(point1, size * 0.5, point2, size * 0.1);\n    radialGradient.setColorAt(0, white);\n    radialGradient.setColorAt(1, black);\n\n    QBrush brush2(radialGradient);\n    painter.setPen(Qt::NoPen);\n    painter.setBrush(brush2);\n    painter.drawEllipse(QRectF((size - diameter)/2, (size - diameter)/2, diameter, diameter));\n\n    image.save(\"sphere.png\");\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "shades = Array(\".\", \":\", \"!\", \"*\", \"o\", \"e\", \"&\", \"#\", \"%\", \"@\")\nlight = Array(30, 30, -50)\n\nSub Normalize(v)\n   length = Sqr(v(0)*v(0) + v(1)*v(1) + v(2)*v(2))\n   v(0) = v(0)/length : v(1) = v(1)/length : v(2) = v(2)/length\nEnd Sub\n\nFunction Dot(x, y)\n   d = x(0)*y(0) + x(1)*y(1) + x(2)*y(2)\n   If d < 0 Then Dot = -d Else Dot = 0 End If\nEnd Function\n\n\n\nFunction Ceil(x)\n    Ceil = Int(x)\n    If Ceil <> x Then Ceil = Ceil + 1 End if\nEnd Function\n\nSub DrawSphere(R, k, ambient)\n   Dim i, j, intensity, inten, b, x, y\n   Dim vec(3)\n   For i = Int(-R) to Ceil(R)\n      x = i + 0.5\n      line = \"\"\n      For j = Int(-2*R) to Ceil(2*R)\n         y = j / 2 + 0.5\n         If x * x + y * y <= R*R Then\n            vec(0) = x\n            vec(1) = y\n            vec(2) = Sqr(R * R - x * x - y * y)\n            Normalize vec\n            b = dot(light, vec)^k + ambient\n            intensity = Int((1 - b) * UBound(shades))\n            If intensity < 0 Then intensity = 0 End If\n            If intensity >= UBound(shades) Then\n               intensity = UBound(shades)\n            End If\n            line = line & shades(intensity)\n         Else\n            line = line & \" \"\n         End If\n      Next\n      WScript.StdOut.WriteLine line\n   Next\nEnd Sub\n\nNormalize light\nDrawSphere 20, 4, 0.1\nDrawSphere 10,2,0.4\n",
    "input_language": "C++",
    "output_language": "VB"
  },
  {
    "id": 81,
    "input": "Translate Java to Go:public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc prodDivisors(n int) int {\n    prod := 1\n    i := 1\n    k := 2\n    if n%2 == 0 {\n        k = 1\n    }\n    for i*i <= n {\n        if n%i == 0 {\n            prod *= i\n            j := n / i\n            if j != i {\n                prod *= j\n            }\n        }\n        i += k\n    }\n    return prod\n}\n\nfunc main() {\n    fmt.Println(\"The products of positive divisors for the first 50 positive integers are:\")\n    for i := 1; i <= 50; i++ {\n        fmt.Printf(\"%9d  \", prodDivisors(i))\n        if i%5 == 0 {\n            fmt.Println()\n        }\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 82,
    "input": "Translate PHP to Go:<?php\n$pairs = array( \"hello\" => 1,\n\t\t\"world\" => 2,\n\t\t\"!\"     => 3 );\n\nforeach($pairs as $k => $v) {\n  echo \"(k,v) = ($k, $v)\\n\";\n}\n\nforeach(array_keys($pairs) as $key) {\n  echo \"key = $key, value = $pairs[$key]\\n\";\n}\n\nforeach($pairs as $value) {\n  echo \"values = $value\\n\";\n}\n?>\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "myMap := map[string]int {\n\t   \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 }\n\n\nfor key, value := range myMap {\n    fmt.Printf(\"key = %s, value = %d\\n\", key, value)\n}\n\n\nfor key := range myMap {\n    fmt.Printf(\"key = %s\\n\", key)\n}\n\n\nfor _, value := range myMap {\n    fmt.Printf(\"value = %d\\n\", value)\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 83,
    "input": "Translate Java to VB:package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Function read_line(filepath,n)\n\tSet objFSO = CreateObject(\"Scripting.FileSystemObject\")\n\tSet objFile = objFSO.OpenTextFile(filepath,1)\n\tarrLines = Split(objFile.ReadAll,vbCrLf)\n\tIf UBound(arrLines) >= n-1 Then\n\t\tIf arrLines(n-1) <> \"\" Then\n\t\t\tread_line = arrLines(n-1)\n\t\tElse\n\t\t\tread_line = \"Line \" & n & \" is null.\"\n\t\tEnd If\n\tElse\n\t\tread_line = \"Line \" & n & \" does not exist.\"\n\tEnd If\n\tobjFile.Close\n\tSet objFSO = Nothing\nEnd Function\n\nWScript.Echo read_line(\"c:\\temp\\input.txt\",7)\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 84,
    "input": "Translate Java to Python:import java.io.File;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class TextProcessing1 {\n\n    public static void main(String[] args) throws Exception {\n        Locale.setDefault(new Locale(\"en\", \"US\"));\n        Metrics metrics = new Metrics();\n\n        int dataGap = 0;\n        String gapBeginDate = null;\n        try (Scanner lines = new Scanner(new File(\"readings.txt\"))) {\n            while (lines.hasNextLine()) {\n\n                double lineTotal = 0.0;\n                int linePairs = 0;\n                int lineInvalid = 0;\n                String lineDate;\n\n                try (Scanner line = new Scanner(lines.nextLine())) {\n\n                    lineDate = line.next();\n\n                    while (line.hasNext()) {\n                        final double value = line.nextDouble();\n                        if (line.nextInt() <= 0) {\n                            if (dataGap == 0)\n                                gapBeginDate = lineDate;\n                            dataGap++;\n                            lineInvalid++;\n                            continue;\n                        }\n                        lineTotal += value;\n                        linePairs++;\n\n                        metrics.addDataGap(dataGap, gapBeginDate, lineDate);\n                        dataGap = 0;\n                    }\n                }\n                metrics.addLine(lineTotal, linePairs);\n                metrics.lineResult(lineDate, lineInvalid, linePairs, lineTotal);\n            }\n            metrics.report();\n        }\n    }\n\n    private static class Metrics {\n        private List<String[]> gapDates;\n        private int maxDataGap = -1;\n        private double total;\n        private int pairs;\n        private int lineResultCount;\n\n        void addLine(double tot, double prs) {\n            total += tot;\n            pairs += prs;\n        }\n\n        void addDataGap(int gap, String begin, String end) {\n            if (gap > 0 && gap >= maxDataGap) {\n                if (gap > maxDataGap) {\n                    maxDataGap = gap;\n                    gapDates = new ArrayList<>();\n                }\n                gapDates.add(new String[]{begin, end});\n            }\n        }\n\n        void lineResult(String date, int invalid, int prs, double tot) {\n            if (lineResultCount >= 3)\n                return;\n            out.printf(\"%10s  out: %2d  in: %2d  tot: %10.3f  avg: %10.3f%n\",\n                    date, invalid, prs, tot, (prs > 0) ? tot / prs : 0.0);\n            lineResultCount++;\n        }\n\n        void report() {\n            out.printf(\"%ntotal    = %10.3f%n\", total);\n            out.printf(\"readings = %6d%n\", pairs);\n            out.printf(\"average  = %010.3f%n\", total / pairs);\n            out.printf(\"%nmaximum run(s) of %d invalid measurements: %n\",\n                    maxDataGap);\n            for (String[] dates : gapDates)\n                out.printf(\"begins at %s and ends at %s%n\", dates[0], dates[1]);\n\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import fileinput\nimport sys\n\nnodata = 0;             \nnodata_max=-1;          \nnodata_maxline=[];      \n\ntot_file = 0            \nnum_file = 0            \n\ninfiles = sys.argv[1:]\n\nfor line in fileinput.input():\n  tot_line=0;             \n  num_line=0;             \n\n  \n  field = line.split()\n  date  = field[0]\n  data  = [float(f) for f in field[1::2]]\n  flags = [int(f)   for f in field[2::2]]\n\n  for datum, flag in zip(data, flags):\n    if flag<1:\n      nodata += 1\n    else:\n      \n      if nodata_max==nodata and nodata>0:\n        nodata_maxline.append(date)\n      if nodata_max<nodata and nodata>0:\n        nodata_max=nodata\n        nodata_maxline=[date]\n      \n      nodata=0; \n      \n      tot_line += datum\n      num_line += 1\n\n  \n  tot_file += tot_line\n  num_file += num_line\n\n  print \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\" % (\n        date, \n        len(data) -num_line, \n        num_line, tot_line, \n        tot_line/num_line if (num_line>0) else 0)\n\nprint \"\"\nprint \"File(s)  = %s\" % (\", \".join(infiles),)\nprint \"Total    = %10.3f\" % (tot_file,)\nprint \"Readings = %6i\" % (num_file,)\nprint \"Average  = %10.3f\" % (tot_file / num_file,)\n\nprint \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\" % (\n    nodata_max, \", \".join(nodata_maxline))\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 85,
    "input": "Translate Python to Go:from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"golang.org/x/crypto/ssh/terminal\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    if terminal.IsTerminal(int(os.Stdin.Fd())) {\n        fmt.Println(\"Hello terminal\")\n    } else {\n        fmt.Println(\"Who are you?  You're not a terminal.\")\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 86,
    "input": "Translate Python to Go:\n\nimport sys\n\nif len(sys.argv)!=2:\n    print(\"Usage : python \" + sys.argv[0] + \" <filename>\")\n    exit()\n\ndataFile = open(sys.argv[1],\"r\")\n\nfileData = dataFile.read().split('\\n')\n\ndataFile.close()\n\n[print(i) for i in fileData[::-1]]\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"runtime\"\n)\n\nfunc main() {\n    fileName1 := \"rodgers.txt\"\n    fileName2 := \"rodgers_reversed.txt\"\n    lineBreak := \"\\n\"\n    if runtime.GOOS == \"windows\" {\n        lineBreak = \"\\r\\n\"\n    }\n    \n    b, err := ioutil.ReadFile(fileName1)\n    if err != nil {\n        log.Fatal(err)\n    }\n    lines := bytes.Split(b, []byte(lineBreak))\n    \n    if len(lines[len(lines)-1]) == 0 {\n        lines = lines[:len(lines)-1]\n    }\n\n    \n    for i, j := 0, len(lines)-1; i < j; i, j = i+1, j-1 {\n        lines[i], lines[j] = lines[j], lines[i]\n    }\n    b = bytes.Join(lines, []byte(lineBreak))\n    if err = ioutil.WriteFile(fileName2, b, 0o666); err != nil {\n        log.Fatal(err)\n    }\n    \n    b, err = ioutil.ReadFile(fileName2)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(string(b))\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 87,
    "input": "Translate C to PHP:>>>>>,----------[++++++++\n++[->+>+<<]>+>[-<<+>>]+++\n+++++[-<------>]>>+>,----\n------<<+[->>>>>+<<<<<]>>\n]>>>[<<<<[<<<[->>+<<[->+>\n[-]<<]]>[-<+>]>[-<<<.>>>>\n->>>>>[>>>>>]<-<<<<[<<<<<\n]+<]<<<<]>>>>>[>>>>>]<]\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\n\n$buffer = 1;\n$pids = [];\n\nfor ($i = 1; $i < $argc; $i++) {\n    $pid = pcntl_fork();\n    if ($pid < 0) {\n        die(\"failed to start child process\");\n    }\n\n    if ($pid === 0) {\n        sleep($argv[$i] + $buffer);\n        echo $argv[$i] . \"\\n\";\n        exit();\n    }\n    \n    $pids[] = $pid;\n}\n\nforeach ($pids as $pid) {\n    pcntl_waitpid($pid, $status);\n}\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 88,
    "input": "Translate C to Python:#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h> \n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <err.h>\n\nchar response[] = \"HTTP/1.1 200 OK\\r\\n\"\n\"Content-Type: text/html; charset=UTF-8\\r\\n\\r\\n\"\n\"<!DOCTYPE html><html><head><title>Bye-bye baby bye-bye</title>\"\n\"<style>body { background-color: #111 }\"\n\"h1 { font-size:4cm; text-align: center; color: black;\"\n\" text-shadow: 0 0 2mm red}</style></head>\"\n\"<body><h1>Goodbye, world!</h1></body></html>\\r\\n\";\n\nint main()\n{\n  int one = 1, client_fd;\n  struct sockaddr_in svr_addr, cli_addr;\n  socklen_t sin_len = sizeof(cli_addr);\n\n  int sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock < 0)\n    err(1, \"can't open socket\");\n\n  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(int));\n\n  int port = 8080;\n  svr_addr.sin_family = AF_INET;\n  svr_addr.sin_addr.s_addr = INADDR_ANY;\n  svr_addr.sin_port = htons(port);\n\n  if (bind(sock, (struct sockaddr *) &svr_addr, sizeof(svr_addr)) == -1) {\n    close(sock);\n    err(1, \"Can't bind\");\n  }\n\n  listen(sock, 5);\n  while (1) {\n    client_fd = accept(sock, (struct sockaddr *) &cli_addr, &sin_len);\n    printf(\"got connection\\n\");\n\n    if (client_fd == -1) {\n      perror(\"Can't accept\");\n      continue;\n    }\n\n    write(client_fd, response, sizeof(response) - 1); \n    close(client_fd);\n  }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from wsgiref.simple_server import make_server\n\ndef app(environ, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\n    yield b\"<h1>Goodbye, World!</h1>\"\n\nserver = make_server('127.0.0.1', 8080, app)\nserver.serve_forever()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 89,
    "input": "Translate C to C++:#include <unistd.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <err.h>\n\n\nint read_file_line(const char *path, int line_no)\n{\n\tstruct stat s;\n\tchar *buf;\n\toff_t start = -1, end = -1;\n\tsize_t i;\n\tint ln, fd, ret = 1;\n\n\tif (line_no == 1) start = 0;\n\telse if (line_no < 1){\n\t\twarn(\"line_no too small\");\n\t\treturn 0; \n\t}\n\n\tline_no--; \n\n\tfd = open(path, O_RDONLY);\n\tfstat(fd, &s);\n\n\t\n\tbuf = mmap(0, s.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n\t\n\tmadvise(buf, s.st_size, MADV_SEQUENTIAL);\n\n\tfor (i = ln = 0; i < s.st_size && ln <= line_no; i++) {\n\t\tif (buf[i] != '\\n') continue;\n\n\t\tif (++ln == line_no) start = i + 1;\n\t\telse if (ln == line_no + 1) end = i + 1;\n\t}\n\n\tif (start >= s.st_size || start < 0) {\n\t\twarn(\"file does not have line %d\", line_no + 1);\n\t\tret = 0;\n\t} else {\n\t\t\n\t}\n\n\tmunmap(buf, s.st_size);\n\tclose(fd);\n\n\treturn ret;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <string>\n#include <fstream>\n#include <iostream>\n\nint main( ) {\n   std::cout << \"Which file do you want to look at ?\\n\" ;\n   std::string input ;\n   std::getline( std::cin , input ) ;\n   std::ifstream infile( input.c_str( ) , std::ios::in ) ;\n   std::string file( input ) ;\n   std::cout << \"Which file line do you want to see ? ( Give a number > 0 ) ?\\n\" ;\n   std::getline( std::cin , input ) ;\n   int linenumber = std::stoi( input ) ;\n   int lines_read = 0 ;\n   std::string line ;\n   if ( infile.is_open( ) ) {\n      while ( infile ) {\n\t getline( infile , line ) ;\n\t lines_read++ ;\n\t if ( lines_read == linenumber ) {\n\t    std::cout << line << std::endl ;\n\t    break ; \n\t }\n      }\n      infile.close( ) ;\n      if ( lines_read < linenumber ) \n\t std::cout << \"No \" << linenumber << \" lines in \" << file << \" !\\n\" ;\n      return 0 ;\n   }\n   else {\n      std::cerr << \"Could not find file \" << file << \" !\\n\" ;\n      return 1 ;\n   }\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 90,
    "input": "Translate Java to Python:public class VariableDeclarationReset {\n    public static void main(String[] args) {\n        int[] s = {1, 2, 2, 3, 4, 4, 5};\n\n        \n        \n        for (int i = 0; i < s.length; ++i) {\n            int curr = s[i];\n            int prev = 0;\n\n            if (i > 0 && curr == prev) System.out.println(i);\n            prev = curr;\n        }\n\n        int gprev = 0;\n\n        \n        \n        for (int i = 0; i < s.length; ++i) {\n            int curr = s[i];\n            if (i > 0 && curr == gprev) System.out.println(i);\n            gprev = curr;\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "s = [1, 2, 2, 3, 4, 4, 5]\n \nfor i in range(len(s)):\n    curr = s[i]\n    if i > 0 and curr == prev:\n        print(i)\n    prev = curr\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 91,
    "input": "Translate Python to C#:>>> from enum import Enum\n>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')\n>>> Contact.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))\n>>> \n>>> \n>>> class Contact2(Enum):\n\tFIRST_NAME = 1\n\tLAST_NAME = 2\n\tPHONE = 3\n\n\t\n>>> Contact2.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))\n>>>\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "enum fruits { apple, banana, cherry }\n\nenum fruits { apple = 0, banana = 1, cherry = 2 }\n\nenum fruits : int { apple = 0, banana = 1, cherry = 2 }\n\n[FlagsAttribute]\nenum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 92,
    "input": "Translate Python to C#:from collections import defaultdict\n\ndef hashJoin(table1, index1, table2, index2):\n    h = defaultdict(list)\n    \n    for s in table1:\n        h[s[index1]].append(s)\n    \n    return [(s, r) for r in table2 for s in h[r[index2]]]\n\ntable1 = [(27, \"Jonah\"),\n          (18, \"Alan\"),\n          (28, \"Glory\"),\n          (18, \"Popeye\"),\n          (28, \"Alan\")]\ntable2 = [(\"Jonah\", \"Whales\"),\n          (\"Jonah\", \"Spiders\"),\n          (\"Alan\", \"Ghosts\"),\n          (\"Alan\", \"Zombies\"),\n          (\"Glory\", \"Buffy\")]\n\nfor row in hashJoin(table1, 1, table2, 0):\n    print(row)\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HashJoin\n{\n    public class AgeName\n    {\n        public AgeName(byte age, string name)\n        {\n            Age = age;\n            Name = name;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n    }\n\n    public class NameNemesis\n    {\n        public NameNemesis(string name, string nemesis)\n        {\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    public class DataContext\n    {\n        public DataContext()\n        {\n            AgeName = new List<AgeName>();\n            NameNemesis = new List<NameNemesis>();\n        }\n        public List<AgeName> AgeName { get; set; }\n        public List<NameNemesis> NameNemesis { get; set; }\n    }\n\n    public class AgeNameNemesis\n    {\n        public AgeNameNemesis(byte age, string name, string nemesis)\n        {\n            Age = age;\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    class Program\n    {\n        public static void Main()\n        {\n            var data = GetData();\n            var result = ExecuteHashJoin(data);\n            WriteResultToConsole(result);\n        }\n\n        private static void WriteResultToConsole(List<AgeNameNemesis> result)\n        {\n            result.ForEach(ageNameNemesis => Console.WriteLine(\"Age: {0}, Name: {1}, Nemesis: {2}\",\n                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));\n        }\n\n        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)\n        {\n            return (data.AgeName.Join(data.NameNemesis, \n                ageName => ageName.Name, nameNemesis => nameNemesis.Name,\n                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))\n                .ToList();\n        }\n\n        private static DataContext GetData()\n        {\n            var context = new DataContext();\n\n            context.AgeName.AddRange(new [] {\n                    new AgeName(27, \"Jonah\"), \n                    new AgeName(18, \"Alan\"), \n                    new AgeName(28, \"Glory\"), \n                    new AgeName(18, \"Popeye\"), \n                    new AgeName(28, \"Alan\")\n                });\n\n            context.NameNemesis.AddRange(new[]\n            {\n                new NameNemesis(\"Jonah\", \"Whales\"),\n                new NameNemesis(\"Jonah\", \"Spiders\"),\n                new NameNemesis(\"Alan\", \"Ghosts\"),\n                new NameNemesis(\"Alan\", \"Zombies\"),\n                new NameNemesis(\"Glory\", \"Buffy\")\n            });\n\n            return context;\n        }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 93,
    "input": "Translate Java to Go:import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class UPC {\n    private static final int SEVEN = 7;\n\n    private static final Map<String, Integer> LEFT_DIGITS = Map.of(\n        \"   ## #\", 0,\n        \"  ##  #\", 1,\n        \"  #  ##\", 2,\n        \" #### #\", 3,\n        \" #   ##\", 4,\n        \" ##   #\", 5,\n        \" # ####\", 6,\n        \" ### ##\", 7,\n        \" ## ###\", 8,\n        \"   # ##\", 9\n    );\n\n    private static final Map<String, Integer> RIGHT_DIGITS = LEFT_DIGITS.entrySet()\n        .stream()\n        .collect(Collectors.toMap(\n            entry -> entry.getKey()\n                .replace(' ', 's')\n                .replace('#', ' ')\n                .replace('s', '#'),\n            Map.Entry::getValue\n        ));\n\n    private static final String END_SENTINEL = \"# #\";\n    private static final String MID_SENTINEL = \" # # \";\n\n    private static void decodeUPC(String input) {\n        Function<String, Map.Entry<Boolean, List<Integer>>> decode = (String candidate) -> {\n            int pos = 0;\n            var part = candidate.substring(pos, pos + END_SENTINEL.length());\n\n            List<Integer> output = new ArrayList<>();\n            if (END_SENTINEL.equals(part)) {\n                pos += END_SENTINEL.length();\n            } else {\n                return Map.entry(false, output);\n            }\n\n            for (int i = 1; i < SEVEN; i++) {\n                part = candidate.substring(pos, pos + SEVEN);\n                pos += SEVEN;\n\n                if (LEFT_DIGITS.containsKey(part)) {\n                    output.add(LEFT_DIGITS.get(part));\n                } else {\n                    return Map.entry(false, output);\n                }\n            }\n\n            part = candidate.substring(pos, pos + MID_SENTINEL.length());\n            if (MID_SENTINEL.equals(part)) {\n                pos += MID_SENTINEL.length();\n            } else {\n                return Map.entry(false, output);\n            }\n\n            for (int i = 1; i < SEVEN; i++) {\n                part = candidate.substring(pos, pos + SEVEN);\n                pos += SEVEN;\n\n                if (RIGHT_DIGITS.containsKey(part)) {\n                    output.add(RIGHT_DIGITS.get(part));\n                } else {\n                    return Map.entry(false, output);\n                }\n            }\n\n            part = candidate.substring(pos, pos + END_SENTINEL.length());\n            if (!END_SENTINEL.equals(part)) {\n                return Map.entry(false, output);\n            }\n\n            int sum = 0;\n            for (int i = 0; i < output.size(); i++) {\n                if (i % 2 == 0) {\n                    sum += 3 * output.get(i);\n                } else {\n                    sum += output.get(i);\n                }\n            }\n            return Map.entry(sum % 10 == 0, output);\n        };\n\n        Consumer<List<Integer>> printList = list -> {\n            var it = list.iterator();\n            System.out.print('[');\n            if (it.hasNext()) {\n                System.out.print(it.next());\n            }\n            while (it.hasNext()) {\n                System.out.print(\", \");\n                System.out.print(it.next());\n            }\n            System.out.print(']');\n        };\n\n        var candidate = input.trim();\n        var out = decode.apply(candidate);\n        if (out.getKey()) {\n            printList.accept(out.getValue());\n            System.out.println();\n        } else {\n            StringBuilder builder = new StringBuilder(candidate);\n            builder.reverse();\n            out = decode.apply(builder.toString());\n            if (out.getKey()) {\n                printList.accept(out.getValue());\n                System.out.println(\" Upside down\");\n            } else if (out.getValue().size() == 12) {\n                System.out.println(\"Invalid checksum\");\n            } else {\n                System.out.println(\"Invalid digit(s)\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        var barcodes = List.of(\n            \"         # #   # ##  #  ## #   ## ### ## ### ## #### # # # ## ##  #   #  ##  ## ###  # ##  ## ### #  # #       \",\n            \"        # # #   ##   ## # #### #   # ## #   ## #   ## # # # ###  # ###  ##  ## ###  # #  ### ###  # # #         \",\n            \"         # #    # # #  ###  #   #    # #  #   #    # # # # ## #   ## #   ## #   ##   # # #### ### ## # #         \",\n            \"       # # ##  ## ##  ##   #  #   #  # ###  # ##  ## # # #   ## ##  #  ### ## ## #   # #### ## #   # #        \",\n            \"         # # ### ## #   ## ## ###  ##  # ##   #   # ## # # ### #  ## ##  #    # ### #  ## ##  #      # #          \",\n            \"          # #  #   # ##  ##  #   #   #  # ##  ##  #   # # # # #### #  ##  # #### #### # #  ##  # #### # #         \",\n            \"         # #  #  ##  ##  # #   ## ##   # ### ## ##   # # # #  #   #   #  #  ### # #    ###  # #  #   # #        \",\n            \"        # # #    # ##  ##   #  # ##  ##  ### #   #  # # # ### ## ## ### ## ### ### ## #  ##  ### ## # #         \",\n            \"         # # ### ##   ## # # #### #   ## # #### # #### # # #   #  # ###  #    # ###  # #    # ###  # # #       \",\n            \"        # # # #### ##   # #### # #   ## ## ### #### # # # #  ### # ###  ###  # # ###  #    # #  ### # #         \"\n        );\n        barcodes.forEach(UPC::decodeUPC);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nvar bits = []string{\n    \"0 0 0 1 1 0 1 \",\n    \"0 0 1 1 0 0 1 \",\n    \"0 0 1 0 0 1 1 \",\n    \"0 1 1 1 1 0 1 \",\n    \"0 1 0 0 0 1 1 \",\n    \"0 1 1 0 0 0 1 \",\n    \"0 1 0 1 1 1 1 \",\n    \"0 1 1 1 0 1 1 \",\n    \"0 1 1 0 1 1 1 \",\n    \"0 0 0 1 0 1 1 \",\n}\n\nvar (\n    lhs = make(map[string]int)\n    rhs = make(map[string]int)\n)\n\nvar weights = []int{3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1}\n\nconst (\n    s = \"# #\"\n    m = \" # # \"\n    e = \"# #\"\n    d = \"(?:#| ){7}\"\n)\n\nfunc init() {\n    for i := 0; i <= 9; i++ {\n        lt := make([]byte, 7)\n        rt := make([]byte, 7)\n        for j := 0; j < 14; j += 2 {\n            if bits[i][j] == '1' {\n                lt[j/2] = '#'\n                rt[j/2] = ' '\n            } else {\n                lt[j/2] = ' '\n                rt[j/2] = '#'\n            }\n        }\n        lhs[string(lt)] = i\n        rhs[string(rt)] = i\n    }\n}\n\nfunc reverse(s string) string {\n    b := []byte(s)\n    for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {\n        b[i], b[j] = b[j], b[i]\n    }\n    return string(b)\n}\n\nfunc main() {\n    barcodes := []string{\n        \"         # #   # ##  #  ## #   ## ### ## ### ## #### # # # ## ##  #   #  ##  ## ###  # ##  ## ### #  # #       \",\n        \"        # # #   ##   ## # #### #   # ## #   ## #   ## # # # ###  # ###  ##  ## ###  # #  ### ###  # # #         \",\n        \"         # #    # # #  ###  #   #    # #  #   #    # # # # ## #   ## #   ## #   ##   # # #### ### ## # #         \",\n        \"       # # ##  ## ##  ##   #  #   #  # ###  # ##  ## # # #   ## ##  #  ### ## ## #   # #### ## #   # #        \",\n        \"         # # ### ## #   ## ## ###  ##  # ##   #   # ## # # ### #  ## ##  #    # ### #  ## ##  #      # #          \",\n        \"          # #  #   # ##  ##  #   #   #  # ##  ##  #   # # # # #### #  ##  # #### #### # #  ##  # #### # #         \",\n        \"         # #  #  ##  ##  # #   ## ##   # ### ## ##   # # # #  #   #   #  #  ### # #    ###  # #  #   # #        \",\n        \"        # # #    # ##  ##   #  # ##  ##  ### #   #  # # # ### ## ## ### ## ### ### ## #  ##  ### ## # #         \",\n        \"         # # ### ##   ## # # #### #   ## # #### # #### # # #   #  # ###  #    # ###  # #    # ###  # # #       \",\n        \"        # # # #### ##   # #### # #   ## ## ### #### # # # #  ### # ###  ###  # # ###  #    # #  ### # #         \",\n    }\n\n    \n    \n    expr := fmt.Sprintf(`^\\s*%s(%s)(%s)(%s)(%s)(%s)(%s)%s(%s)(%s)(%s)(%s)(%s)(%s)%s\\s*$`,\n        s, d, d, d, d, d, d, m, d, d, d, d, d, d, e)\n    rx := regexp.MustCompile(expr)\n    fmt.Println(\"UPC-A barcodes:\")\n    for i, bc := range barcodes {\n        for j := 0; j <= 1; j++ {\n            if !rx.MatchString(bc) {\n                fmt.Printf(\"%2d: Invalid format\\n\", i+1)\n                break\n            }\n            codes := rx.FindStringSubmatch(bc)\n            digits := make([]int, 12)\n            var invalid, ok bool \n            for i := 1; i <= 6; i++ {\n                digits[i-1], ok = lhs[codes[i]]\n                if !ok {\n                    invalid = true\n                }\n                digits[i+5], ok = rhs[codes[i+6]]\n                if !ok {\n                    invalid = true\n                }\n            }\n            if invalid { \n                if j == 0 { \n                    bc = reverse(bc)\n                    continue\n                } else {\n                    fmt.Printf(\"%2d: Invalid digit(s)\\n\", i+1)\n                    break\n                }\n            }\n            sum := 0\n            for i, d := range digits {\n                sum += weights[i] * d\n            }\n            if sum%10 != 0 {\n                fmt.Printf(\"%2d: Checksum error\\n\", i+1)\n                break\n            } else {\n                ud := \"\"\n                if j == 1 {\n                    ud = \"(upside down)\"\n                }\n                fmt.Printf(\"%2d: %v %s\\n\", i+1, digits, ud)\n                break\n            }\n        }\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 94,
    "input": "Translate PHP to VB:<?php\n\n\n\nfunction _commonPath($dirList)\n{\n\t$arr = array();\n\tforeach($dirList as $i => $path)\n\t{\n\t\t$dirList[$i]\t= explode('/', $path);\n\t\tunset($dirList[$i][0]);\n\t\t\n\t\t$arr[$i] = count($dirList[$i]);\n\t}\n\t\n\t$min = min($arr);\n\t\n\tfor($i = 0; $i < count($dirList); $i++)\n\t{\n\t\twhile(count($dirList[$i]) > $min)\n\t\t{\n\t\t\tarray_pop($dirList[$i]);\n\t\t}\n\t\t\n\t\t$dirList[$i] = '/' . implode('/' , $dirList[$i]);\n\t}\n\t\n\t$dirList = array_unique($dirList);\n\twhile(count($dirList) !== 1)\n\t{\n\t\t$dirList = array_map('dirname', $dirList);\n\t\t$dirList = array_unique($dirList);\n\t}\n\treset($dirList);\n\t\n\treturn current($dirList);\n}\n\n \n\n$dirs = array(\n '/home/user1/tmp/coverage/test',\n '/home/user1/tmp/covert/operator',\n '/home/user1/tmp/coven/members',\n);\n\n\nif('/home/user1/tmp' !== common_path($dirs))\n{\n  echo 'test fail';\n} else {\n  echo 'test success';\n}\n\n?>\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Public Function CommonDirectoryPath(ParamArray Paths()) As String\nDim v As Variant\nDim Path() As String, s As String\nDim i As Long, j As Long, k As Long\nConst PATH_SEPARATOR As String = \"/\"\n  \n  For Each v In Paths\n    ReDim Preserve Path(0 To i)\n    Path(i) = v\n    i = i + 1\n  Next v\n  \n  k = 1\n  \n  Do\n    For i = 0 To UBound(Path)\n      If i Then\n        If InStr(k, Path(i), PATH_SEPARATOR) <> j Then\n          Exit Do\n        ElseIf Left$(Path(i), j) <> Left$(Path(0), j) Then\n          Exit Do\n        End If\n      Else\n        j = InStr(k, Path(i), PATH_SEPARATOR)\n        If j = 0 Then\n          Exit Do\n        End If\n      End If\n    Next i\n    s = Left$(Path(0), j + CLng(k <> 1))\n    k = j + 1\n  Loop\n  CommonDirectoryPath = s\n  \nEnd Function\n\nSub Main()\n\n\n\nDebug.Assert CommonDirectoryPath( _\n \"/home/user1/tmp/coverage/test\", _\n \"/home/user1/tmp/covert/operator\", _\n \"/home/user1/tmp/coven/members\") = _\n \"/home/user1/tmp\"\n \n Debug.Assert CommonDirectoryPath( _\n \"/home/user1/tmp/coverage/test\", _\n \"/home/user1/tmp/covert/operator\", _\n \"/home/user1/tmp/coven/members\", _\n \"/home/user1/abc/coven/members\") = _\n \"/home/user1\"\n\nDebug.Assert CommonDirectoryPath( _\n \"/home/user1/tmp/coverage/test\", _\n \"/hope/user1/tmp/covert/operator\", _\n \"/home/user1/tmp/coven/members\") = _\n \"/\"\n\nEnd Sub\n",
    "input_language": "PHP",
    "output_language": "VB"
  },
  {
    "id": 95,
    "input": "Translate C to Python:#define _XOPEN_SOURCE\n#include <stdio.h>\n#include <time.h>\n\nint main() {\n    struct tm t[2];\n    strptime(\"2021-12-25\", \"%F\", &t[0]);\n    strptime(\"2022-01-01\", \"%F\", &t[1]);\n    for (int i=0; i<2; i++) {\n        char buf[32];\n        strftime(buf, 32, \"%F is a %A\", &t[i]);\n        puts(buf);\n    }\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import datetime\n\nweekDays = (\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\nthisXMas  = datetime.date(2021,12,25)\nthisXMasDay = thisXMas.weekday()\nthisXMasDayAsString = weekDays[thisXMasDay]\nprint(\"This year's Christmas is on a {}\".format(thisXMasDayAsString))\n\nnextNewYear = datetime.date(2022,1,1)\nnextNewYearDay = nextNewYear.weekday()\nnextNewYearDayAsString = weekDays[nextNewYearDay]\nprint(\"Next new year is on a {}\".format(nextNewYearDayAsString))\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 96,
    "input": "Translate C++ to C#:#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n\n#include <limits> \n\n#include <set>\n#include <utility> \n#include <algorithm>\n#include <iterator>\n\n\ntypedef int vertex_t;\ntypedef double weight_t;\n\nconst weight_t max_weight = std::numeric_limits<double>::infinity();\n\nstruct neighbor {\n    vertex_t target;\n    weight_t weight;\n    neighbor(vertex_t arg_target, weight_t arg_weight)\n        : target(arg_target), weight(arg_weight) { }\n};\n\ntypedef std::vector<std::vector<neighbor> > adjacency_list_t;\n\n\nvoid DijkstraComputePaths(vertex_t source,\n                          const adjacency_list_t &adjacency_list,\n                          std::vector<weight_t> &min_distance,\n                          std::vector<vertex_t> &previous)\n{\n    int n = adjacency_list.size();\n    min_distance.clear();\n    min_distance.resize(n, max_weight);\n    min_distance[source] = 0;\n    previous.clear();\n    previous.resize(n, -1);\n    std::set<std::pair<weight_t, vertex_t> > vertex_queue;\n    vertex_queue.insert(std::make_pair(min_distance[source], source));\n\n    while (!vertex_queue.empty()) \n    {\n        weight_t dist = vertex_queue.begin()->first;\n        vertex_t u = vertex_queue.begin()->second;\n        vertex_queue.erase(vertex_queue.begin());\n\n        \n\tconst std::vector<neighbor> &neighbors = adjacency_list[u];\n        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();\n             neighbor_iter != neighbors.end();\n             neighbor_iter++)\n        {\n            vertex_t v = neighbor_iter->target;\n            weight_t weight = neighbor_iter->weight;\n            weight_t distance_through_u = dist + weight;\n\t    if (distance_through_u < min_distance[v]) {\n\t        vertex_queue.erase(std::make_pair(min_distance[v], v));\n\n\t        min_distance[v] = distance_through_u;\n\t        previous[v] = u;\n\t        vertex_queue.insert(std::make_pair(min_distance[v], v));\n\n\t    }\n\n        }\n    }\n}\n\n\nstd::list<vertex_t> DijkstraGetShortestPathTo(\n    vertex_t vertex, const std::vector<vertex_t> &previous)\n{\n    std::list<vertex_t> path;\n    for ( ; vertex != -1; vertex = previous[vertex])\n        path.push_front(vertex);\n    return path;\n}\n\n\nint main()\n{\n    \n    adjacency_list_t adjacency_list(6);\n    \n    adjacency_list[0].push_back(neighbor(1, 7));\n    adjacency_list[0].push_back(neighbor(2, 9));\n    adjacency_list[0].push_back(neighbor(5, 14));\n    \n    adjacency_list[1].push_back(neighbor(0, 7));\n    adjacency_list[1].push_back(neighbor(2, 10));\n    adjacency_list[1].push_back(neighbor(3, 15));\n    \n    adjacency_list[2].push_back(neighbor(0, 9));\n    adjacency_list[2].push_back(neighbor(1, 10));\n    adjacency_list[2].push_back(neighbor(3, 11));\n    adjacency_list[2].push_back(neighbor(5, 2));\n    \n    adjacency_list[3].push_back(neighbor(1, 15));\n    adjacency_list[3].push_back(neighbor(2, 11));\n    adjacency_list[3].push_back(neighbor(4, 6));\n    \n    adjacency_list[4].push_back(neighbor(3, 6));\n    adjacency_list[4].push_back(neighbor(5, 9));\n    \n    adjacency_list[5].push_back(neighbor(0, 14));\n    adjacency_list[5].push_back(neighbor(2, 2));\n    adjacency_list[5].push_back(neighbor(4, 9));\n\n    std::vector<weight_t> min_distance;\n    std::vector<vertex_t> previous;\n    DijkstraComputePaths(0, adjacency_list, min_distance, previous);\n    std::cout << \"Distance from 0 to 4: \" << min_distance[4] << std::endl;\n    std::list<vertex_t> path = DijkstraGetShortestPathTo(4, previous);\n    std::cout << \"Path : \";\n    std::copy(path.begin(), path.end(), std::ostream_iterator<vertex_t>(std::cout, \" \"));\n    std::cout << std::endl;\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using static System.Linq.Enumerable;\nusing static System.String;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System;\nusing EdgeList = System.Collections.Generic.List<(int node, double weight)>;\n\npublic static class Dijkstra\n{\n    public static void Main() {\n        Graph graph = new Graph(6);\n        Func<char, int> id = c => c - 'a';\n        Func<int , char> name = i => (char)(i + 'a');\n        foreach (var (start, end, cost) in new [] {\n            ('a', 'b', 7),\n            ('a', 'c', 9),\n            ('a', 'f', 14),\n            ('b', 'c', 10),\n            ('b', 'd', 15),\n            ('c', 'd', 11),\n            ('c', 'f', 2),\n            ('d', 'e', 6),\n            ('e', 'f', 9),\n        }) {\n            graph.AddEdge(id(start), id(end), cost);\n        }\n\n        var path = graph.FindPath(id('a'));\n        for (int d = id('b'); d <= id('f'); d++) {\n            WriteLine(Join(\" -> \", Path(id('a'), d).Select(p => $\"{name(p.node)}({p.distance})\").Reverse()));\n        }\n        \n        IEnumerable<(double distance, int node)> Path(int start, int destination) {\n            yield return (path[destination].distance, destination);\n            for (int i = destination; i != start; i = path[i].prev) {\n                yield return (path[path[i].prev].distance, path[i].prev);\n            }\n        }\n    }\n\n}\n\nsealed class Graph\n{\n    private readonly List<EdgeList> adjacency;\n\n    public Graph(int vertexCount) => adjacency = Range(0, vertexCount).Select(v => new EdgeList()).ToList();\n\n    public int Count => adjacency.Count;\n    public bool HasEdge(int s, int e) => adjacency[s].Any(p => p.node == e);\n    public bool RemoveEdge(int s, int e) => adjacency[s].RemoveAll(p => p.node == e) > 0;\n\n    public bool AddEdge(int s, int e, double weight) {\n        if (HasEdge(s, e)) return false;\n        adjacency[s].Add((e, weight));\n        return true;\n    }\n\n    public (double distance, int prev)[] FindPath(int start) {\n        var info = Range(0, adjacency.Count).Select(i => (distance: double.PositiveInfinity, prev: i)).ToArray();\n        info[start].distance = 0;\n        var visited = new System.Collections.BitArray(adjacency.Count);\n\n        var heap = new Heap<(int node, double distance)>((a, b) => a.distance.CompareTo(b.distance));\n        heap.Push((start, 0));\n        while (heap.Count > 0) {\n            var current = heap.Pop();\n            if (visited[current.node]) continue;\n            var edges = adjacency[current.node];\n            for (int n = 0; n < edges.Count; n++) {\n                int v = edges[n].node;\n                if (visited[v]) continue;\n                double alt = info[current.node].distance + edges[n].weight;\n                if (alt < info[v].distance) {\n                    info[v] = (alt, current.node);\n                    heap.Push((v, alt));\n                }\n            }\n            visited[current.node] = true;\n        }\n        return info;\n    }\n\n}\n\nsealed class Heap<T>\n{\n    private readonly IComparer<T> comparer;\n    private readonly List<T> list = new List<T> { default };\n\n    public Heap() : this(default(IComparer<T>)) { }\n\n    public Heap(IComparer<T> comparer) {\n        this.comparer = comparer ?? Comparer<T>.Default;\n    }\n\n    public Heap(Comparison<T> comparison) : this(Comparer<T>.Create(comparison)) { }\n\n    public int Count => list.Count - 1;\n\n    public void Push(T element) {\n        list.Add(element);\n        SiftUp(list.Count - 1);\n    }\n\n    public T Pop() {\n        T result = list[1];\n        list[1] = list[list.Count - 1];\n        list.RemoveAt(list.Count - 1);\n        SiftDown(1);\n        return result;\n    }\n\n    private static int Parent(int i) => i / 2;\n    private static int Left(int i) => i * 2;\n    private static int Right(int i) => i * 2 + 1;\n\n    private void SiftUp(int i) {\n        while (i > 1) {\n            int parent = Parent(i);\n            if (comparer.Compare(list[i], list[parent]) > 0) return;\n            (list[parent], list[i]) = (list[i], list[parent]);\n            i = parent;\n        }\n    }\n\n    private void SiftDown(int i) {\n        for (int left = Left(i); left < list.Count; left = Left(i)) {\n            int smallest = comparer.Compare(list[left], list[i]) <= 0 ? left : i;\n            int right = Right(i);\n            if (right < list.Count && comparer.Compare(list[right], list[smallest]) <= 0) smallest = right;\n            if (smallest == i) return;\n            (list[i], list[smallest]) = (list[smallest], list[i]);\n            i = smallest;\n        }\n    }\n\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 97,
    "input": "Translate C to Go:enum fruits { apple, banana, cherry };\n\nenum fruits { apple = 0, banana = 1, cherry = 2 };\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "const (\n\tapple = iota\n\tbanana\n\tcherry\n)\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 98,
    "input": "Translate Python to VB:import math\nimport random\n\ndef GammaInc_Q( a, x):\n    a1 = a-1\n    a2 = a-2\n    def f0( t ):\n        return t**a1*math.exp(-t)\n\n    def df0(t):\n        return (a1-t)*t**a2*math.exp(-t)\n    \n    y = a1\n    while f0(y)*(x-y) >2.0e-8 and y < x: y += .3\n    if y > x: y = x\n\n    h = 3.0e-4\n    n = int(y/h)\n    h = y/n\n    hh = 0.5*h\n    gamax = h * sum( f0(t)+hh*df0(t) for t in ( h*j for j in xrange(n-1, -1, -1)))\n\n    return gamax/gamma_spounge(a)\n\nc = None\ndef gamma_spounge( z):\n    global c\n    a = 12\n\n    if c is None:\n       k1_factrl = 1.0\n       c = []\n       c.append(math.sqrt(2.0*math.pi))\n       for k in range(1,a):\n          c.append( math.exp(a-k) * (a-k)**(k-0.5) / k1_factrl )\n          k1_factrl *= -k\n    \n    accm = c[0]\n    for k in range(1,a):\n        accm += c[k] / (z+k)\n    accm *= math.exp( -(z+a)) * (z+a)**(z+0.5)\n    return accm/z;\n\ndef chi2UniformDistance( dataSet ):\n    expected = sum(dataSet)*1.0/len(dataSet)\n    cntrd = (d-expected for d in dataSet)\n    return sum(x*x for x in cntrd)/expected\n\ndef chi2Probability(dof, distance):\n    return 1.0 - GammaInc_Q( 0.5*dof, 0.5*distance)\n\ndef chi2IsUniform(dataSet, significance):\n    dof = len(dataSet)-1\n    dist = chi2UniformDistance(dataSet)\n    return chi2Probability( dof, dist ) > significance\n\ndset1 = [ 199809, 200665, 199607, 200270, 199649 ]\ndset2 = [ 522573, 244456, 139979,  71531,  21461 ]\n\nfor ds in (dset1, dset2):\n    print \"Data set:\", ds\n    dof = len(ds)-1\n    distance =chi2UniformDistance(ds)\n    print \"dof: %d distance: %.4f\" % (dof, distance),\n    prob = chi2Probability( dof, distance)\n    print \"probability: %.4f\"%prob,\n    print \"uniform? \", \"Yes\"if chi2IsUniform(ds,0.05) else \"No\"\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Private Function Test4DiscreteUniformDistribution(ObservationFrequencies() As Variant, Significance As Single) As Boolean\n    \n    Dim Total As Long, Ei As Long, i As Integer\n    Dim ChiSquared As Double, DegreesOfFreedom As Integer, p_value As Double\n    Debug.Print \"[1] \"\"Data set:\"\" \";\n    For i = LBound(ObservationFrequencies) To UBound(ObservationFrequencies)\n        Total = Total + ObservationFrequencies(i)\n        Debug.Print ObservationFrequencies(i); \" \";\n    Next i\n    DegreesOfFreedom = UBound(ObservationFrequencies) - LBound(ObservationFrequencies)\n    \n    Ei = Total / (DegreesOfFreedom + 1)\n    For i = LBound(ObservationFrequencies) To UBound(ObservationFrequencies)\n        ChiSquared = ChiSquared + (ObservationFrequencies(i) - Ei) ^ 2 / Ei\n    Next i\n    p_value = 1 - WorksheetFunction.ChiSq_Dist(ChiSquared, DegreesOfFreedom, True)\n    Debug.Print\n    Debug.Print \"   Chi-squared test for given frequencies\"\n    Debug.Print \"X-squared =\"; ChiSquared; \", \";\n    Debug.Print \"df =\"; DegreesOfFreedom; \", \";\n    Debug.Print \"p-value = \"; Format(p_value, \"0.0000\")\n    Test4DiscreteUniformDistribution = p_value > Significance\nEnd Function\nPublic Sub test()\n    Dim O() As Variant\n    O = [{199809,200665,199607,200270,199649}]\n    Debug.Print \"[1] \"\"Uniform? \"; Test4DiscreteUniformDistribution(O, 0.05); \"\"\"\"\n    O = [{522573,244456,139979,71531,21461}]\n    Debug.Print \"[1] \"\"Uniform? \"; Test4DiscreteUniformDistribution(O, 0.05); \"\"\"\"\nEnd Sub\n",
    "input_language": "Python",
    "output_language": "VB"
  },
  {
    "id": 99,
    "input": "Translate C++ to Python:#include <iostream>\n#include <fstream>\n\nint main(){\n  std::ofstream lprFile;\n  lprFile.open( \"/dev/lp0\" );\n  lprFile << \"Hello World!\\n\";\n  lprFile.close();\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 100,
    "input": "Translate PHP to Python:$str = \"alphaBETA\";\necho strtoupper($str), \"\\n\"; // ALPHABETA\necho strtolower($str), \"\\n\"; // alphabeta\n\necho ucfirst($str), \"\\n\"; // AlphaBETA\necho lcfirst(\"FOObar\"), \"\\n\"; // fOObar\necho ucwords(\"foO baR baZ\"), \"\\n\"; // FoO BaR BaZ\necho lcwords(\"FOo BAr BAz\"), \"\\n\"; // fOo bAr bAz\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 101,
    "input": "Translate C# to VB:if (condition)\n{\n   \n}\n\nif (condition)\n{\n  \n}\nelse if (condition2)\n{\n  \n}\nelse\n{\n  \n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Sub C_S_If()\nDim A$, B$\n\n    A = \"Hello\"\n    B = \"World\"\n    \n    If A = B Then Debug.Print A & \" = \" & B\n    \n    If A = B Then\n        Debug.Print A & \" = \" & B\n    Else\n        Debug.Print A & \" and \" & B & \" are differents.\"\n    End If\n    \n    If A = B Then\n        Debug.Print A & \" = \" & B\n    Else: Debug.Print A & \" and \" & B & \" are differents.\"\n    End If\n    \n    If A = B Then Debug.Print A & \" = \" & B _\n    Else Debug.Print A & \" and \" & B & \" are differents.\"    \n    \n    If A = B Then Debug.Print A & \" = \" & B Else Debug.Print A & \" and \" & B & \" are differents.\"\n    If A = B Then Debug.Print A & \" = \" & B Else: Debug.Print A & \" and \" & B & \" are differents.\"\nEnd Sub\n",
    "input_language": "C#",
    "output_language": "VB"
  },
  {
    "id": 102,
    "input": "Translate C to C#:#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\nbool isPrime(int64_t n) {\n    int64_t i;\n\n    if (n < 2)       return false;\n    if (n % 2 == 0)  return n == 2;\n    if (n % 3 == 0)  return n == 3;\n    if (n % 5 == 0)  return n == 5;\n    if (n % 7 == 0)  return n == 7;\n    if (n % 11 == 0) return n == 11;\n    if (n % 13 == 0) return n == 13;\n    if (n % 17 == 0) return n == 17;\n    if (n % 19 == 0) return n == 19;\n\n    for (i = 23; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint countTwinPrimes(int limit) {\n    int count = 0;\n\n    \n    int64_t p3 = true, p2 = true, p1 = false;\n    int64_t i;\n\n    for (i = 5; i <= limit; i++) {\n        p3 = p2;\n        p2 = p1;\n        p1 = isPrime(i);\n        if (p3 && p1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test(int limit) {\n    int count = countTwinPrimes(limit);\n    printf(\"Number of twin prime pairs less than %d is %d\\n\", limit, count);\n}\n\nint main() {\n    test(10);\n    test(100);\n    test(1000);\n    test(10000);\n    test(100000);\n    test(1000000);\n    test(10000000);\n    test(100000000);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\n\nclass Program {\n\n    static uint[] res = new uint[10];\n    static uint ri = 1, p = 10, count = 0;\n\n    static void TabulateTwinPrimes(uint bound) {\n        if (bound < 5) return; count++;\n        uint cl = (bound - 1) >> 1, i = 1, j,\n             limit = (uint)(Math.Sqrt(bound) - 1) >> 1;\n        var comp = new bool[cl]; bool lp;\n        for (j = 3; j < cl; j += 3) comp[j] = true;\n        while (i < limit) {\n            if (lp = !comp[i]) {\n                uint pr = (i << 1) + 3;\n                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)\n                    comp[j] = true;\n            }\n            if (!comp[++i]) {\n                uint pr = (i << 1) + 3;\n                if (lp) {\n                    if (pr > p) {\n                        res[ri++] = count;\n                        p *= 10;\n                    }\n                    count++;\n                    i++;\n                }\n                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)\n                    comp[j] = true; \n            }\n        }\n        cl--;\n        while (i < cl) {\n            lp = !comp[i++];\n            if (!comp[i] && lp) {\n                if ((i++ << 1) + 3 > p) {\n                    res[ri++] = count;\n                    p *= 10;\n                }\n                count++;\n            }\n        }\n        res[ri] = count;\n    }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        string fmt = \"{0,9:n0} twin primes below {1,-13:n0}\";\n        TabulateTwinPrimes(1_000_000_000);\n        sw.Stop();\n        p = 1;\n        for (var j = 1; j <= ri; j++)\n            Console.WriteLine(fmt, res[j], p *= 10);\n        Console.Write(\"{0} sec\", sw.Elapsed.TotalSeconds);\n    }\n}\n",
    "input_language": "C",
    "output_language": "C#"
  },
  {
    "id": 103,
    "input": "Translate C++ to PHP:#include <cstdio>\n#include <direct.h>\n\nint main() {\n\tremove( \"input.txt\" );\n\tremove( \"/input.txt\" );\n\t_rmdir( \"docs\" );\n\t_rmdir( \"/docs\" );\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\nunlink('input.txt');\nunlink('/input.txt');\nrmdir('docs');\nrmdir('/docs');\n?>\n",
    "input_language": "C++",
    "output_language": "PHP"
  },
  {
    "id": 104,
    "input": "Translate C to Go:#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint day(int y, int m, int d) {\n    return 367 * y - 7 * (y + (m + 9) / 12) / 4 + 275 * m / 9 + d - 730530;\n}\n\nvoid cycle(int diff, int l, char *t) {\n    int p = round(100 * sin(2 * M_PI * diff / l));\n    printf(\"%12s cycle: %3i%%\", t, p);\n    if (abs(p) < 15)\n        printf(\" (critical day)\");\n    printf(\"\\n\");\n}\n\nint main(int argc, char *argv[]) {\n    int diff;\n\n    if (argc < 7) {\n        printf(\"Usage:\\n\");\n        printf(\"cbio y1 m1 d1 y2 m2 d2\\n\");\n        exit(1);\n    }\n    diff = abs(day(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]))\n             - day(atoi(argv[4]), atoi(argv[5]), atoi(argv[6])));\n    printf(\"Age: %u days\\n\", diff);\n    cycle(diff, 23, \"Physical\");\n    cycle(diff, 28, \"Emotional\");\n    cycle(diff, 33, \"Intellectual\");\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"math\"\n    \"time\"\n)\n\nconst layout = \"2006-01-02\" \n\nvar cycles = [3]string{\"Physical day \", \"Emotional day\", \"Mental day   \"}\nvar lengths = [3]int{23, 28, 33}\nvar quadrants = [4][2]string{\n    {\"up and rising\", \"peak\"},\n    {\"up but falling\", \"transition\"},\n    {\"down and falling\", \"valley\"},\n    {\"down but rising\", \"transition\"},\n}\n\nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\n\nfunc biorhythms(birthDate, targetDate string) {\n    bd, err := time.Parse(layout, birthDate)\n    check(err)\n    td, err := time.Parse(layout, targetDate)\n    check(err)\n    days := int(td.Sub(bd).Hours() / 24)\n    fmt.Printf(\"Born %s, Target %s\\n\", birthDate, targetDate)\n    fmt.Println(\"Day\", days)\n    for i := 0; i < 3; i++ {\n        length := lengths[i]\n        cycle := cycles[i]\n        position := days % length\n        quadrant := position * 4 / length\n        percent := math.Sin(2 * math.Pi * float64(position) / float64(length))\n        percent = math.Floor(percent*1000) / 10\n        descript := \"\"\n        if percent > 95 {\n            descript = \" peak\"\n        } else if percent < -95 {\n            descript = \" valley\"\n        } else if math.Abs(percent) < 5 {\n            descript = \" critical transition\"\n        } else {\n            daysToAdd := (quadrant+1)*length/4 - position\n            transition := td.Add(time.Hour * 24 * time.Duration(daysToAdd))\n            trend := quadrants[quadrant][0]\n            next := quadrants[quadrant][1]\n            transStr := transition.Format(layout)\n            descript = fmt.Sprintf(\"%5.1f%% (%s, next %s %s)\", percent, trend, next, transStr)\n        }\n        fmt.Printf(\"%s %2d : %s\\n\", cycle, position, descript)\n    }\n    fmt.Println()\n}\n\nfunc main() {\n    datePairs := [][2]string{\n        {\"1943-03-09\", \"1972-07-11\"},\n        {\"1809-01-12\", \"1863-11-19\"},\n        {\"1809-02-12\", \"1863-11-19\"}, \n    }\n    for _, datePair := range datePairs {\n        biorhythms(datePair[0], datePair[1])\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 105,
    "input": "Translate C to Java:#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\ninline int rand5()\n{\n\tint r, rand_max = RAND_MAX - (RAND_MAX % 5);\n\twhile ((r = rand()) >= rand_max);\n\treturn r / (rand_max / 5) + 1;\n}\n\ninline int rand5_7()\n{\n\tint r;\n\twhile ((r = rand5() * 5 + rand5()) >= 27);\n\treturn r / 3 - 1;\n}\n\n\nint check(int (*gen)(), int n, int cnt, double delta) \n{\n\tint i = cnt, *bins = calloc(sizeof(int), n);\n\tdouble ratio;\n\twhile (i--) bins[gen() - 1]++;\n\tfor (i = 0; i < n; i++) {\n\t\tratio = bins[i] * n / (double)cnt - 1;\n\t\tif (ratio > -delta && ratio < delta) continue;\n\n\t\tprintf(\"bin %d out of range: %d (%g%% vs %g%%), \",\n\t\t\ti + 1, bins[i], ratio * 100, delta * 100);\n\t\tbreak;\n\t}\n\tfree(bins);\n\treturn i == n;\n}\n\nint main()\n{\n\tint cnt = 1;\n\twhile ((cnt *= 10) <= 1000000) {\n\t\tprintf(\"Count = %d: \", cnt);\n\t\tprintf(check(rand5_7, 7, cnt, 0.03) ? \"flat\\n\" : \"NOT flat\\n\");\n\t}\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import static java.lang.Math.abs;\nimport java.util.*;\nimport java.util.function.IntSupplier;\n\npublic class Test {\n\n    static void distCheck(IntSupplier f, int nRepeats, double delta) {\n        Map<Integer, Integer> counts = new HashMap<>();\n\n        for (int i = 0; i < nRepeats; i++)\n            counts.compute(f.getAsInt(), (k, v) -> v == null ? 1 : v + 1);\n\n        double target = nRepeats / (double) counts.size();\n        int deltaCount = (int) (delta / 100.0 * target);\n\n        counts.forEach((k, v) -> {\n            if (abs(target - v) >= deltaCount)\n                System.out.printf(\"distribution potentially skewed \"\n                        + \"for '%s': '%d'%n\", k, v);\n        });\n\n        counts.keySet().stream().sorted().forEach(k\n                -> System.out.printf(\"%d %d%n\", k, counts.get(k)));\n    }\n\n    public static void main(String[] a) {\n        distCheck(() -> (int) (Math.random() * 5) + 1, 1_000_000, 1);\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 106,
    "input": "Translate C# to Go:using System;\nusing BI = System.Numerics.BigInteger;\nusing static System.Console;\n\nclass Program {\n\n  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\n  static string dump(int digs, bool show = false) {\n    int gb = 1, dg = ++digs + gb, z;\n    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,\n       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;\n    for (BI n = 0; n < dg; n++) {\n      if (n > 0) t3 *= BI.Pow(n, 6);\n      te = t1 * t2 / t3;\n      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);\n      else te /= BI.Pow (10, -z);\n      if (show && n < 10)\n        WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t);\n      su += te; if (te < 10) {\n        if (show) WriteLine(\"\\n{0} iterations required for {1} digits \" +\n        \"after the decimal point.\\n\", n, --digs); break; }\n      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;\n      t2 += 126 + 532 * (d += 2);\n    }\n    string s = string.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) /\n      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));\n    return s[0] + \".\" + s.Substring(1, digs); }\n\n  static void Main(string[] args) {\n    WriteLine(dump(70, true)); }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"strings\"\n)\n\nfunc factorial(n int64) *big.Int {\n    var z big.Int\n    return z.MulRange(1, n)\n}\n\nvar one = big.NewInt(1)\nvar three = big.NewInt(3)\nvar six = big.NewInt(6)\nvar ten = big.NewInt(10)\nvar seventy = big.NewInt(70)\n\nfunc almkvistGiullera(n int64, print bool) *big.Rat {\n    t1 := big.NewInt(32)\n    t1.Mul(factorial(6*n), t1)\n    t2 := big.NewInt(532*n*n + 126*n + 9)\n    t3 := new(big.Int)\n    t3.Exp(factorial(n), six, nil)\n    t3.Mul(t3, three)\n    ip := new(big.Int)\n    ip.Mul(t1, t2)\n    ip.Quo(ip, t3)\n    pw := 6*n + 3\n    t1.SetInt64(pw)\n    tm := new(big.Rat).SetFrac(ip, t1.Exp(ten, t1, nil))\n    if print {\n        fmt.Printf(\"%d  %44d  %3d  %-35s\\n\", n, ip, -pw, tm.FloatString(33))\n    }\n    return tm\n}\n\nfunc main() {\n    fmt.Println(\"N                               Integer Portion  Pow  Nth Term (33 dp)\")\n    fmt.Println(strings.Repeat(\"-\", 89))\n    for n := int64(0); n < 10; n++ {\n        almkvistGiullera(n, true)\n    }\n\n    sum := new(big.Rat)\n    prev := new(big.Rat)\n    pow70 := new(big.Int).Exp(ten, seventy, nil)\n    prec := new(big.Rat).SetFrac(one, pow70)\n    n := int64(0)\n    for {\n        term := almkvistGiullera(n, false)\n        sum.Add(sum, term)\n        z := new(big.Rat).Sub(sum, prev)\n        z.Abs(z)\n        if z.Cmp(prec) < 0 {\n            break\n        }\n        prev.Set(sum)\n        n++\n    }\n    sum.Inv(sum)\n    pi := new(big.Float).SetPrec(256).SetRat(sum)\n    pi.Sqrt(pi)\n    fmt.Println(\"\\nPi to 70 decimal places is:\")\n    fmt.Println(pi.Text('f', 70))\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 107,
    "input": "Translate C to Python:\n\n#include<graphics.h>\n#include<math.h>\n\n#define pi M_PI\n\nvoid sunflower(int winWidth, int winHeight, double diskRatio, int iter){\n\tdouble factor = .5 + sqrt(1.25),r,theta;\n\tdouble x = winWidth/2.0, y = winHeight/2.0;\n\tdouble maxRad = pow(iter,factor)/iter;\n\t\n\tint i;\n\t\n\tsetbkcolor(LIGHTBLUE);\n\t\n\tfor(i=0;i<=iter;i++){\n\t\tr = pow(i,factor)/iter;\n\t\t\n\t\tr/maxRad < diskRatio?setcolor(BLACK):setcolor(YELLOW);\n\t\t\n\t\ttheta = 2*pi*factor*i;\n\t\tcircle(x + r*sin(theta), y + r*cos(theta), 10 * i/(1.0*iter));\n\t}\n}\n\nint main()\n{\n\tinitwindow(1000,1000,\"Sunflower...\");\n\t\n\tsunflower(1000,1000,0.5,3000);\n\t\n\tgetch();\n\t\n\tclosegraph();\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from turtle import *\nfrom math import *\n\n\n\niter = 3000\ndiskRatio = .5\n\nfactor = .5 + sqrt(1.25)\n\nscreen = getscreen()\n\n(winWidth, winHeight) = screen.screensize()\n\n\n\n\n\nx = 0.0\ny = 0.0\n\nmaxRad = pow(iter,factor)/iter;\n\nbgcolor(\"light blue\")\n\nhideturtle()\n\ntracer(0, 0)\n\nfor i in range(iter+1):\n    r = pow(i,factor)/iter;\n    \n    if r/maxRad < diskRatio:\n        pencolor(\"black\")\n    else:\n        pencolor(\"yellow\")\n \n    theta = 2*pi*factor*i;\n        \n    up()\n    \n    setposition(x + r*sin(theta), y + r*cos(theta))\n    \n    down()\n       \n    circle(10.0 * i/(1.0*iter))\n    \nupdate()\n\ndone()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 108,
    "input": "Translate C++ to Go:#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n\nint main() {\n    std::ofstream out(\"penrose_tiling.svg\");\n    if (!out) {\n        std::cerr << \"Cannot open output file.\\n\";\n        return EXIT_FAILURE;\n    }\n    std::string penrose(\"[N]++[N]++[N]++[N]++[N]\");\n    for (int i = 1; i <= 4; ++i) {\n        std::string next;\n        for (char ch : penrose) {\n            switch (ch) {\n            case 'A':\n                break;\n            case 'M':\n                next += \"OA++PA----NA[-OA----MA]++\";\n                break;\n            case 'N':\n                next += \"+OA--PA[---MA--NA]+\";\n                break;\n            case 'O':\n                next += \"-MA++NA[+++OA++PA]-\";\n                break;\n            case 'P':\n                next += \"--OA++++MA[+PA++++NA]--NA\";\n                break;\n            default:\n                next += ch;\n                break;\n            }\n        }\n        penrose = std::move(next);\n    }\n    const double r = 30;\n    const double pi5 = 0.628318530717959;\n    double x = r * 8, y = r * 8, theta = pi5;\n    std::set<std::string> svg;\n    std::stack<std::tuple<double, double, double>> stack;\n    for (char ch : penrose) {\n        switch (ch) {\n        case 'A': {\n            double nx = x + r * std::cos(theta);\n            double ny = y + r * std::sin(theta);\n            std::ostringstream line;\n            line << std::fixed << std::setprecision(3) << \"<line x1='\" << x\n                 << \"' y1='\" << y << \"' x2='\" << nx << \"' y2='\" << ny << \"'/>\";\n            svg.insert(line.str());\n            x = nx;\n            y = ny;\n        } break;\n        case '+':\n            theta += pi5;\n            break;\n        case '-':\n            theta -= pi5;\n            break;\n        case '[':\n            stack.push({x, y, theta});\n            break;\n        case ']':\n            std::tie(x, y, theta) = stack.top();\n            stack.pop();\n            break;\n        }\n    }\n    out << \"<svg xmlns='http:\n        << \"' width='\" << r * 16 << \"'>\\n\"\n        << \"<rect height='100%' width='100%' fill='black'/>\\n\"\n        << \"<g stroke='rgb(255,165,0)'>\\n\";\n    for (const auto& line : svg)\n        out << line << '\\n';\n    out << \"</g>\\n</svg>\\n\";\n    return EXIT_SUCCESS;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"github.com/fogleman/gg\"\n    \"math\"\n)\n\ntype tiletype int\n\nconst (\n    kite tiletype = iota\n    dart\n)\n\ntype tile struct {\n    tt          tiletype\n    x, y        float64\n    angle, size float64\n}\n\nvar gr = (1 + math.Sqrt(5)) / 2 \n\nconst theta = math.Pi / 5 \n\nfunc setupPrototiles(w, h int) []tile {\n    var proto []tile\n    \n    for a := math.Pi/2 + theta; a < 3*math.Pi; a += 2 * theta {\n        ww := float64(w / 2)\n        hh := float64(h / 2)\n        proto = append(proto, tile{kite, ww, hh, a, float64(w) / 2.5})\n    }\n    return proto\n}\n\nfunc distinctTiles(tls []tile) []tile {\n    tileset := make(map[tile]bool)\n    for _, tl := range tls {\n        tileset[tl] = true\n    }\n    distinct := make([]tile, len(tileset))\n    for tl, _ := range tileset {\n        distinct = append(distinct, tl)\n    }\n    return distinct\n}\n\nfunc deflateTiles(tls []tile, gen int) []tile {\n    if gen <= 0 {\n        return tls\n    }\n    var next []tile\n    for _, tl := range tls {\n        x, y, a, size := tl.x, tl.y, tl.angle, tl.size/gr\n        var nx, ny float64\n        if tl.tt == dart {\n            next = append(next, tile{kite, x, y, a + 5*theta, size})\n            for i, sign := 0, 1.0; i < 2; i, sign = i+1, -sign {\n                nx = x + math.Cos(a-4*theta*sign)*gr*tl.size\n                ny = y - math.Sin(a-4*theta*sign)*gr*tl.size\n                next = append(next, tile{dart, nx, ny, a - 4*theta*sign, size})\n            }\n        } else {\n            for i, sign := 0, 1.0; i < 2; i, sign = i+1, -sign {\n                next = append(next, tile{dart, x, y, a - 4*theta*sign, size})\n                nx = x + math.Cos(a-theta*sign)*gr*tl.size\n                ny = y - math.Sin(a-theta*sign)*gr*tl.size\n                next = append(next, tile{kite, nx, ny, a + 3*theta*sign, size})\n            }\n        }\n    }\n    \n    tls = distinctTiles(next)\n    return deflateTiles(tls, gen-1)\n}\n\nfunc drawTiles(dc *gg.Context, tls []tile) {\n    dist := [2][3]float64{{gr, gr, gr}, {-gr, -1, -gr}}\n    for _, tl := range tls {\n        angle := tl.angle - theta\n        dc.MoveTo(tl.x, tl.y)\n        ord := tl.tt\n        for i := 0; i < 3; i++ {\n            x := tl.x + dist[ord][i]*tl.size*math.Cos(angle)\n            y := tl.y - dist[ord][i]*tl.size*math.Sin(angle)\n            dc.LineTo(x, y)\n            angle += theta\n        }\n        dc.ClosePath()\n        if ord == kite {\n            dc.SetHexColor(\"FFA500\") \n        } else {\n            dc.SetHexColor(\"FFFF00\") \n        }\n        dc.FillPreserve()\n        dc.SetHexColor(\"A9A9A9\") \n        dc.SetLineWidth(1)\n        dc.Stroke()\n    }\n}\n\nfunc main() {\n    w, h := 700, 450\n    dc := gg.NewContext(w, h)\n    dc.SetRGB(1, 1, 1)\n    dc.Clear()\n    tiles := deflateTiles(setupPrototiles(w, h), 5)\n    drawTiles(dc, tiles)\n    dc.SavePNG(\"penrose_tiling.png\")\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 109,
    "input": "Translate Java to Python:public class LogicPuzzle\n{\n    boolean S[] = new boolean[13];\n    int Count = 0;\n\n    public boolean check2 ()\n    {\n        int count = 0;\n        for (int k = 7; k <= 12; k++)\n            if (S[k]) count++;\n        return S[2] == (count == 3);\n    }\n\n    public boolean check3 ()\n    {\n        int count = 0;\n        for (int k = 2; k <= 12; k += 2)\n            if (S[k]) count++;\n        return S[3] == (count == 2);\n    }\n\n    public boolean check4 ()\n    {\n        return S[4] == ( !S[5] || S[6] && S[7]);\n    }\n\n    public boolean check5 ()\n    {\n        return S[5] == ( !S[2] && !S[3] && !S[4]);\n    }\n\n    public boolean check6 ()\n    {\n        int count = 0;\n        for (int k = 1; k <= 11; k += 2)\n            if (S[k]) count++;\n        return S[6] == (count == 4);\n    }\n\n    public boolean check7 ()\n    {\n        return S[7] == ((S[2] || S[3]) && !(S[2] && S[3]));\n    }\n\n    public boolean check8 ()\n    {\n        return S[8] == ( !S[7] || S[5] && S[6]);\n    }\n\n    public boolean check9 ()\n    {\n        int count = 0;\n        for (int k = 1; k <= 6; k++)\n            if (S[k]) count++;\n        return S[9] == (count == 3);\n    }\n\n    public boolean check10 ()\n    {\n        return S[10] == (S[11] && S[12]);\n    }\n\n    public boolean check11 ()\n    {\n        int count = 0;\n        for (int k = 7; k <= 9; k++)\n            if (S[k]) count++;\n        return S[11] == (count == 1);\n    }\n\n    public boolean check12 ()\n    {\n        int count = 0;\n        for (int k = 1; k <= 11; k++)\n            if (S[k]) count++;\n        return S[12] == (count == 4);\n    }\n\n    public void check ()\n    {\n        if (check2() && check3() && check4() && check5() && check6()\n            && check7() && check8() && check9() && check10() && check11()\n            && check12())\n        {\n            for (int k = 1; k <= 12; k++)\n                if (S[k]) System.out.print(k + \" \");\n            System.out.println();\n            Count++;\n        }\n    }\n\n    public void recurseAll (int k)\n    {\n        if (k == 13)\n            check();\n        else\n        {\n            S[k] = false;\n            recurseAll(k + 1);\n            S[k] = true;\n            recurseAll(k + 1);\n        }\n    }\n\n    public static void main (String args[])\n    {\n        LogicPuzzle P = new LogicPuzzle();\n        P.S[1] = true;\n        P.recurseAll(2);\n        System.out.println();\n        System.out.println(P.Count + \" Solutions found.\");\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from itertools import product\n\n\nconstraintinfo = (  \n  (lambda st: len(st) == 12                 ,(1, 'This is a numbered list of twelve statements')),\n  (lambda st: sum(st[-6:]) == 3             ,(2, 'Exactly 3 of the last 6 statements are true')),\n  (lambda st: sum(st[1::2]) == 2            ,(3, 'Exactly 2 of the even-numbered statements are true')),\n  (lambda st: (st[5]&st[6]) if st[4] else 1 ,(4, 'If statement 5 is true, then statements 6 and 7 are both true')),\n  (lambda st: sum(st[1:4]) == 0             ,(5, 'The 3 preceding statements are all false')),\n  (lambda st: sum(st[0::2]) == 4            ,(6, 'Exactly 4 of the odd-numbered statements are true')),\n  (lambda st: sum(st[1:3]) == 1             ,(7, 'Either statement 2 or 3 is true, but not both')),\n  (lambda st: (st[4]&st[5]) if st[6] else 1 ,(8, 'If statement 7 is true, then 5 and 6 are both true')),\n  (lambda st: sum(st[:6]) == 3              ,(9, 'Exactly 3 of the first 6 statements are true')),\n  (lambda st: (st[10]&st[11])               ,(10, 'The next two statements are both true')),\n  (lambda st: sum(st[6:9]) == 1             ,(11, 'Exactly 1 of statements 7, 8 and 9 are true')),\n  (lambda st: sum(st[0:11]) == 4            ,(12, 'Exactly 4 of the preceding statements are true')),\n)  \n\ndef printer(st, matches):\n    if False in matches:\n        print('Missed by one statement: %i, %s' % docs[matches.index(False)])\n    else:\n        print('Full match:')\n    print('  ' + ', '.join('%i:%s' % (i, 'T' if t else 'F') for i, t in enumerate(st, 1)))\n\nfuncs, docs = zip(*constraintinfo)\n\nfull, partial = [], []\n\nfor st in product( *([(False, True)] * 12) ):\n    truths = [bool(func(st)) for func in funcs]\n    matches = [s == t for s,t in zip(st, truths)]\n    mcount = sum(matches)\n    if mcount == 12:\n        full.append((st, matches))\n    elif mcount == 11:\n        partial.append((st, matches))\n\nfor stm in full + partial:\n    printer(*stm)\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 110,
    "input": "Translate C# to VB:using System.Collections.Generic; using System.Linq; using static System.Console;\n\nclass Program {\n\n    static bool soas(int n, IEnumerable<int> f) {\n        if (n <= 0) return false; if (f.Contains(n)) return true;\n        switch(n.CompareTo(f.Sum())) { case 1: return false; case 0: return true;\n            case -1: var rf = f.Reverse().ToList(); var d = n - rf[0]; rf.RemoveAt(0);\n                return soas(d, rf) || soas(n, rf); } return true; }\n\n    static bool ip(int n) { var f = Enumerable.Range(1, n >> 1).Where(d => n % d == 0).ToList();\n        return Enumerable.Range(1, n - 1).ToList().TrueForAll(i => soas(i, f));  }\n\n    static void Main() {\n        int c = 0, m = 333; for (int i = 1; i <= m; i += i == 1 ? 1 : 2)\n            if (ip(i) || i == 1) Write(\"{0,3} {1}\", i, ++c % 10 == 0 ? \"\\n\" : \"\"); \n        Write(\"\\nFound {0} practical numbers between 1 and {1} inclusive.\\n\", c, m);\n        do Write(\"\\n{0,5} is a{1}practical number.\",\n            m = m < 500 ? m << 1 : m * 10 + 6, ip(m) ? \" \" : \"n im\"); while (m < 1e4); } }\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Imports System.Collections.Generic, System.Linq, System.Console\n\nModule Module1\n    Function soas(ByVal n As Integer, ByVal f As IEnumerable(Of Integer)) As Boolean\n        If n <= 0 Then Return False Else If f.Contains(n) Then Return True\n        Select Case n.CompareTo(f.Sum())\n            Case 1 : Return False : Case 0 : Return True\n            Case -1 : Dim rf As List(Of Integer) = f.Reverse().ToList() : Dim D as Integer = n - rf(0) \n                rf.RemoveAt(0) : Return soas(d, rf) OrElse soas(n, rf)\n        End Select : Return true\n    End Function\n\n    Function ip(ByVal n As Integer) As Boolean\n        Dim f As IEnumerable(Of Integer) = Enumerable.Range(1, n >> 1).Where(Function(d) n Mod d = 0).ToList()\n        Return Enumerable.Range(1, n - 1).ToList().TrueForAll(Function(i) soas(i, f))\n    End Function\n\n    Sub Main()\n        Dim c As Integer = 0, m As Integer = 333, i As Integer = 1 : While i <= m\n            If ip(i) OrElse i = 1 Then c += 1 : Write(\"{0,3} {1}\", i, If(c Mod 10 = 0, vbLf, \"\"))\n            i += If(i = 1, 1, 2) : End While\n        Write(vbLf & \"Found {0} practical numbers between 1 and {1} inclusive.\" & vbLf, c, m)\n        Do : m = If(m < 500, m << 1, m * 10 + 6)\n            Write(vbLf & \"{0,5} is a{1}practical number.\", m, If(ip(m), \" \", \"n im\")) : Loop While m < 1e4\n    End Sub\nEnd Module\n",
    "input_language": "C#",
    "output_language": "VB"
  },
  {
    "id": 111,
    "input": "Translate C to Go:count = 1;\n while (count < 10) {\n     print(\"count is: \", count, \"\\n\");\n     count = count + 1;\n }\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype TokenType int\n\nconst (\n    tkEOI TokenType = iota\n    tkMul\n    tkDiv\n    tkMod\n    tkAdd\n    tkSub\n    tkNegate\n    tkNot\n    tkLss\n    tkLeq\n    tkGtr\n    tkGeq\n    tkEql\n    tkNeq\n    tkAssign\n    tkAnd\n    tkOr\n    tkIf\n    tkElse\n    tkWhile\n    tkPrint\n    tkPutc\n    tkLparen\n    tkRparen\n    tkLbrace\n    tkRbrace\n    tkSemi\n    tkComma\n    tkIdent\n    tkInteger\n    tkString\n)\n\ntype NodeType int\n\nconst (\n    ndIdent NodeType = iota\n    ndString\n    ndInteger\n    ndSequence\n    ndIf\n    ndPrtc\n    ndPrts\n    ndPrti\n    ndWhile\n    ndAssign\n    ndNegate\n    ndNot\n    ndMul\n    ndDiv\n    ndMod\n    ndAdd\n    ndSub\n    ndLss\n    ndLeq\n    ndGtr\n    ndGeq\n    ndEql\n    ndNeq\n    ndAnd\n    ndOr\n)\n\ntype tokS struct {\n    tok    TokenType\n    errLn  int\n    errCol int\n    text   string \n}\n\ntype Tree struct {\n    nodeType NodeType\n    left     *Tree\n    right    *Tree\n    value    string\n}\n\n\ntype atr struct {\n    text             string\n    enumText         string\n    tok              TokenType\n    rightAssociative bool\n    isBinary         bool\n    isUnary          bool\n    precedence       int\n    nodeType         NodeType\n}\n\nvar atrs = []atr{\n    {\"EOI\", \"End_of_input\", tkEOI, false, false, false, -1, -1},\n    {\"*\", \"Op_multiply\", tkMul, false, true, false, 13, ndMul},\n    {\"/\", \"Op_divide\", tkDiv, false, true, false, 13, ndDiv},\n    {\"%\", \"Op_mod\", tkMod, false, true, false, 13, ndMod},\n    {\"+\", \"Op_add\", tkAdd, false, true, false, 12, ndAdd},\n    {\"-\", \"Op_subtract\", tkSub, false, true, false, 12, ndSub},\n    {\"-\", \"Op_negate\", tkNegate, false, false, true, 14, ndNegate},\n    {\"!\", \"Op_not\", tkNot, false, false, true, 14, ndNot},\n    {\"<\", \"Op_less\", tkLss, false, true, false, 10, ndLss},\n    {\"<=\", \"Op_lessequal\", tkLeq, false, true, false, 10, ndLeq},\n    {\">\", \"Op_greater\", tkGtr, false, true, false, 10, ndGtr},\n    {\">=\", \"Op_greaterequal\", tkGeq, false, true, false, 10, ndGeq},\n    {\"==\", \"Op_equal\", tkEql, false, true, false, 9, ndEql},\n    {\"!=\", \"Op_notequal\", tkNeq, false, true, false, 9, ndNeq},\n    {\"=\", \"Op_assign\", tkAssign, false, false, false, -1, ndAssign},\n    {\"&&\", \"Op_and\", tkAnd, false, true, false, 5, ndAnd},\n    {\"||\", \"Op_or\", tkOr, false, true, false, 4, ndOr},\n    {\"if\", \"Keyword_if\", tkIf, false, false, false, -1, ndIf},\n    {\"else\", \"Keyword_else\", tkElse, false, false, false, -1, -1},\n    {\"while\", \"Keyword_while\", tkWhile, false, false, false, -1, ndWhile},\n    {\"print\", \"Keyword_print\", tkPrint, false, false, false, -1, -1},\n    {\"putc\", \"Keyword_putc\", tkPutc, false, false, false, -1, -1},\n    {\"(\", \"LeftParen\", tkLparen, false, false, false, -1, -1},\n    {\")\", \"RightParen\", tkRparen, false, false, false, -1, -1},\n    {\"{\", \"LeftBrace\", tkLbrace, false, false, false, -1, -1},\n    {\"}\", \"RightBrace\", tkRbrace, false, false, false, -1, -1},\n    {\";\", \"Semicolon\", tkSemi, false, false, false, -1, -1},\n    {\",\", \"Comma\", tkComma, false, false, false, -1, -1},\n    {\"Ident\", \"Identifier\", tkIdent, false, false, false, -1, ndIdent},\n    {\"Integer literal\", \"Integer\", tkInteger, false, false, false, -1, ndInteger},\n    {\"String literal\", \"String\", tkString, false, false, false, -1, ndString},\n}\n\nvar displayNodes = []string{\n    \"Identifier\", \"String\", \"Integer\", \"Sequence\", \"If\", \"Prtc\", \"Prts\", \"Prti\",\n    \"While\", \"Assign\", \"Negate\", \"Not\", \"Multiply\", \"Divide\", \"Mod\", \"Add\",\n    \"Subtract\", \"Less\", \"LessEqual\", \"Greater\", \"GreaterEqual\", \"Equal\",\n    \"NotEqual\", \"And\", \"Or\",\n}\n\nvar (\n    err     error\n    token   tokS\n    scanner *bufio.Scanner\n)\n\nfunc reportError(errLine, errCol int, msg string) {\n    log.Fatalf(\"(%d, %d) error : %s\\n\", errLine, errCol, msg)\n}\n\nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc getEum(name string) TokenType { \n    for _, atr := range atrs {\n        if atr.enumText == name {\n            return atr.tok\n        }\n    }\n    reportError(0, 0, fmt.Sprintf(\"Unknown token %s\\n\", name))\n    return tkEOI\n}\n\nfunc getTok() tokS {\n    tok := tokS{}\n    if scanner.Scan() {\n        line := strings.TrimRight(scanner.Text(), \" \\t\")\n        fields := strings.Fields(line)\n        \n        tok.errLn, err = strconv.Atoi(fields[0])\n        check(err)\n        tok.errCol, err = strconv.Atoi(fields[1])\n        check(err)\n        tok.tok = getEum(fields[2])\n        le := len(fields)\n        if le == 4 {\n            tok.text = fields[3]\n        } else if le > 4 {\n            idx := strings.Index(line, `\"`)\n            tok.text = line[idx:]\n        }\n    }\n    check(scanner.Err())\n    return tok\n}\n\nfunc makeNode(nodeType NodeType, left *Tree, right *Tree) *Tree {\n    return &Tree{nodeType, left, right, \"\"}\n}\n\nfunc makeLeaf(nodeType NodeType, value string) *Tree {\n    return &Tree{nodeType, nil, nil, value}\n}\n\nfunc expect(msg string, s TokenType) {\n    if token.tok == s {\n        token = getTok()\n        return\n    }\n    reportError(token.errLn, token.errCol,\n        fmt.Sprintf(\"%s: Expecting '%s', found '%s'\\n\", msg, atrs[s].text, atrs[token.tok].text))\n}\n\nfunc expr(p int) *Tree {\n    var x, node *Tree\n    switch token.tok {\n    case tkLparen:\n        x = parenExpr()\n    case tkSub, tkAdd:\n        op := token.tok\n        token = getTok()\n        node = expr(atrs[tkNegate].precedence)\n        if op == tkSub {\n            x = makeNode(ndNegate, node, nil)\n        } else {\n            x = node\n        }\n    case tkNot:\n        token = getTok()\n        x = makeNode(ndNot, expr(atrs[tkNot].precedence), nil)\n    case tkIdent:\n        x = makeLeaf(ndIdent, token.text)\n        token = getTok()\n    case tkInteger:\n        x = makeLeaf(ndInteger, token.text)\n        token = getTok()\n    default:\n        reportError(token.errLn, token.errCol,\n            fmt.Sprintf(\"Expecting a primary, found: %s\\n\", atrs[token.tok].text))\n    }\n\n    for atrs[token.tok].isBinary && atrs[token.tok].precedence >= p {\n        op := token.tok\n        token = getTok()\n        q := atrs[op].precedence\n        if !atrs[op].rightAssociative {\n            q++\n        }\n        node = expr(q)\n        x = makeNode(atrs[op].nodeType, x, node)\n    }\n    return x\n}\n\nfunc parenExpr() *Tree {\n    expect(\"parenExpr\", tkLparen)\n    t := expr(0)\n    expect(\"parenExpr\", tkRparen)\n    return t\n}\n\nfunc stmt() *Tree {\n    var t, v, e, s, s2 *Tree\n    switch token.tok {\n    case tkIf:\n        token = getTok()\n        e = parenExpr()\n        s = stmt()\n        s2 = nil\n        if token.tok == tkElse {\n            token = getTok()\n            s2 = stmt()\n        }\n        t = makeNode(ndIf, e, makeNode(ndIf, s, s2))\n    case tkPutc:\n        token = getTok()\n        e = parenExpr()\n        t = makeNode(ndPrtc, e, nil)\n        expect(\"Putc\", tkSemi)\n    case tkPrint: \n        token = getTok()\n        for expect(\"Print\", tkLparen); ; expect(\"Print\", tkComma) {\n            if token.tok == tkString {\n                e = makeNode(ndPrts, makeLeaf(ndString, token.text), nil)\n                token = getTok()\n            } else {\n                e = makeNode(ndPrti, expr(0), nil)\n            }\n            t = makeNode(ndSequence, t, e)\n            if token.tok != tkComma {\n                break\n            }\n        }\n        expect(\"Print\", tkRparen)\n        expect(\"Print\", tkSemi)\n    case tkSemi:\n        token = getTok()\n    case tkIdent:\n        v = makeLeaf(ndIdent, token.text)\n        token = getTok()\n        expect(\"assign\", tkAssign)\n        e = expr(0)\n        t = makeNode(ndAssign, v, e)\n        expect(\"assign\", tkSemi)\n    case tkWhile:\n        token = getTok()\n        e = parenExpr()\n        s = stmt()\n        t = makeNode(ndWhile, e, s)\n    case tkLbrace: \n        for expect(\"Lbrace\", tkLbrace); token.tok != tkRbrace && token.tok != tkEOI; {\n            t = makeNode(ndSequence, t, stmt())\n        }\n        expect(\"Lbrace\", tkRbrace)\n    case tkEOI:\n        \n    default:\n        reportError(token.errLn, token.errCol,\n            fmt.Sprintf(\"expecting start of statement, found '%s'\\n\", atrs[token.tok].text))\n    }\n    return t\n}\n\nfunc parse() *Tree {\n    var t *Tree\n    token = getTok()\n    for {\n        t = makeNode(ndSequence, t, stmt())\n        if t == nil || token.tok == tkEOI {\n            break\n        }\n    }\n    return t\n}\n\nfunc prtAst(t *Tree) {\n    if t == nil {\n        fmt.Print(\";\\n\")\n    } else {\n        fmt.Printf(\"%-14s \", displayNodes[t.nodeType])\n        if t.nodeType == ndIdent || t.nodeType == ndInteger || t.nodeType == ndString {\n            fmt.Printf(\"%s\\n\", t.value)\n        } else {\n            fmt.Println()\n            prtAst(t.left)\n            prtAst(t.right)\n        }\n    }\n}\n\nfunc main() {\n    source, err := os.Open(\"source.txt\")\n    check(err)\n    defer source.Close()\n    scanner = bufio.NewScanner(source)\n    prtAst(parse())\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 112,
    "input": "Translate C to Go:#include<stdio.h>\n#include<stdlib.h>\n\nint isprime( int p ) {\n    int i;\n    if(p==2) return 1;\n    if(!(p%2)) return 0;\n    for(i=3; i*i<=p; i+=2) {\n       if(!(p%i)) return 0;\n    }\n    return 1;\n}\n\nint nextprime( int p ) {\n    int i=0;\n    if(p==0) return 2;\n    if(p<3) return p+1;\n    while(!isprime(++i + p));\n    return i+p;\n}\n\nint issquare( int p ) {\n    int i;\n    for(i=0;i*i<p;i++);\n    return i*i==p;\n}\n\nint main(void) {\n    int i=3, j=2;\n    for(i=3;j<=1000000;i=j) {\n        j=nextprime(i);\n        if(j-i>36&&issquare(j-i)) printf( \"%d %d %d\\n\", i, j, j-i );\n    }\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"rcu\"\n)\n\nfunc main() {\n    limit := 999999\n    primes := rcu.Primes(limit)\n    fmt.Println(\"Adjacent primes under 1,000,000 whose difference is a square > 36:\")\n    for i := 1; i < len(primes); i++ {\n        diff := primes[i] - primes[i-1]\n        if diff > 36 {\n            s := int(math.Sqrt(float64(diff)))\n            if diff == s*s {\n                cp1 := rcu.Commatize(primes[i])\n                cp2 := rcu.Commatize(primes[i-1])\n                fmt.Printf(\"%7s - %7s = %3d = %2d x %2d\\n\", cp1, cp2, diff, s, s)\n            }\n        }\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 113,
    "input": "Translate C# to Go:\nusing System;\nclass Program\n{\n    static void Main()\n    {\n        uint[] r = items1();\n        Console.WriteLine(r[0] + \" v  \" + r[1] + \" a  \" + r[2] + \" b\");  \n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) items1();\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint[] items0()  \n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n                for (c = 0; a * 25 + b * 15 + c * 2 <= 250 && a * 3 + b * 2 + c * 20 <= 250; c++)\n                    if (v0 < (v = a * 30 + b * 18 + c * 25))\n                    {\n                        v0 = v; a0 = a; b0 = b; c0 = c;\n                        \n                    }\n        return new uint[] { a0, b0, c0 };\n    }\n\n    static uint[] items1()  \n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0, c1 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n            {\n                c = (250 - a * 25 - b * 15) / 2;\n                if ((c1 = (250 - a * 3 - b * 2) / 20) < c) c = c1;\n                if (v0 < (v = a * 30 + b * 18 + c * 25))\n                { v0 = v; a0 = a; b0 = b; c0 = c; }\n            }\n        return new uint[] { a0, b0, c0 };\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\ntype Item struct {\n\tName           string\n\tValue          int\n\tWeight, Volume float64\n}\n\ntype Result struct {\n\tCounts []int\n\tSum    int\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc Knapsack(items []Item, weight, volume float64) (best Result) {\n\tif len(items) == 0 {\n\t\treturn\n\t}\n\tn := len(items) - 1\n\tmaxCount := min(int(weight/items[n].Weight), int(volume/items[n].Volume))\n\tfor count := 0; count <= maxCount; count++ {\n\t\tsol := Knapsack(items[:n],\n\t\t\tweight-float64(count)*items[n].Weight,\n\t\t\tvolume-float64(count)*items[n].Volume)\n\t\tsol.Sum += items[n].Value * count\n\t\tif sol.Sum > best.Sum {\n\t\t\tsol.Counts = append(sol.Counts, count)\n\t\t\tbest = sol\n\t\t}\n\t}\n\treturn\n}\n\nfunc main() {\n\titems := []Item{\n\t\t{\"Panacea\", 3000, 0.3, 0.025},\n\t\t{\"Ichor\", 1800, 0.2, 0.015},\n\t\t{\"Gold\", 2500, 2.0, 0.002},\n\t}\n\tvar sumCount, sumValue int\n\tvar sumWeight, sumVolume float64\n\n\tresult := Knapsack(items, 25, 0.25)\n\n\tfor i := range result.Counts {\n\t\tfmt.Printf(\"%-8s x%3d  -> Weight: %4.1f  Volume: %5.3f  Value: %6d\\n\",\n\t\t\titems[i].Name, result.Counts[i], items[i].Weight*float64(result.Counts[i]),\n\t\t\titems[i].Volume*float64(result.Counts[i]), items[i].Value*result.Counts[i])\n\n\t\tsumCount += result.Counts[i]\n\t\tsumValue += items[i].Value * result.Counts[i]\n\t\tsumWeight += items[i].Weight * float64(result.Counts[i])\n\t\tsumVolume += items[i].Volume * float64(result.Counts[i])\n\t}\n\n\tfmt.Printf(\"TOTAL (%3d items) Weight: %4.1f  Volume: %5.3f  Value: %6d\\n\",\n\t\tsumCount, sumWeight, sumVolume, sumValue)\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 114,
    "input": "Translate Python to C#:\nfrom unicodedata import name\n\n\ndef unicode_code(ch):\n    return 'U+{:04x}'.format(ord(ch))\n\n\ndef utf8hex(ch):\n    return \" \".join([hex(c)[2:] for c in ch.encode('utf8')]).upper()\n\n\nif __name__ == \"__main__\":\n    print('{:<11} {:<36} {:<15} {:<15}'.format('Character', 'Name', 'Unicode', 'UTF-8 encoding (hex)'))\n    chars = ['A', 'ö', 'Ж', '€', '𝄞']\n    for char in chars:\n        print('{:<11} {:<36} {:<15} {:<15}'.format(char, name(char), unicode_code(char), utf8hex(char)))\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Text;\n\nnamespace Rosetta\n{\n    class Program\n    {\n        static byte[] MyEncoder(int codepoint) => Encoding.UTF8.GetBytes(char.ConvertFromUtf32(codepoint));\n        static string MyDecoder(byte[] utf8bytes) => Encoding.UTF8.GetString(utf8bytes);\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = Encoding.UTF8;  \n            foreach (int unicodePoint in new int[] {  0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E})\n            {\n                byte[] asUtf8bytes = MyEncoder(unicodePoint);\n                string theCharacter = MyDecoder(asUtf8bytes);\n                Console.WriteLine(\"{0,8} {1,5}     {2,-15}\", unicodePoint.ToString(\"X4\"), theCharacter, BitConverter.ToString(asUtf8bytes));\n            }\n        }\n    }\n}\n\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 115,
    "input": "Translate C# to Go:enum fruits { apple, banana, cherry }\n\nenum fruits { apple = 0, banana = 1, cherry = 2 }\n\nenum fruits : int { apple = 0, banana = 1, cherry = 2 }\n\n[FlagsAttribute]\nenum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "const (\n\tapple = iota\n\tbanana\n\tcherry\n)\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 116,
    "input": "Translate C to Python:#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct node_t {\n    char *elem;\n    int length;\n    struct node_t *next;\n} node;\n\nnode *make_node(char *s) {\n    node *t = malloc(sizeof(node));\n    t->elem = s;\n    t->length = strlen(s);\n    t->next = NULL;\n    return t;\n}\n\nvoid append_node(node *head, node *elem) {\n    while (head->next != NULL) {\n        head = head->next;\n    }\n    head->next = elem;\n}\n\nvoid print_node(node *n) {\n    putc('[', stdout);\n    while (n != NULL) {\n        printf(\"`%s` \", n->elem);\n        n = n->next;\n    }\n    putc(']', stdout);\n}\n\nchar *lcs(node *list) {\n    int minLen = INT_MAX;\n    int i;\n\n    char *res;\n    node *ptr;\n\n    if (list == NULL) {\n        return \"\";\n    }\n    if (list->next == NULL) {\n        return list->elem;\n    }\n\n    for (ptr = list; ptr != NULL; ptr = ptr->next) {\n        minLen = min(minLen, ptr->length);\n    }\n    if (minLen == 0) {\n        return \"\";\n    }\n\n    res = \"\";\n    for (i = 1; i < minLen; i++) {\n        char *suffix = &list->elem[list->length - i];\n\n        for (ptr = list->next; ptr != NULL; ptr = ptr->next) {\n            char *e = &ptr->elem[ptr->length - i];\n            if (strcmp(suffix, e) != 0) {\n                return res;\n            }\n        }\n\n        res = suffix;\n    }\n\n    return res;\n}\n\nvoid test(node *n) {\n    print_node(n);\n    printf(\" -> `%s`\\n\", lcs(n));\n}\n\nvoid case1() {\n    node *n = make_node(\"baabababc\");\n    append_node(n, make_node(\"baabc\"));\n    append_node(n, make_node(\"bbbabc\"));\n    test(n);\n}\n\nvoid case2() {\n    node *n = make_node(\"baabababc\");\n    append_node(n, make_node(\"baabc\"));\n    append_node(n, make_node(\"bbbazc\"));\n    test(n);\n}\n\nvoid case3() {\n    node *n = make_node(\"Sunday\");\n    append_node(n, make_node(\"Monday\"));\n    append_node(n, make_node(\"Tuesday\"));\n    append_node(n, make_node(\"Wednesday\"));\n    append_node(n, make_node(\"Thursday\"));\n    append_node(n, make_node(\"Friday\"));\n    append_node(n, make_node(\"Saturday\"));\n    test(n);\n}\n\nvoid case4() {\n    node *n = make_node(\"longest\");\n    append_node(n, make_node(\"common\"));\n    append_node(n, make_node(\"suffix\"));\n    test(n);\n}\n\nvoid case5() {\n    node *n = make_node(\"suffix\");\n    test(n);\n}\n\nvoid case6() {\n    node *n = make_node(\"\");\n    test(n);\n}\n\nint main() {\n    case1();\n    case2();\n    case3();\n    case4();\n    case5();\n    case6();\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\nfrom itertools import takewhile\nfrom functools import reduce\n\n\n\ndef longestCommonSuffix(xs):\n    \n    def allSame(cs):\n        h = cs[0]\n        return all(h == c for c in cs[1:])\n\n    def firstCharPrepended(s, cs):\n        return cs[0] + s\n    return reduce(\n        firstCharPrepended,\n        takewhile(\n            allSame,\n            zip(*(reversed(x) for x in xs))\n        ),\n        ''\n    )\n\n\n\n\ndef main():\n    \n\n    samples = [\n        [\n            \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n            \"Thursday\", \"Friday\", \"Saturday\"\n        ], [\n            \"Sondag\", \"Maandag\", \"Dinsdag\", \"Woensdag\",\n            \"Donderdag\", \"Vrydag\", \"Saterdag\"\n        ]\n    ]\n    for xs in samples:\n        print(\n            longestCommonSuffix(xs)\n        )\n\n\n\nif __name__ == '__main__':\n    main()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 117,
    "input": "Translate C++ to Python:#pragma once\n\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n\nclass Approx {\npublic:\n    Approx(double _v, double _s = 0.0) : v(_v), s(_s) {}\n\n    operator std::string() const {\n        std::ostringstream os(\"\");\n        os << std::setprecision(15) << v << \" ±\" << std::setprecision(15) << s << std::ends;\n        return os.str();\n    }\n\n    Approx operator +(const Approx& a) const { return Approx(v + a.v, sqrt(s * s + a.s * a.s)); }\n    Approx operator +(double d) const { return Approx(v + d, s); }\n    Approx operator -(const Approx& a) const { return Approx(v - a.v, sqrt(s * s + a.s * a.s)); }\n    Approx operator -(double d) const { return Approx(v - d, s); }\n\n    Approx operator *(const Approx& a) const {\n        const double t = v * a.v;\n        return Approx(v, sqrt(t * t * s * s / (v * v) + a.s * a.s / (a.v * a.v)));\n    }\n\n    Approx operator *(double d) const { return Approx(v * d, fabs(d * s)); }\n\n    Approx operator /(const Approx& a) const {\n        const double t = v / a.v;\n        return Approx(t, sqrt(t * t * s * s / (v * v) + a.s * a.s / (a.v * a.v)));\n    }\n\n    Approx operator /(double d) const { return Approx(v / d, fabs(d * s)); }\n\n    Approx pow(double d) const {\n        const double t = ::pow(v, d);\n        return Approx(t, fabs(t * d * s / v));\n    }\n\nprivate:\n    double v, s;\n};\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from collections import namedtuple\nimport math\n \nclass I(namedtuple('Imprecise', 'value, delta')):\n    'Imprecise type: I(value=0.0, delta=0.0)' \n \n    __slots__ = () \n \n    def __new__(_cls, value=0.0, delta=0.0):\n        'Defaults to 0.0 ± delta'\n        return super().__new__(_cls, float(value), abs(float(delta)))\n \n    def reciprocal(self):\n        return I(1. / self.value, self.delta / (self.value**2)) \n \n    def __str__(self):\n        'Shorter form of Imprecise as string'\n        return 'I(%g, %g)' % self\n \n    def __neg__(self):\n        return I(-self.value, self.delta)\n \n    def __add__(self, other):\n        if type(other) == I:\n            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value + c, self.delta)\n\n    def __sub__(self, other):\n        return self + (-other)\n \n    def __radd__(self, other):\n        return I.__add__(self, other)\n \n    def __mul__(self, other):\n        if type(other) == I:\n            \n            \n            a1,b1 = self\n            a2,b2 = other\n            f = a1 * a2\n            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value * c, self.delta * c)\n \n    def __pow__(self, other):\n        if type(other) == I:\n            return NotImplemented\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        f = self.value ** c\n        return I(f, f * c * (self.delta / self.value))\n \n    def __rmul__(self, other):\n        return I.__mul__(self, other)\n \n    def __truediv__(self, other):\n        if type(other) == I:\n            return self.__mul__(other.reciprocal())\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value / c, self.delta / c)\n \n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n \n    __div__, __rdiv__ = __truediv__, __rtruediv__\n \nImprecise = I\n\ndef distance(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n \nx1 = I(100, 1.1)\nx2 = I(200, 2.2)\ny1 = I( 50, 1.2)\ny2 = I(100, 2.3)\n\np1, p2 = (x1, y1), (x2, y2)\nprint(\"Distance between points\\n  p1: %s\\n  and p2: %s\\n  = %r\" % (\n      p1, p2, distance(p1, p2)))\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 118,
    "input": "Translate C to Go:#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\nenum { MAX_ROWS=14, MAX_NAMES=20, NAME_SZ=80 };\n\nchar *Lines[MAX_ROWS] = {\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                      ID                       |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    QDCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    ANCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    NSCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    ARCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\n};\ntypedef struct {\n   unsigned bit3s;\n   unsigned mask;\n   unsigned data;\n   char A[NAME_SZ+2];\n}NAME_T;\nNAME_T names[MAX_NAMES];\nunsigned idx_name;\nenum{ID,BITS,QDCOUNT,ANCOUNT,NSCOUNT,ARCOUNT,MAX_HDR};\nunsigned header[MAX_HDR]; \nunsigned idx_hdr;\n\nint  bit_hdr(char *pLine);\nint  bit_names(char *pLine);\nvoid dump_names(void);\nvoid make_test_hdr(void);\n\nint main(void){\n   char *p1;   int rv;\n   printf(\"Extract meta-data from bit-encoded text form\\n\");\n   make_test_hdr();\n   idx_name = 0;\n   for( int i=0; i<MAX_ROWS;i++ ){\n      p1 = Lines[i];\n      if( p1==NULL ) break;\n      if( rv = bit_hdr(Lines[i]), rv>0) continue;\n      if( rv = bit_names(Lines[i]),rv>0) continue;\n      \n   }\n   dump_names();\n}\n\nint  bit_hdr(char *pLine){ \n   char *p1 = strchr(pLine,'+');\n   if( p1==NULL ) return 0;\n   int numbits=0;\n   for( int i=0; i<strlen(p1)-1; i+=3 ){\n      if( p1[i] != '+' || p1[i+1] != '-' || p1[i+2] != '-' ) return 0;\n      numbits++;\n   }\n   return numbits;\n}\n\nint  bit_names(char *pLine){ \n   char *p1,*p2 = pLine, tmp[80];\n   unsigned sz=0, maskbitcount = 15;\n   while(1){\n      p1 = strchr(p2,'|');  if( p1==NULL ) break;\n      p1++;\n      p2 = strchr(p1,'|');  if( p2==NULL ) break;\n      sz = p2-p1;\n      tmp[sz] = 0;  \n      int k=0;\n      for(int j=0; j<sz;j++){  \n\t if( p1[j] > ' ') tmp[k++] = p1[j];\n      }\n      tmp[k]= 0; sz++;\n      NAME_T *pn = &names[idx_name++];\n      strcpy(&pn->A[0], &tmp[0]);\n      pn->bit3s = sz/3;\n      if( pn->bit3s < 16 ){\n\t for( int i=0; i<pn->bit3s; i++){\n\t    pn->mask |= 1 << maskbitcount--;\n\t }\n\t pn->data = header[idx_hdr] & pn->mask;\n\t unsigned m2 = pn->mask;\n\t while( (m2 & 1)==0 ){\n\t    m2>>=1; \n\t    pn->data >>= 1;\n\t }\n\t if( pn->mask == 0xf ) idx_hdr++;\n\n      }\n      else{\n\t pn->data = header[idx_hdr++];\n      }\n   }\n   return sz;\n}\n\nvoid dump_names(void){ \n   NAME_T *pn;\n   printf(\"-name-bits-mask-data-\\n\");\n   for( int i=0; i<MAX_NAMES; i++ ){\n      pn = &names[i];\n      if( pn->bit3s < 1 ) break;\n      printf(\"%10s %2d X%04x = %u\\n\",pn->A, pn->bit3s, pn->mask, pn->data);\n   }\n   puts(\"bye..\");\n}\n\nvoid make_test_hdr(void){\n   header[ID] = 1024;\n   header[QDCOUNT] = 12;\n   header[ANCOUNT] = 34;\n   header[NSCOUNT] = 56;\n   header[ARCOUNT] = 78;\n   \n   \n   \n   \n   header[BITS] = 0xB50A;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"math/big\"\n    \"strings\"\n)\n\ntype result struct {\n    name  string\n    size  int\n    start int\n    end   int\n}\n\nfunc (r result) String() string {\n    return fmt.Sprintf(\"%-7s   %2d    %3d   %3d\", r.name, r.size, r.start, r.end)\n}\n\nfunc validate(diagram string) []string {\n    var lines []string\n    for _, line := range strings.Split(diagram, \"\\n\") {\n        line = strings.Trim(line, \" \\t\")\n        if line != \"\" {\n            lines = append(lines, line)\n        }\n    }\n    if len(lines) == 0 {\n        log.Fatal(\"diagram has no non-empty lines!\")\n    }\n    width := len(lines[0])\n    cols := (width - 1) / 3\n    if cols != 8 && cols != 16 && cols != 32 && cols != 64 {\n        log.Fatal(\"number of columns should be 8, 16, 32 or 64\")\n    }\n    if len(lines)%2 == 0 {\n        log.Fatal(\"number of non-empty lines should be odd\")\n    }\n    if lines[0] != strings.Repeat(\"+--\", cols)+\"+\" {\n        log.Fatal(\"incorrect header line\")\n    }\n    for i, line := range lines {\n        if i == 0 {\n            continue\n        } else if i%2 == 0 {\n            if line != lines[0] {\n                log.Fatal(\"incorrect separator line\")\n            }\n        } else if len(line) != width {\n            log.Fatal(\"inconsistent line widths\")\n        } else if line[0] != '|' || line[width-1] != '|' {\n            log.Fatal(\"non-separator lines must begin and end with '|'\")\n        }\n    }\n    return lines\n}\n\nfunc decode(lines []string) []result {\n    fmt.Println(\"Name     Bits  Start  End\")\n    fmt.Println(\"=======  ====  =====  ===\")\n    start := 0\n    width := len(lines[0])\n    var results []result\n    for i, line := range lines {\n        if i%2 == 0 {\n            continue\n        }\n        line := line[1 : width-1]\n        for _, name := range strings.Split(line, \"|\") {\n            size := (len(name) + 1) / 3\n            name = strings.TrimSpace(name)\n            res := result{name, size, start, start + size - 1}\n            results = append(results, res)\n            fmt.Println(res)\n            start += size\n        }\n    }\n    return results\n}\n\nfunc unpack(results []result, hex string) {\n    fmt.Println(\"\\nTest string in hex:\")\n    fmt.Println(hex)\n    fmt.Println(\"\\nTest string in binary:\")\n    bin := hex2bin(hex)\n    fmt.Println(bin)\n    fmt.Println(\"\\nUnpacked:\\n\")\n    fmt.Println(\"Name     Size  Bit pattern\")\n    fmt.Println(\"=======  ====  ================\")\n    for _, res := range results {\n        fmt.Printf(\"%-7s   %2d   %s\\n\", res.name, res.size, bin[res.start:res.end+1])\n    }\n}\n\nfunc hex2bin(hex string) string {\n    z := new(big.Int)\n    z.SetString(hex, 16)\n    return fmt.Sprintf(\"%0*b\", 4*len(hex), z)\n}\n\nfunc main() {\n    const diagram = `\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n         |                      ID                       |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    QDCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\n        |                    ANCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    NSCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    ARCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    `\n    lines := validate(diagram)\n    fmt.Println(\"Diagram after trimming whitespace and removal of blank lines:\\n\")\n    for _, line := range lines {\n        fmt.Println(line)\n    }\n    fmt.Println(\"\\nDecoded:\\n\")\n    results := decode(lines)\n    hex := \"78477bbf5496e12e1bf169a4\" \n    unpack(results, hex)\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 119,
    "input": "Translate C to VB:#include \"stdio.h\"\n#include \"math.h\"\n\nint perfect(int n) {\n    int max = (int)sqrt((double)n) + 1;\n    int tot = 1;\n    int i;\n\n    for (i = 2; i < max; i++)\n        if ( (n % i) == 0 ) {\n            tot += i;\n            int q = n / i;\n            if (q > i)\n                tot += q;\n        }\n\n    return tot == n;\n}\n\nint main() {\n    int n;\n    for (n = 2; n < 33550337; n++)\n        if (perfect(n))\n            printf(\"%d\\n\", n);\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Private Function Factors(x As Long) As String\n    Application.Volatile\n    Dim i As Long\n    Dim cooresponding_factors As String\n    Factors = 1\n    corresponding_factors = x\n    For i = 2 To Sqr(x)\n        If x Mod i = 0 Then\n            Factors = Factors & \", \" & i\n            If i <> x / i Then corresponding_factors = x / i & \", \" & corresponding_factors\n        End If\n    Next i\n    If x <> 1 Then Factors = Factors & \", \" & corresponding_factors\nEnd Function\nPrivate Function is_perfect(n As Long)\n    fs = Split(Factors(n), \", \")\n    Dim f() As Long\n    ReDim f(UBound(fs))\n    For i = 0 To UBound(fs)\n        f(i) = Val(fs(i))\n    Next i\n    is_perfect = WorksheetFunction.Sum(f) - n = n\nEnd Function\nPublic Sub main()\n    Dim i As Long\n    For i = 2 To 100000\n        If is_perfect(i) Then Debug.Print i\n    Next i\nEnd Sub\n",
    "input_language": "C",
    "output_language": "VB"
  },
  {
    "id": 120,
    "input": "Translate C++ to Python:#include <iostream>\n#include <fstream>\n\nint main(){\n  std::ofstream lprFile;\n  lprFile.open( \"/dev/lp0\" );\n  lprFile << \"Hello World!\\n\";\n  lprFile.close();\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 121,
    "input": "Translate C to Go:#include <stdlib.h>  \n#include <string.h>  \n#include <strings.h> \n\nint mycmp(const void *s1, const void *s2)\n{\n    const char *l = *(const char **)s1, *r = *(const char **)s2;\n    size_t ll = strlen(l), lr = strlen(r);\n\n    if (ll > lr) return -1;\n    if (ll < lr) return 1;\n    return strcasecmp(l, r);\n}\n\nint main()\n{\n    const char *strings[] = {\n      \"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\" };\n\n    qsort(strings, sizeof(strings)/sizeof(*strings), sizeof(*strings), mycmp);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strings\"\n)\n\ntype sortable []string\n\nfunc (s sortable) Len() int      { return len(s) }\nfunc (s sortable) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\nfunc (s sortable) Less(i, j int) bool {\n    a, b := s[i], s[j]\n    if len(a) != len(b) {\n        return len(a) > len(b)\n    }\n    return strings.ToLower(a) < strings.ToLower(b)\n}\n\nfunc main() {\n    var s sortable = strings.Fields(\"To tell your name the livelong day To an admiring bog\")\n    fmt.Println(s, \"(original)\")\n\n    sort.Sort(s)\n    fmt.Println(s, \"(sorted)\")\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 122,
    "input": "Translate C to Go:#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n \nvoid set_mode(int want_key)\n{\n\tstatic struct termios old, new;\n\tif (!want_key) {\n\t\ttcsetattr(STDIN_FILENO, TCSANOW, &old);\n\t\treturn;\n\t}\n \n\ttcgetattr(STDIN_FILENO, &old);\n\tnew = old;\n\tnew.c_lflag &= ~(ICANON);\n\ttcsetattr(STDIN_FILENO, TCSANOW, &new);\n}\n \nint get_key(int no_timeout)\n{\n\tint c = 0;\n\tstruct timeval tv;\n\tfd_set fs;\n\ttv.tv_usec = tv.tv_sec = 0;\n \n\tFD_ZERO(&fs);\n\tFD_SET(STDIN_FILENO, &fs);\n\n\tselect(STDIN_FILENO + 1, &fs, 0, 0, no_timeout ? 0 : &tv);\n\tif (FD_ISSET(STDIN_FILENO, &fs)) {\n\t\tc = getchar();\n\t\tset_mode(0);\n\t}\n\treturn c;\n}\n \nint main()\n{\n\tint c;\n\twhile(1) {\n\t\tset_mode(1);\n\t\twhile (get_key(0)); \n\t\tprintf(\"Prompt again [Y/N]? \");\n\t\tfflush(stdout);\n\n\t\tc = get_key(1);\n\t\tif (c == 'Y' || c == 'y') {\n\t\t\tprintf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c == 'N' || c == 'n') {\n\t\t\tprintf(\"\\nDone\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"\\nYes or no?\\n\");\n\t}\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"log\"\n\n    gc \"code.google.com/p/goncurses\"\n)\n\nfunc main() {\n    s, err := gc.Init()\n    if err != nil {\n        log.Fatal(\"init:\", err)\n    }\n    defer gc.End()\n    var k gc.Key\n    for {\n        gc.FlushInput()\n        s.MovePrint(20, 0, \"Press y/n \")\n        s.Refresh()\n        switch k = s.GetChar(); k {\n        default:\n            continue\n        case 'y', 'Y', 'n', 'N':\n        }\n        break\n    }\n    s.Printf(\"\\nThanks for the %c!\\n\", k)\n    s.Refresh()\n    s.GetChar()\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 123,
    "input": "Translate PHP to Java:<?php\nfunction Y($f) {\n  $g = function($w) use($f) {\n    return $f(function() use($w) {\n      return call_user_func_array($w($w), func_get_args());\n    });\n  };\n  return $g($g);\n}\n\n$fibonacci = Y(function($f) {\n  return function($i) use($f) { return ($i <= 1) ? $i : ($f($i-1) + $f($i-2)); };\n});\n\necho $fibonacci(10), \"\\n\";\n\n$factorial = Y(function($f) {\n  return function($i) use($f) { return ($i <= 1) ? 1 : ($f($i - 1) * $i); };\n});\n\necho $factorial(10), \"\\n\";\n?>\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}\n",
    "input_language": "PHP",
    "output_language": "Java"
  },
  {
    "id": 124,
    "input": "Translate PHP to VB:function getitem($s,$depth=0) {\n    $out = [''];\n    while ($s) {\n        $c = $s[0];\n        if ($depth && ($c == ',' || $c == '}')) {\n            return [$out, $s];\n        }\n        if ($c == '{') {\n            $x = getgroup(substr($s, 1), $depth + 1);\n            if($x) {\n                $tmp = [];\n                foreach($out as $a) {\n                    foreach($x[0] as $b) { \n                        $tmp[] = $a . $b;\n                    }\n                }\n                $out = $tmp;\n                $s = $x[1];\n                continue;\n            }\n        }\n        if ($c == '\\\\' && strlen($s) > 1) {\n            list($s, $c) = [substr($s, 1), ($c . $s[1])];\n        }\n\n        $tmp = [];\n        foreach($out as $a) {\n            $tmp[] = $a . $c;\n        }\n        $out = $tmp;\n        $s = substr($s, 1);\n        \n    }\n    return [$out, $s];\n}\nfunction getgroup($s,$depth) {\n    list($out, $comma) = [[], false];\n    while ($s) {\n        list($g, $s) = getitem($s, $depth);\n        if (!$s) {\n            break;\n        }\n        $out = array_merge($out, $g);\n        if ($s[0] == '}') {\n            if ($comma) {\n                return [$out, substr($s, 1)];\n            }\n\n            $tmp = [];\n            foreach($out as $a) {\n                $tmp[] = '{' . $a . '}';\n            }\n            return [$tmp, substr($s, 1)];\n        }\n        if ($s[0] == ',') {\n            list($comma, $s) = [true, substr($s, 1)];\n        }\n    }\n    return null;\n}\n\n$lines = <<< 'END'\n~/{Downloads,Pictures}/*.{jpg,gif,png}\nIt{{em,alic}iz,erat}e{d,}, please.\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\n{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\nEND;\n\nforeach( explode(\"\\n\", $lines) as $line ) {\n    printf(\"\\n%s\\n\", $line);\n    foreach( getitem($line)[0] as $expansion ) {\n        printf(\"    %s\\n\", $expansion);\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Module Module1\n\n    Function GetGroup(s As String, depth As Integer) As Tuple(Of List(Of String), String)\n        Dim out As New List(Of String)\n        Dim comma = False\n        While Not String.IsNullOrEmpty(s)\n            Dim gs = GetItem(s, depth)\n            Dim g = gs.Item1\n            s = gs.Item2\n            If String.IsNullOrEmpty(s) Then\n                Exit While\n            End If\n            out.AddRange(g)\n\n            If s(0) = \"}\" Then\n                If comma Then\n                    Return Tuple.Create(out, s.Substring(1))\n                End If\n                Return Tuple.Create(out.Select(Function(a) \"{\" + a + \"}\").ToList(), s.Substring(1))\n            End If\n\n            If s(0) = \",\" Then\n                comma = True\n                s = s.Substring(1)\n            End If\n        End While\n        Return Nothing\n    End Function\n\n    Function GetItem(s As String, Optional depth As Integer = 0) As Tuple(Of List(Of String), String)\n        Dim out As New List(Of String) From {\"\"}\n        While Not String.IsNullOrEmpty(s)\n            Dim c = s(0)\n            If depth > 0 AndAlso (c = \",\" OrElse c = \"}\") Then\n                Return Tuple.Create(out, s)\n            End If\n            If c = \"{\" Then\n                Dim x = GetGroup(s.Substring(1), depth + 1)\n                If Not IsNothing(x) Then\n                    Dim tout As New List(Of String)\n                    For Each a In out\n                        For Each b In x.Item1\n                            tout.Add(a + b)\n                        Next\n                    Next\n                    out = tout\n                    s = x.Item2\n                    Continue While\n                End If\n            End If\n            If c = \"\\\" AndAlso s.Length > 1 Then\n                c += s(1)\n                s = s.Substring(1)\n            End If\n            out = out.Select(Function(a) a + c).ToList()\n            s = s.Substring(1)\n        End While\n        Return Tuple.Create(out, s)\n    End Function\n\n    Sub Main()\n        For Each s In {\n            \"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            \"{,{,gotta have{ ,\\, again\\, }}more }cowbell!\",\n            \"{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\"\n        }\n            Dim fmt = \"{0}\" + vbNewLine + vbTab + \"{1}\"\n            Dim parts = GetItem(s)\n            Dim res = String.Join(vbNewLine + vbTab, parts.Item1)\n            Console.WriteLine(fmt, s, res)\n        Next\n    End Sub\n\nEnd Module\n",
    "input_language": "PHP",
    "output_language": "VB"
  },
  {
    "id": 125,
    "input": "Translate C++ to Python:#include <iostream>\nusing namespace std;\n\nbool steady(int n) {\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main() {\n    for (int i = 1; i < 10000; i++)\n        if (steady(i)) printf(\"%4d^2 = %8d\\n\", i, i * i);\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "print(\"working...\")\nprint(\"Steady squares under 10.000 are:\")\nlimit = 10000\n\nfor n in range(1,limit):\n    nstr = str(n)\n    nlen = len(nstr)\n    square = str(pow(n,2))\n    rn = square[-nlen:]\n    if nstr == rn:\n       print(str(n) + \" \" + str(square))\n\nprint(\"done...\")\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 126,
    "input": "Translate C# to Go:static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc computePerfect(n int64) bool {\n    var sum int64\n    for i := int64(1); i < n; i++ {\n        if n%i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\n\n\nfunc isPerfect(n int64) bool {\n    switch n {\n    case 6, 28, 496, 8128, 33550336, 8589869056,\n        137438691328, 2305843008139952128:\n        return true\n    }\n    return false\n}\n\n\nfunc main() {\n    for n := int64(1); ; n++ {\n        if isPerfect(n) != computePerfect(n) {\n            panic(\"bug\")\n        }\n        if n%1e3 == 0 {\n            fmt.Println(\"tested\", n)\n        }\n    }\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 127,
    "input": "Translate C++ to Go:\n\n\n\n#include <iostream>\n#include <vector>\n\nusing std::cout;\nusing std::vector;\n\nvoid distribute(int dist, vector<int> &List) {\n\t\n    if (dist > List.size() )\n        List.resize(dist); \n\n    for (int i=0; i < dist; i++)\n        List[i]++;\n}\n\nvector<int> beadSort(int *myints, int n) {\n    vector<int> list, list2, fifth (myints, myints + n);\n\n    cout << \"#1 Beads falling down: \";\n    for (int i=0; i < fifth.size(); i++)\n        distribute (fifth[i], list);\n    cout << '\\n';\n\n    cout << \"\\nBeads on their sides: \";\n    for (int i=0; i < list.size(); i++)\n        cout << \" \" << list[i];\n    cout << '\\n';\n\n    \n\n    cout << \"#2 Beads right side up: \";\n    for (int i=0; i < list.size(); i++)\n        distribute (list[i], list2);\n    cout << '\\n';\n\n    return list2;\n}\n\nint main() {\n    int myints[] = {734,3,1,24,324,324,32,432,42,3,4,1,1};\n\tvector<int> sorted = beadSort(myints, sizeof(myints)/sizeof(int));\n\tcout << \"Sorted list/array: \";\n\tfor(unsigned int i=0; i<sorted.size(); i++)\n\t\tcout << sorted[i] << ' ';\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar a = []int{170, 45, 75, 90, 802, 24, 2, 66}\nvar aMax = 1000\n\nconst bead = 'o'\n\nfunc main() {\n    fmt.Println(\"before:\", a)\n    beadSort()\n    fmt.Println(\"after: \", a)\n}\n\nfunc beadSort() {\n    \n    all := make([]byte, aMax*len(a))\n    \n    \n    abacus := make([][]byte, aMax)\n    for pole, space := 0, all; pole < aMax; pole++ {\n        abacus[pole] = space[:len(a)]\n        space = space[len(a):]\n    }\n    \n    var wg sync.WaitGroup\n    \n    \n    \n    wg.Add(len(a))\n    for row, n := range a {\n        go func(row, n int) {\n            for pole := 0; pole < n; pole++ {\n                abacus[pole][row] = bead\n            }\n            wg.Done()\n        }(row, n)\n    }\n    wg.Wait()\n    \n    wg.Add(aMax)\n    for _, pole := range abacus {\n        go func(pole []byte) {\n            \n            top := 0\n            for row, space := range pole {\n                if space == bead {\n                    \n                    \n                    \n                    \n                    \n                    pole[row] = 0\n                    pole[top] = bead\n                    top++\n                }\n            }\n            wg.Done()\n        }(pole)\n    }\n    wg.Wait()\n    \n    for row := range a {\n        x := 0\n        for pole := 0; pole < aMax && abacus[pole][row] == bead; pole++ {\n            x++\n        }\n        a[len(a)-1-row] = x\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 128,
    "input": "Translate C to C++:#include <math.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#define LIMIT 15\nint smallPrimes[LIMIT];\n\nstatic void sieve() {\n    int i = 2, j;\n    int p = 5;\n\n    smallPrimes[0] = 2;\n    smallPrimes[1] = 3;\n\n    while (i < LIMIT) {\n        for (j = 0; j < i; j++) {\n            if (smallPrimes[j] * smallPrimes[j] <= p) {\n                if (p % smallPrimes[j] == 0) {\n                    p += 2;\n                    break;\n                }\n            } else {\n                smallPrimes[i++] = p;\n                p += 2;\n                break;\n            }\n        }\n    }\n}\n\nstatic bool is_prime(uint64_t n) {\n    uint64_t i;\n\n    for (i = 0; i < LIMIT; i++) {\n        if (n % smallPrimes[i] == 0) {\n            return n == smallPrimes[i];\n        }\n    }\n\n    i = smallPrimes[LIMIT - 1] + 2;\n    for (; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nstatic uint64_t divisor_count(uint64_t n) {\n    uint64_t count = 1;\n    uint64_t d;\n\n    while (n % 2 == 0) {\n        n /= 2;\n        count++;\n    }\n\n    for (d = 3; d * d <= n; d += 2) {\n        uint64_t q = n / d;\n        uint64_t r = n % d;\n        uint64_t dc = 0;\n        while (r == 0) {\n            dc += count;\n            n = q;\n            q = n / d;\n            r = n % d;\n        }\n        count += dc;\n    }\n\n    if (n != 1) {\n        return count *= 2;\n    }\n    return count;\n}\n\nstatic uint64_t OEISA073916(size_t n) {\n    uint64_t count = 0;\n    uint64_t result = 0;\n    size_t i;\n\n    if (is_prime(n)) {\n        return (uint64_t)pow(smallPrimes[n - 1], n - 1);\n    }\n\n    for (i = 1; count < n; i++) {\n        if (n % 2 == 1) {\n            \n            uint64_t root = (uint64_t)sqrt(i);\n            if (root * root != i) {\n                continue;\n            }\n        }\n        if (divisor_count(i) == n) {\n            count++;\n            result = i;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    size_t n;\n\n    sieve();\n\n    for (n = 1; n <= LIMIT; n++) {\n        if (n == 13) {\n            printf(\"A073916(%lu) = One more bit needed to represent result.\\n\", n);\n        } else {\n            printf(\"A073916(%lu) = %llu\\n\", n, OEISA073916(n));\n        }\n    }\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <iostream>\n#include <vector>\n\nstd::vector<int> smallPrimes;\n\nbool is_prime(size_t test) {\n    if (test < 2) {\n        return false;\n    }\n    if (test % 2 == 0) {\n        return test == 2;\n    }\n    for (size_t d = 3; d * d <= test; d += 2) {\n        if (test % d == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init_small_primes(size_t numPrimes) {\n    smallPrimes.push_back(2);\n\n    int count = 0;\n    for (size_t n = 3; count < numPrimes; n += 2) {\n        if (is_prime(n)) {\n            smallPrimes.push_back(n);\n            count++;\n        }\n    }\n}\n\nsize_t divisor_count(size_t n) {\n    size_t count = 1;\n    while (n % 2 == 0) {\n        n /= 2;\n        count++;\n    }\n    for (size_t d = 3; d * d <= n; d += 2) {\n        size_t q = n / d;\n        size_t r = n % d;\n        size_t dc = 0;\n        while (r == 0) {\n            dc += count;\n            n = q;\n            q = n / d;\n            r = n % d;\n        }\n        count += dc;\n    }\n    if (n != 1) {\n        count *= 2;\n    }\n    return count;\n}\n\nuint64_t OEISA073916(size_t n) {\n    if (is_prime(n)) {\n        return (uint64_t) pow(smallPrimes[n - 1], n - 1);\n    }\n\n    size_t count = 0;\n    uint64_t result = 0;\n    for (size_t i = 1; count < n; i++) {\n        if (n % 2 == 1) {\n            \n            size_t root = (size_t) sqrt(i);\n            if (root * root != i) {\n                continue;\n            }\n        }\n        if (divisor_count(i) == n) {\n            count++;\n            result = i;\n        }\n    }\n    return result;\n}\n\nint main() {\n    const int MAX = 15;\n    init_small_primes(MAX);\n    for (size_t n = 1; n <= MAX; n++) {\n        if (n == 13) {\n            std::cout << \"A073916(\" << n << \") = One more bit needed to represent result.\\n\";\n        } else {\n            std::cout << \"A073916(\" << n << \") = \" << OEISA073916(n) << '\\n';\n        }\n    }\n\n    return 0;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 129,
    "input": "Translate C++ to Go:#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\nusing word_map = std::map<size_t, std::vector<std::string>>;\n\n\nbool one_away(const std::string& s1, const std::string& s2) {\n    if (s1.size() != s2.size())\n        return false;\n    bool result = false;\n    for (size_t i = 0, n = s1.size(); i != n; ++i) {\n        if (s1[i] != s2[i]) {\n            if (result)\n                return false;\n            result = true;\n        }\n    }\n    return result;\n}\n\n\ntemplate <typename iterator_type, typename separator_type>\nstd::string join(iterator_type begin, iterator_type end,\n                 separator_type separator) {\n    std::string result;\n    if (begin != end) {\n        result += *begin++;\n        for (; begin != end; ++begin) {\n            result += separator;\n            result += *begin;\n        }\n    }\n    return result;\n}\n\n\n\n\nbool word_ladder(const word_map& words, const std::string& from,\n                 const std::string& to) {\n    auto w = words.find(from.size());\n    if (w != words.end()) {\n        auto poss = w->second;\n        std::vector<std::vector<std::string>> queue{{from}};\n        while (!queue.empty()) {\n            auto curr = queue.front();\n            queue.erase(queue.begin());\n            for (auto i = poss.begin(); i != poss.end();) {\n                if (!one_away(*i, curr.back())) {\n                    ++i;\n                    continue;\n                }\n                if (to == *i) {\n                    curr.push_back(to);\n                    std::cout << join(curr.begin(), curr.end(), \" -> \") << '\\n';\n                    return true;\n                }\n                std::vector<std::string> temp(curr);\n                temp.push_back(*i);\n                queue.push_back(std::move(temp));\n                i = poss.erase(i);\n            }\n        }\n    }\n    std::cout << from << \" into \" << to << \" cannot be done.\\n\";\n    return false;\n}\n\nint main() {\n    word_map words;\n    std::ifstream in(\"unixdict.txt\");\n    if (!in) {\n        std::cerr << \"Cannot open file unixdict.txt.\\n\";\n        return EXIT_FAILURE;\n    }\n    std::string word;\n    while (getline(in, word))\n        words[word.size()].push_back(word);\n    word_ladder(words, \"boy\", \"man\");\n    word_ladder(words, \"girl\", \"lady\");\n    word_ladder(words, \"john\", \"jane\");\n    word_ladder(words, \"child\", \"adult\");\n    word_ladder(words, \"cat\", \"dog\");\n    word_ladder(words, \"lead\", \"gold\");\n    word_ladder(words, \"white\", \"black\");\n    word_ladder(words, \"bubble\", \"tickle\");\n    return EXIT_SUCCESS;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"strings\"\n)\n\nfunc contains(a []string, s string) bool {\n    for _, e := range a {\n        if e == s {\n            return true\n        }\n    }\n    return false\n}\n\nfunc oneAway(a, b string) bool {\n    sum := 0\n    for i := 0; i < len(a); i++ {\n        if a[i] != b[i] {\n            sum++\n        }\n    }\n    return sum == 1\n}\n\nfunc wordLadder(words []string, a, b string) {\n    l := len(a)\n    var poss []string\n    for _, word := range words {\n        if len(word) == l {\n            poss = append(poss, word)\n        }\n    }\n    todo := [][]string{{a}}\n    for len(todo) > 0 {\n        curr := todo[0]\n        todo = todo[1:]\n        var next []string\n        for _, word := range poss {\n            if oneAway(word, curr[len(curr)-1]) {\n                next = append(next, word)\n            }\n        }\n        if contains(next, b) {\n            curr = append(curr, b)\n            fmt.Println(strings.Join(curr, \" -> \"))\n            return\n        }\n        for i := len(poss) - 1; i >= 0; i-- {\n            if contains(next, poss[i]) {\n                copy(poss[i:], poss[i+1:])\n                poss[len(poss)-1] = \"\"\n                poss = poss[:len(poss)-1]\n            }\n        }\n        for _, s := range next {\n            temp := make([]string, len(curr))\n            copy(temp, curr)\n            temp = append(temp, s)\n            todo = append(todo, temp)\n        }\n    }\n    fmt.Println(a, \"into\", b, \"cannot be done.\")\n}\n\nfunc main() {\n    b, err := ioutil.ReadFile(\"unixdict.txt\")\n    if err != nil {\n        log.Fatal(\"Error reading file\")\n    }\n    bwords := bytes.Fields(b)\n    words := make([]string, len(bwords))\n    for i, bword := range bwords {\n        words[i] = string(bword)\n    }\n    pairs := [][]string{\n        {\"boy\", \"man\"},\n        {\"girl\", \"lady\"},\n        {\"john\", \"jane\"},\n        {\"child\", \"adult\"},\n    }\n    for _, pair := range pairs {\n        wordLadder(words, pair[0], pair[1])\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 130,
    "input": "Translate C++ to Java:#include <string>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <sstream>\n\nstd::string mostFreqKHashing ( const std::string & input , int k ) {\n   std::ostringstream oss ;\n   std::map<char, int> frequencies ;\n   for ( char c : input ) {\n      frequencies[ c ] = std::count ( input.begin( ) , input.end( ) , c ) ;\n   }\n   std::vector<std::pair<char , int>> letters ( frequencies.begin( ) , frequencies.end( ) ) ;\n   std::sort ( letters.begin( ) , letters.end( ) , [input] ( std::pair<char, int> a ,\n\t         std::pair<char, int> b ) { char fc = std::get<0>( a ) ; char fs = std::get<0>( b ) ; \n\t         int o = std::get<1>( a ) ; int p = std::get<1>( b ) ; if ( o != p ) { return o > p ; }\n\t         else { return input.find_first_of( fc ) < input.find_first_of ( fs ) ; } } ) ;\n   for ( int i = 0 ; i < letters.size( ) ; i++ ) {\n      oss << std::get<0>( letters[ i ] ) ;\n      oss << std::get<1>( letters[ i ] ) ;\n   }\n   std::string output ( oss.str( ).substr( 0 , 2 * k ) ) ;\n   if ( letters.size( ) >= k ) {\n      return output ;\n   }\n   else {\n      return output.append( \"NULL0\" ) ;\n   }\n}\n\nint mostFreqKSimilarity ( const std::string & first , const std::string & second ) {\n   int i = 0 ;\n   while ( i < first.length( ) - 1  ) {\n      auto found = second.find_first_of( first.substr( i , 2 ) ) ;\n      if ( found != std::string::npos ) \n\t return std::stoi ( first.substr( i , 2 )) ;\n      else \n\t i += 2 ;\n   }\n   return 0 ;\n}\n\nint mostFreqKSDF ( const std::string & firstSeq , const std::string & secondSeq , int num ) {\n   return mostFreqKSimilarity ( mostFreqKHashing( firstSeq , num ) , mostFreqKHashing( secondSeq , num ) ) ;\n}\n\nint main( ) {\n   std::string s1(\"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\" ) ;\n   std::string s2( \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\" ) ;\n   std::cout << \"MostFreqKHashing( s1 , 2 ) = \" << mostFreqKHashing( s1 , 2 ) << '\\n' ;\n   std::cout << \"MostFreqKHashing( s2 , 2 ) = \" << mostFreqKHashing( s2 , 2 ) << '\\n' ;\n   return 0 ;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class SDF {\n\n    \n    public static HashMap<Character, Integer> countElementOcurrences(char[] array) {\n\n        HashMap<Character, Integer> countMap = new HashMap<Character, Integer>();\n\n        for (char element : array) {\n            Integer count = countMap.get(element);\n            count = (count == null) ? 1 : count + 1;\n            countMap.put(element, count);\n        }\n\n        return countMap;\n    }\n    \n    \n    private static <K, V extends Comparable<? super V>>\n            HashMap<K, V> descendingSortByValues(HashMap<K, V> map) { \n\tList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>(map.entrySet());\n\t\n\tCollections.sort(list, new Comparator<Map.Entry<K, V>>() {\n\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n\t\t    return o2.getValue().compareTo(o1.getValue());\n\t\t}\n\t    });\n\n\t\n\t\n\tHashMap<K, V> sortedHashMap = new LinkedHashMap<K, V>();\n\tfor (Map.Entry<K, V> entry : list) {\n\t    sortedHashMap.put(entry.getKey(), entry.getValue());\n\t} \n\treturn sortedHashMap;\n    }\n    \n    public static String mostOcurrencesElement(char[] array, int k) {\n        HashMap<Character, Integer> countMap = countElementOcurrences(array);\n        System.out.println(countMap);\n        Map<Character, Integer> map = descendingSortByValues(countMap); \n        System.out.println(map);\n        int i = 0;\n        String output = \"\";\n        for (Map.Entry<Character, Integer> pairs : map.entrySet()) {\n\t    if (i++ >= k)\n\t\tbreak;\n            output += \"\" + pairs.getKey() + pairs.getValue();\n        }\n        return output;\n    }\n    \n    public static int getDiff(String str1, String str2, int limit) {\n        int similarity = 0;\n\tint k = 0;\n\tfor (int i = 0; i < str1.length() ; i = k) {\n\t    k ++;\n\t    if (Character.isLetter(str1.charAt(i))) {\n\t\tint pos = str2.indexOf(str1.charAt(i));\n\t\t\t\t\n\t\tif (pos >= 0) {\t\n\t\t    String digitStr1 = \"\";\n\t\t    while ( k < str1.length() && !Character.isLetter(str1.charAt(k))) {\n\t\t\tdigitStr1 += str1.charAt(k);\n\t\t\tk++;\n\t\t    }\n\t\t\t\t\t\n\t\t    int k2 = pos+1;\n\t\t    String digitStr2 = \"\";\n\t\t    while (k2 < str2.length() && !Character.isLetter(str2.charAt(k2)) ) {\n\t\t\tdigitStr2 += str2.charAt(k2);\n\t\t\tk2++;\n\t\t    }\n\t\t\t\t\t\n\t\t    similarity += Integer.parseInt(digitStr2)\n\t\t\t+ Integer.parseInt(digitStr1);\n\t\t\t\t\t\n\t\t} \n\t    }\n\t}\n\treturn Math.abs(limit - similarity);\n    }\n    \n    public static int SDFfunc(String str1, String str2, int limit) {\n        return getDiff(mostOcurrencesElement(str1.toCharArray(), 2), mostOcurrencesElement(str2.toCharArray(), 2), limit);\n    }\n\n    public static void main(String[] args) {\n        String input1 = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\";\n        String input2 = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\";\n        System.out.println(SDF.SDFfunc(input1,input2,100));\n\n    }\n\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 131,
    "input": "Translate Java to VB:import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Option Explicit\n\nPrivate Type Aliquot\n   Sequence() As Double\n   Classification As String\nEnd Type\n\nSub Main()\nDim result As Aliquot, i As Long, j As Double, temp As String\n\n   For j = 1 To 10\n      result = Aliq(j)\n      temp = vbNullString\n      For i = 0 To UBound(result.Sequence)\n         temp = temp & result.Sequence(i) & \", \"\n      Next i\n      Debug.Print \"Aliquot seq of \" & j & \" : \" & result.Classification & \"   \" & Left(temp, Len(temp) - 2)\n   Next j\n\nDim a\n   \n   a = Array(11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488)\n   For j = LBound(a) To UBound(a)\n      result = Aliq(CDbl(a(j)))\n      temp = vbNullString\n      For i = 0 To UBound(result.Sequence)\n         temp = temp & result.Sequence(i) & \", \"\n      Next i\n      Debug.Print \"Aliquot seq of \" & a(j) & \" : \" & result.Classification & \"   \" & Left(temp, Len(temp) - 2)\n   Next\nEnd Sub\n\nPrivate Function Aliq(Nb As Double) As Aliquot\nDim s() As Double, i As Long, temp, j As Long, cpt As Long\n   temp = Array(\"non-terminating\", \"Terminate\", \"Perfect\", \"Amicable\", \"Sociable\", \"Aspiring\", \"Cyclic\")\n   ReDim s(0)\n   s(0) = Nb\n   For i = 1 To 15\n      cpt = cpt + 1\n      ReDim Preserve s(cpt)\n      s(i) = SumPDiv(s(i - 1))\n      If s(i) > 140737488355328# Then Exit For\n      If s(i) = 0 Then j = 1\n      If s(1) = s(0) Then j = 2\n      If s(i) = s(0) And i > 1 And i <> 2 Then j = 4\n      If s(i) = s(i - 1) And i > 1 Then j = 5\n      If i >= 2 Then\n         If s(2) = s(0) Then j = 3\n         If s(i) = s(i - 2) And i <> 2 Then j = 6\n      End If\n      If j > 0 Then Exit For\n   Next\n   Aliq.Classification = temp(j)\n   Aliq.Sequence = s\nEnd Function\n\nPrivate Function SumPDiv(n As Double) As Double\n\nDim j As Long, t As Long\n    If n > 1 Then\n        For j = 1 To n \\ 2\n            If n Mod j = 0 Then t = t + j\n        Next\n    End If\n    SumPDiv = t\nEnd Function\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 132,
    "input": "Translate C++ to PHP:#include <iostream>\nusing namespace std ;\n\nint divisor_sum( int number ) { \n   int sum = 0 ; \n   for ( int i = 1 ; i < number ; i++ ) \n      if ( number % i == 0 ) \n         sum += i ; \n   return sum; \n}\n\nint main( ) { \n   cout << \"Perfect numbers from 1 to 33550337:\\n\" ;\n   for ( int num = 1 ; num < 33550337 ; num++ ) { \n      if (divisor_sum(num) == num) \n         cout << num << '\\n' ;\n   }   \n   return 0 ; \n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "function is_perfect($number)\n{\n    $sum = 0;\n    for($i = 1; $i < $number; $i++)\n    {\n        if($number % $i == 0)\n            $sum += $i;\n    }\n    return $sum == $number;\n}\n\necho \"Perfect numbers from 1 to 33550337:\" . PHP_EOL;\nfor($num = 1; $num < 33550337; $num++)\n{\n    if(is_perfect($num))\n        echo $num . PHP_EOL;\n}\n",
    "input_language": "C++",
    "output_language": "PHP"
  },
  {
    "id": 133,
    "input": "Translate C++ to PHP:#include <iostream>\n#include <iterator>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace detail {\n\ntemplate <typename ForwardIterator>\nclass tokenizer\n{\n\t\n\tForwardIterator _tbegin, _tend, _end;\n\t\npublic:\n\t\n\ttokenizer(ForwardIterator begin, ForwardIterator end)\n\t\t: _tbegin(begin), _tend(begin), _end(end)\n\t{ }\n\t\n\ttemplate <typename Lambda>\n\tbool next(Lambda istoken)\n\t{\n\t\tif (_tbegin == _end) {\n\t\t\treturn false;\n\t\t}\n\t\t_tbegin = _tend;\n\t\tfor (; _tend != _end && !istoken(*_tend); ++_tend) {\n\t\t\tif (*_tend == '\\\\' && std::next(_tend) != _end) {\n\t\t\t\t++_tend;\n\t\t\t}\n\t\t}\n\t\tif (_tend == _tbegin) {\n\t\t\t_tend++;\n\t\t}\n\t\treturn _tbegin != _end;\n\t}\n\t\n\tForwardIterator begin() const { return _tbegin; }\n\tForwardIterator end()   const { return _tend; }\n\tbool operator==(char c) { return *_tbegin == c; }\n\t\n};\n\ntemplate <typename List>\nvoid append_all(List & lista, const List & listb)\n{\n\tif (listb.size() == 1) {\n\t\tfor (auto & a : lista) {\n\t\t\ta += listb.back();\n\t\t}\n\t} else {\n\t\tList tmp;\n\t\tfor (auto & a : lista) {\n\t\t\tfor (auto & b : listb) {\n\t\t\t\ttmp.push_back(a + b);\n\t\t\t}\n\t\t}\n\t\tlista = std::move(tmp);\n\t}\n}\n\ntemplate <typename String, typename List, typename Tokenizer>\nList expand(Tokenizer & token)\n{\n\t\n\tstd::vector<List> alts{ { String() } };\n\t\n\twhile (token.next([](char c) { return c == '{' || c == ',' || c == '}'; })) {\n\t\t\n\t\tif (token == '{') {\n\t\t\tappend_all(alts.back(), expand<String, List>(token));\n\t\t} else if (token == ',') {\n\t\t\talts.push_back({ String() });\n\t\t} else if (token == '}') {\n\t\t\tif (alts.size() == 1) {\n\t\t\t\tfor (auto & a : alts.back()) {\n\t\t\t\t\ta = '{' + a + '}';\n\t\t\t\t}\n\t\t\t\treturn alts.back();\n\t\t\t} else {\n\t\t\t\tfor (std::size_t i = 1; i < alts.size(); i++) {\n\t\t\t\t\talts.front().insert(alts.front().end(),\n\t\t\t\t\t\tstd::make_move_iterator(std::begin(alts[i])),\n\t\t\t\t\t\tstd::make_move_iterator(std::end(alts[i])));\n\t\t\t\t}\n\t\t\t\treturn std::move(alts.front());\n\t\t\t}\n\t\t} else {\n\t\t\tfor (auto & a : alts.back()) {\n\t\t\t\ta.append(token.begin(), token.end());\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tList result{ String{ '{' } };\n\tappend_all(result, alts.front());\n\tfor (std::size_t i = 1; i < alts.size(); i++) {\n\t\tfor (auto & a : result) {\n\t\t\ta += ',';\n\t\t}\n\t\tappend_all(result, alts[i]);\n\t}\n\treturn result;\n}\n\n} \n\ntemplate <\n\ttypename ForwardIterator,\n\ttypename String = std::basic_string<\n\t\ttypename std::iterator_traits<ForwardIterator>::value_type\n\t>,\n\ttypename List = std::vector<String>\n>\nList expand(ForwardIterator begin, ForwardIterator end)\n{\n\tdetail::tokenizer<ForwardIterator> token(begin, end);\n\tList list{ String() };\n\twhile (token.next([](char c) { return c == '{'; })) {\n\t\tif (token == '{') {\n\t\t\tdetail::append_all(list, detail::expand<String, List>(token));\n\t\t} else {\n\t\t\tfor (auto & a : list) {\n\t\t\t\ta.append(token.begin(), token.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\ntemplate <\n\ttypename Range,\n\ttypename String = std::basic_string<typename Range::value_type>,\n\ttypename List = std::vector<String>\n>\nList expand(const Range & range)\n{\n\tusing Iterator = typename Range::const_iterator;\n\treturn expand<Iterator, String, List>(std::begin(range), std::end(range));\n}\n\nint main()\n{\n\t\n\tfor (std::string string : {\n\t\tR\"(~/{Downloads,Pictures}/*.{jpg,gif,png})\",\n\t\tR\"(It{{em,alic}iz,erat}e{d,}, please.)\",\n\t\tR\"({,{,gotta have{ ,\\, again\\, }}more }cowbell!)\",\n\t\tR\"({}} some {\\\\{edge,edgy} }{ cases, here\\\\\\})\",\n\t\tR\"(a{b{1,2}c)\",\n\t\tR\"(a{1,2}b}c)\",\n\t\tR\"(a{1,{2},3}b)\",\n\t\tR\"(a{b{1,2}c{}})\",\n\t\tR\"(more{ darn{ cowbell,},})\",\n\t\tR\"(ab{c,d\\,e{f,g\\h},i\\,j{k,l\\,m}n,o\\,p}qr)\",\n\t\tR\"({a,{\\,b}c)\",\n\t\tR\"(a{b,{{c}})\",\n\t\tR\"({a{\\}b,c}d)\",\n\t\tR\"({a,b{{1,2}e}f)\",\n\t\tR\"({}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\})\",\n\t\tR\"({{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{)\",\n\t}) {\n\t\tstd::cout << string << '\\n';\n\t\tfor (auto expansion : expand(string)) {\n\t\t\tstd::cout << \"    \" << expansion << '\\n';\n\t\t}\n\t\tstd::cout << '\\n';\n\t}\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "function getitem($s,$depth=0) {\n    $out = [''];\n    while ($s) {\n        $c = $s[0];\n        if ($depth && ($c == ',' || $c == '}')) {\n            return [$out, $s];\n        }\n        if ($c == '{') {\n            $x = getgroup(substr($s, 1), $depth + 1);\n            if($x) {\n                $tmp = [];\n                foreach($out as $a) {\n                    foreach($x[0] as $b) { \n                        $tmp[] = $a . $b;\n                    }\n                }\n                $out = $tmp;\n                $s = $x[1];\n                continue;\n            }\n        }\n        if ($c == '\\\\' && strlen($s) > 1) {\n            list($s, $c) = [substr($s, 1), ($c . $s[1])];\n        }\n\n        $tmp = [];\n        foreach($out as $a) {\n            $tmp[] = $a . $c;\n        }\n        $out = $tmp;\n        $s = substr($s, 1);\n        \n    }\n    return [$out, $s];\n}\nfunction getgroup($s,$depth) {\n    list($out, $comma) = [[], false];\n    while ($s) {\n        list($g, $s) = getitem($s, $depth);\n        if (!$s) {\n            break;\n        }\n        $out = array_merge($out, $g);\n        if ($s[0] == '}') {\n            if ($comma) {\n                return [$out, substr($s, 1)];\n            }\n\n            $tmp = [];\n            foreach($out as $a) {\n                $tmp[] = '{' . $a . '}';\n            }\n            return [$tmp, substr($s, 1)];\n        }\n        if ($s[0] == ',') {\n            list($comma, $s) = [true, substr($s, 1)];\n        }\n    }\n    return null;\n}\n\n$lines = <<< 'END'\n~/{Downloads,Pictures}/*.{jpg,gif,png}\nIt{{em,alic}iz,erat}e{d,}, please.\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\n{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\nEND;\n\nforeach( explode(\"\\n\", $lines) as $line ) {\n    printf(\"\\n%s\\n\", $line);\n    foreach( getitem($line)[0] as $expansion ) {\n        printf(\"    %s\\n\", $expansion);\n    }\n}\n",
    "input_language": "C++",
    "output_language": "PHP"
  },
  {
    "id": 134,
    "input": "Translate Java to Go:import java.awt.BorderLayout;\nimport java.awt.EventQueue;\nimport java.awt.Frame;\nimport java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.lang.reflect.InvocationTargetException;\nimport javax.swing.AbstractAction;\nimport javax.swing.JButton;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.border.EmptyBorder;\n\npublic class WindowController extends JFrame {\n   \n   public static void main( final String[] args ) {\n      EventQueue.invokeLater( () -> new WindowController() );\n   }\n\n   private JComboBox<ControlledWindow> list;\n\n   \n   private class ControlButton extends JButton {\n      private ControlButton( final String name ) {\n         super(\n            new AbstractAction( name ) {\n               public void actionPerformed( final ActionEvent e ) {\n                  try {\n                     WindowController.class.getMethod( \"do\" + name )\n                        .invoke ( WindowController.this );\n                  } catch ( final Exception x ) { \n                     x.printStackTrace();        \n                  }\n               }\n            }\n         );\n      }\n   }\n\n   \n   public WindowController() {\n      super( \"Controller\" );\n\n      final JPanel main = new JPanel();\n      final JPanel controls = new JPanel();\n\n      setLocationByPlatform( true );\n      setResizable( false );\n      setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );\n      setLayout( new BorderLayout( 3, 3 ) );\n      getRootPane().setBorder( new EmptyBorder( 3, 3, 3, 3 ) );\n      add( new JLabel( \"Add windows and control them.\" ), BorderLayout.NORTH );\n      main.add( list = new JComboBox<>() );\n      add( main, BorderLayout.CENTER );\n      controls.setLayout( new GridLayout( 0, 1, 3, 3 ) );\n      controls.add( new ControlButton( \"Add\"      ) );\n      controls.add( new ControlButton( \"Hide\"     ) );\n      controls.add( new ControlButton( \"Show\"     ) );\n      controls.add( new ControlButton( \"Close\"    ) );\n      controls.add( new ControlButton( \"Maximise\" ) );\n      controls.add( new ControlButton( \"Minimise\" ) );\n      controls.add( new ControlButton( \"Move\"     ) );\n      controls.add( new ControlButton( \"Resize\"   ) );\n      add( controls, BorderLayout.EAST );\n      pack();\n      setVisible( true );\n   }\n\n   \n   private static class ControlledWindow extends JFrame {\n      private int num;\n\n      public ControlledWindow( final int num ) {\n         super( Integer.toString( num ) );\n         this.num = num;\n         setLocationByPlatform( true );\n         getRootPane().setBorder( new EmptyBorder( 3, 3, 3, 3 ) );\n         setDefaultCloseOperation( JFrame.DISPOSE_ON_CLOSE );\n         add( new JLabel( \"I am window \" + num + \". Use the controller to control me.\" ) );\n         pack();\n         setVisible( true );\n      }\n\n      public String toString() {\n         return \"Window \" + num;\n      }\n   }\n\n   \n   \n\n   public void doAdd() {\n      list.addItem( new ControlledWindow( list.getItemCount () + 1 ) );\n      pack();\n   }\n\n   public void doHide() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setVisible( false );\n   }\n\n   public void doShow() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setVisible( true );\n   }\n\n   public void doClose() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.dispose();\n   }\n\n   public void doMinimise() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setState( Frame.ICONIFIED );\n   }\n\n   public void doMaximise() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setExtendedState( Frame.MAXIMIZED_BOTH );\n   }\n\n   public void doMove() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      final int hPos = getInt( \"Horizontal position?\" );\n      if ( -1 == hPos ) {\n         return;\n      }\n      final int vPos = getInt( \"Vertical position?\" );\n      if ( -1 == vPos ) {\n         return;\n      }\n      window.setLocation ( hPos, vPos );\n   }\n\n   public void doResize() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      final int width = getInt( \"Width?\" );\n      if ( -1 == width ) {\n         return;\n      }\n      final int height = getInt( \"Height?\" );\n      if ( -1 == height ) {\n         return;\n      }\n      window.setBounds ( window.getX(), window.getY(), width, height );\n   }\n\n   private JFrame getWindow() {\n      final JFrame window = ( JFrame ) list.getSelectedItem();\n      if ( null == window ) {\n         JOptionPane.showMessageDialog( this, \"Add a window first\" );\n      }\n      return window;\n   }\n\n   private int getInt(final String prompt) {\n      final String s = JOptionPane.showInputDialog( prompt );\n      if ( null == s ) {\n         return -1;\n      }\n      try {\n         return Integer.parseInt( s );\n      } catch ( final NumberFormatException x ) {\n         JOptionPane.showMessageDialog( this, \"Not a number\" );\n         return -1;\n      }\n   }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"github.com/gotk3/gotk3/gtk\"\n    \"log\"\n    \"time\"\n)\n\nfunc check(err error, msg string) {\n    if err != nil {\n        log.Fatal(msg, err)\n    }\n}\n\nfunc main() {\n    gtk.Init(nil)\n\n    window, err := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)\n    check(err, \"Unable to create window:\")\n    window.SetResizable(true)\n    window.SetTitle(\"Window management\")\n    window.SetBorderWidth(5)\n    window.Connect(\"destroy\", func() {\n        gtk.MainQuit()\n    })\n\n    stackbox, err := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 10)\n    check(err, \"Unable to create stack box:\")\n\n    bmax, err := gtk.ButtonNewWithLabel(\"Maximize\")\n    check(err, \"Unable to create maximize button:\")\n    bmax.Connect(\"clicked\", func() {\n        window.Maximize()\n    })\n\n    bunmax, err := gtk.ButtonNewWithLabel(\"Unmaximize\")\n    check(err, \"Unable to create unmaximize button:\")\n    bunmax.Connect(\"clicked\", func() {\n        window.Unmaximize()\n    })\n\n    bicon, err := gtk.ButtonNewWithLabel(\"Iconize\")\n    check(err, \"Unable to create iconize button:\")\n    bicon.Connect(\"clicked\", func() {\n        window.Iconify()\n    })\n\n    bdeicon, err := gtk.ButtonNewWithLabel(\"Deiconize\")\n    check(err, \"Unable to create deiconize button:\")\n    bdeicon.Connect(\"clicked\", func() {\n        window.Deiconify()\n    })\n\n    bhide, err := gtk.ButtonNewWithLabel(\"Hide\")\n    check(err, \"Unable to create hide button:\")\n    bhide.Connect(\"clicked\", func() {\n        \n        window.Hide() \n        time.Sleep(10 * time.Second)\n        window.Show()\n    })\n\n    bshow, err := gtk.ButtonNewWithLabel(\"Show\")\n    check(err, \"Unable to create show button:\")\n    bshow.Connect(\"clicked\", func() {\n        window.Show()\n    })\n\n    bmove, err := gtk.ButtonNewWithLabel(\"Move\")\n    check(err, \"Unable to create move button:\")\n    isShifted := false\n    bmove.Connect(\"clicked\", func() {\n        w, h := window.GetSize()\n        if isShifted {\n            window.Move(w-10, h-10)\n        } else {\n            window.Move(w+10, h+10)\n        }\n        isShifted = !isShifted\n    })\n\n    bquit, err := gtk.ButtonNewWithLabel(\"Quit\")\n    check(err, \"Unable to create quit button:\")\n    bquit.Connect(\"clicked\", func() {\n        window.Destroy()\n    })\n\n    stackbox.PackStart(bmax, true, true, 0)\n    stackbox.PackStart(bunmax, true, true, 0)\n    stackbox.PackStart(bicon, true, true, 0)\n    stackbox.PackStart(bdeicon, true, true, 0)\n    stackbox.PackStart(bhide, true, true, 0)\n    stackbox.PackStart(bshow, true, true, 0)\n    stackbox.PackStart(bmove, true, true, 0)\n    stackbox.PackStart(bquit, true, true, 0)\n\n    window.Add(stackbox)\n    window.ShowAll()\n    gtk.Main()\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 135,
    "input": "Translate C++ to C#:#include <iostream>\n\nint main()\n{\n  int a, b;\n  std::cin >> a >> b;\n  std::cout << \"a+b = \" << a+b << \"\\n\";\n  std::cout << \"a-b = \" << a-b << \"\\n\";\n  std::cout << \"a*b = \" << a*b << \"\\n\";\n  std::cout << \"a/b = \" << a/b << \", remainder \" << a%b << \"\\n\";\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0} % {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 136,
    "input": "Translate C to VB:#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define strcomp(X, Y) strcasecmp(X, Y)\n\nstruct option\n{ const char *name, *value; \n  int flag; };\n\n\nstruct option updlist[] =\n{ { \"NEEDSPEELING\", NULL },\n  { \"SEEDSREMOVED\", \"\" },\n  { \"NUMBEROFBANANAS\", \"1024\" },\n  { \"NUMBEROFSTRAWBERRIES\", \"62000\" },\n  { NULL, NULL } };\n\nint output_opt(FILE *to, struct option *opt)\n{ if (opt->value == NULL)\n    return fprintf(to, \"; %s\\n\", opt->name);\n  else if (opt->value[0] == 0)\n    return fprintf(to, \"%s\\n\", opt->name);\n  else \n    return fprintf(to, \"%s %s\\n\", opt->name, opt->value); }\n\nint update(FILE *from, FILE *to, struct option *updlist) \n{ char line_buf[256], opt_name[128];\n  int i;\n  for (;;)\n  { size_t len, space_span, span_to_hash;\n    if (fgets(line_buf, sizeof line_buf, from) == NULL)\n      break;\n    len = strlen(line_buf);\n    space_span = strspn(line_buf, \"\\t \");\n    span_to_hash = strcspn(line_buf, \"#\");\n    if (space_span == span_to_hash)\n      goto line_out;\n    if (space_span == len)\n      goto line_out;\n    if ((sscanf(line_buf, \"; %127s\", opt_name) == 1) ||\n        (sscanf(line_buf, \"%127s\", opt_name) == 1))\n    { int flag = 0;\n      for (i = 0; updlist[i].name; i++)\n      { if (strcomp(updlist[i].name, opt_name) == 0)\n        { if (output_opt(to, &updlist[i]) < 0)\n            return -1;\n          updlist[i].flag = 1;\n          flag = 1; } }\n      if (flag == 0)\n        goto line_out; }\n    else\n  line_out: \n      if (fprintf(to, \"%s\", line_buf) < 0)\n        return -1;\n    continue; }\n  { for (i = 0; updlist[i].name; i++)\n    { if (!updlist[i].flag)\n        if (output_opt(to, &updlist[i]) < 0)\n          return -1; } }\n  return feof(from) ? 0 : -1; }\n\nint main(void)\n{ if (update(stdin, stdout, updlist) < 0)\n  { fprintf(stderr, \"failed\\n\");\n    return (EXIT_FAILURE); }\n  return 0; }\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Set objFSO = CreateObject(\"Scripting.FileSystemObject\")\n\n\nSet objParamLookup = CreateObject(\"Scripting.Dictionary\")\nWith objParamLookup\n\t.Add \"FAVOURITEFRUIT\", \"banana\"\n\t.Add \"NEEDSPEELING\", \"\"\n\t.Add \"SEEDSREMOVED\", \"\"\n\t.Add \"NUMBEROFBANANAS\", \"1024\"\n\t.Add \"NUMBEROFSTRAWBERRIES\", \"62000\"\nEnd With \n\n\nSet objInFile = objFSO.OpenTextFile(objFSO.GetParentFolderName(WScript.ScriptFullName) &_\n\t\"\\IN_config.txt\",1)\n\nOutput = \"\"\t\nIsnumberofstrawberries = False\nWith objInFile\n\tDo Until .AtEndOfStream\n\t\tline = .ReadLine\n\t\tIf Left(line,1) = \"#\" Or line = \"\" Then\n\t\t\tOutput = Output & line & vbCrLf\n\t\tElseIf Left(line,1) = \" \" And InStr(line,\"#\") Then\n\t\t\tOutput = Output & Mid(line,InStr(1,line,\"#\"),1000) & vbCrLf\n\t\tElseIf Replace(Replace(line,\";\",\"\"),\" \",\"\") <> \"\" Then\n\t\t\tIf InStr(1,line,\"FAVOURITEFRUIT\",1) Then\n\t\t\t\tOutput = Output & \"FAVOURITEFRUIT\" & \" \" & objParamLookup.Item(\"FAVOURITEFRUIT\") & vbCrLf\n\t\t\tElseIf InStr(1,line,\"NEEDSPEELING\",1) Then\n\t\t\t\tOutput = Output & \"; \" & \"NEEDSPEELING\" & vbCrLf\n\t\t\tElseIf InStr(1,line,\"SEEDSREMOVED\",1) Then\n\t\t\t\tOutput = Output & \"SEEDSREMOVED\" & vbCrLf\n\t\t\tElseIf InStr(1,line,\"NUMBEROFBANANAS\",1) Then\n\t\t\t\tOutput = Output & \"NUMBEROFBANANAS\" & \" \" & objParamLookup.Item(\"NUMBEROFBANANAS\") & vbCrLf\n\t\t\tElseIf InStr(1,line,\"NUMBEROFSTRAWBERRIES\",1) Then\n\t\t\t\tOutput = Output & \"NUMBEROFSTRAWBERRIES\" & \" \" & objParamLookup.Item(\"NUMBEROFSTRAWBERRIES\") & vbCrLf\n\t\t\t\tIsnumberofstrawberries = True\n\t\t\tEnd If\n\t\tEnd If\n\tLoop\n\tIf Isnumberofstrawberries = False Then\n\t\tOutput = Output & \"NUMBEROFSTRAWBERRIES\" & \" \" & objParamLookup.Item(\"NUMBEROFSTRAWBERRIES\") & vbCrLf\n\t\tIsnumberofstrawberries = True\n\tEnd If\n\t.Close\nEnd With\n\t\n\nSet objOutFile = objFSO.OpenTextFile(objFSO.GetParentFolderName(WScript.ScriptFullName) &_\n\t\"\\OUT_config.txt\",2,True)\nWith objOutFile\n\t.Write Output\n\t.Close\nEnd With\n\nSet objFSO = Nothing\nSet objParamLookup = Nothing\n",
    "input_language": "C",
    "output_language": "VB"
  },
  {
    "id": 137,
    "input": "Translate Java to Python:if (s == 'Hello World') {\n    foo();\n} else if (s == 'Bye World') {\n    bar();\n} else {\n    deusEx();\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "if x == 0:\n    foo()\nelif x == 1:\n    bar()\nelif x == 2:\n    baz()\nelse:\n    qux()\n\nmatch x:\n    0 => foo()\n    1 => bar()\n    2 => baz()\n    _ => qux()\n\n(a) ? b : c\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 138,
    "input": "Translate C to Java:#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define strcomp(X, Y) strcasecmp(X, Y)\n\nstruct option\n{ const char *name, *value; \n  int flag; };\n\n\nstruct option updlist[] =\n{ { \"NEEDSPEELING\", NULL },\n  { \"SEEDSREMOVED\", \"\" },\n  { \"NUMBEROFBANANAS\", \"1024\" },\n  { \"NUMBEROFSTRAWBERRIES\", \"62000\" },\n  { NULL, NULL } };\n\nint output_opt(FILE *to, struct option *opt)\n{ if (opt->value == NULL)\n    return fprintf(to, \"; %s\\n\", opt->name);\n  else if (opt->value[0] == 0)\n    return fprintf(to, \"%s\\n\", opt->name);\n  else \n    return fprintf(to, \"%s %s\\n\", opt->name, opt->value); }\n\nint update(FILE *from, FILE *to, struct option *updlist) \n{ char line_buf[256], opt_name[128];\n  int i;\n  for (;;)\n  { size_t len, space_span, span_to_hash;\n    if (fgets(line_buf, sizeof line_buf, from) == NULL)\n      break;\n    len = strlen(line_buf);\n    space_span = strspn(line_buf, \"\\t \");\n    span_to_hash = strcspn(line_buf, \"#\");\n    if (space_span == span_to_hash)\n      goto line_out;\n    if (space_span == len)\n      goto line_out;\n    if ((sscanf(line_buf, \"; %127s\", opt_name) == 1) ||\n        (sscanf(line_buf, \"%127s\", opt_name) == 1))\n    { int flag = 0;\n      for (i = 0; updlist[i].name; i++)\n      { if (strcomp(updlist[i].name, opt_name) == 0)\n        { if (output_opt(to, &updlist[i]) < 0)\n            return -1;\n          updlist[i].flag = 1;\n          flag = 1; } }\n      if (flag == 0)\n        goto line_out; }\n    else\n  line_out: \n      if (fprintf(to, \"%s\", line_buf) < 0)\n        return -1;\n    continue; }\n  { for (i = 0; updlist[i].name; i++)\n    { if (!updlist[i].flag)\n        if (output_opt(to, &updlist[i]) < 0)\n          return -1; } }\n  return feof(from) ? 0 : -1; }\n\nint main(void)\n{ if (update(stdin, stdout, updlist) < 0)\n  { fprintf(stderr, \"failed\\n\");\n    return (EXIT_FAILURE); }\n  return 0; }\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class UpdateConfig {\n\n    public static void main(String[] args) {\n        if (args[0] == null) {\n            System.out.println(\"filename required\");\n\n        } else if (readConfig(args[0])) {\n            enableOption(\"seedsremoved\");\n            disableOption(\"needspeeling\");\n            setOption(\"numberofbananas\", \"1024\");\n            addOption(\"numberofstrawberries\", \"62000\");\n            store();\n        }\n    }\n\n    private enum EntryType {\n        EMPTY, ENABLED, DISABLED, COMMENT\n    }\n\n    private static class Entry {\n        EntryType type;\n        String name, value;\n\n        Entry(EntryType t, String n, String v) {\n            type = t;\n            name = n;\n            value = v;\n        }\n    }\n\n    private static Map<String, Entry> entries = new LinkedHashMap<>();\n    private static String path;\n\n    private static boolean readConfig(String p) {\n        path = p;\n\n        File f = new File(path);\n        if (!f.exists() || f.isDirectory())\n            return false;\n\n        String regexString = \"^(;*)\\\\s*([A-Za-z0-9]+)\\\\s*([A-Za-z0-9]*)\";\n        Pattern regex = Pattern.compile(regexString);\n\n        try (Scanner sc = new Scanner(new FileReader(f))){\n            int emptyLines = 0;\n            String line;\n            while (sc.hasNext()) {\n                line = sc.nextLine().trim();\n\n                if (line.isEmpty()) {\n                    addOption(\"\" + emptyLines++, null, EntryType.EMPTY);\n\n                } else if (line.charAt(0) == '#') {\n                    entries.put(line, new Entry(EntryType.COMMENT, line, null));\n\n                } else {\n                    line = line.replaceAll(\"[^a-zA-Z0-9\\\\x20;]\", \"\");\n                    Matcher m = regex.matcher(line);\n\n                    if (m.find() && !m.group(2).isEmpty()) {\n\n                        EntryType t = EntryType.ENABLED;\n                        if (!m.group(1).isEmpty())\n                            t = EntryType.DISABLED;\n\n                        addOption(m.group(2), m.group(3), t);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return true;\n    }\n\n    private static void addOption(String name, String value) {\n        addOption(name, value, EntryType.ENABLED);\n    }\n\n    private static void addOption(String name, String value, EntryType t) {\n        name = name.toUpperCase();\n        entries.put(name, new Entry(t, name, value));\n    }\n\n    private static void enableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.ENABLED;\n    }\n\n    private static void disableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.DISABLED;\n    }\n\n    private static void setOption(String name, String value) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.value = value;\n    }\n\n    private static void store() {\n        try (PrintWriter pw = new PrintWriter(path)) {\n            for (Entry e : entries.values()) {\n                switch (e.type) {\n                    case EMPTY:\n                        pw.println();\n                        break;\n                    case ENABLED:\n                        pw.format(\"%s %s%n\", e.name, e.value);\n                        break;\n                    case DISABLED:\n                        pw.format(\"; %s %s%n\", e.name, e.value);\n                        break;\n                    case COMMENT:\n                        pw.println(e.name);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (pw.checkError()) {\n                throw new IOException(\"writing to file failed\");\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 139,
    "input": "Translate C to VB:#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <curses.h>\n#include <string.h>\n\n#define MAX_NUM_TRIES 72\n#define LINE_BEGIN 7\n#define LAST_LINE 18\n\nint yp=LINE_BEGIN, xp=0;\n\nchar number[5];\nchar guess[5];\n\n#define MAX_STR 256\nvoid mvaddstrf(int y, int x, const char *fmt, ...)\n{\n  va_list args;\n  char buf[MAX_STR];\n  \n  va_start(args, fmt);\n  vsprintf(buf, fmt, args);\n  move(y, x);\n  clrtoeol();\n  addstr(buf);\n  va_end(args);\n}\n\nvoid ask_for_a_number()\n{\n  int i=0;\n  char symbols[] = \"123456789\";\n\n  move(5,0); clrtoeol();\n  addstr(\"Enter four digits: \");\n  while(i<4) {\n    int c = getch();\n    if ( (c >= '1') && (c <= '9') && (symbols[c-'1']!=0) ) {\n      addch(c);\n      symbols[c-'1'] = 0;\n      guess[i++] = c;\n    }\n  }\n}\n\nvoid choose_the_number()\n{\n  int i=0, j;\n  char symbols[] = \"123456789\";\n\n  while(i<4) {\n    j = rand() % 9;\n    if ( symbols[j] != 0 ) {\n      number[i++] = symbols[j];\n      symbols[j] = 0;\n    }\n  }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Option Explicit\n\nSub Main_Bulls_and_cows()\nDim strNumber As String, strInput As String, strMsg As String, strTemp As String\nDim boolEnd As Boolean\nDim lngCpt As Long\nDim i As Byte, bytCow As Byte, bytBull As Byte\nConst NUMBER_OF_DIGITS As Byte = 4\nConst MAX_LOOPS As Byte = 25 \n\n    strNumber = Create_Number(NUMBER_OF_DIGITS)\n    Do\n        bytBull = 0: bytCow = 0: lngCpt = lngCpt + 1\n        If lngCpt > MAX_LOOPS Then strMsg = \"Max of loops... Sorry you loose!\": Exit Do\n        strInput = AskToUser(NUMBER_OF_DIGITS)\n        If strInput = \"Exit Game\" Then strMsg = \"User abort\": Exit Do\n        For i = 1 To Len(strNumber)\n            If Mid(strNumber, i, 1) = Mid(strInput, i, 1) Then\n                bytBull = bytBull + 1\n            ElseIf InStr(strNumber, Mid(strInput, i, 1)) > 0 Then\n                bytCow = bytCow + 1\n            End If\n        Next i\n        If bytBull = Len(strNumber) Then\n            boolEnd = True: strMsg = \"You win in \" & lngCpt & \" loops!\"\n        Else\n            strTemp = strTemp & vbCrLf & \"With : \" & strInput & \" ,you have : \" & bytBull & \" bulls,\" & bytCow & \" cows.\"\n            MsgBox strTemp\n        End If\n    Loop While Not boolEnd\n    MsgBox strMsg\nEnd Sub\n\nFunction Create_Number(NbDigits As Byte) As String\nDim myColl As New Collection\nDim strTemp As String\nDim bytAlea As Byte\n\n    Randomize\n    Do\n        bytAlea = Int((Rnd * 9) + 1)\n        On Error Resume Next\n        myColl.Add CStr(bytAlea), CStr(bytAlea)\n        If Err <> 0 Then\n            On Error GoTo 0\n        Else\n            strTemp = strTemp & CStr(bytAlea)\n        End If\n    Loop While Len(strTemp) < NbDigits\n    Create_Number = strTemp\nEnd Function\n\nFunction AskToUser(NbDigits As Byte) As String\nDim boolGood As Boolean, strIn As String, i As Byte, NbDiff As Byte\n\n    Do While Not boolGood\n        strIn = InputBox(\"Enter your number (\" & NbDigits & \" digits)\", \"Number\")\n        If StrPtr(strIn) = 0 Then strIn = \"Exit Game\": Exit Do\n        If strIn <> \"\" Then\n            If Len(strIn) = NbDigits Then\n                NbDiff = 0\n                For i = 1 To Len(strIn)\n                    If Len(Replace(strIn, Mid(strIn, i, 1), \"\")) < NbDigits - 1 Then\n                        NbDiff = 1\n                        Exit For\n                    End If\n                Next i\n                If NbDiff = 0 Then boolGood = True\n            End If\n        End If\n    Loop\n    AskToUser = strIn\nEnd Function\n",
    "input_language": "C",
    "output_language": "VB"
  },
  {
    "id": 140,
    "input": "Translate Java to C#:import java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] a) {\n        for (int n = 2; n < 6; n++)\n            unity(n);\n    }\n\n    public static void unity(int n) {\n        System.out.printf(\"%n%d: \", n);\n\n        \n        for (double angle = 0; angle < 2 * Math.PI; angle += (2 * Math.PI) / n) {\n\n            double real = Math.cos(angle); \n\n            if (Math.abs(real) < 1.0E-3)\n                real = 0.0; \n\n            double imag = Math.sin(angle); \n\n            if (Math.abs(imag) < 1.0E-3)\n                imag = 0.0;\n\n            System.out.printf(Locale.US, \"(%9f,%9f) \", real, imag);\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nclass Program\n{\n    static IEnumerable<Complex> RootsOfUnity(int degree)\n    {\n        return Enumerable\n            .Range(0, degree)\n            .Select(element => Complex.FromPolarCoordinates(1, 2 * Math.PI * element / degree));\n    }\n\n    static void Main()\n    {\n        var degree = 3;\n        foreach (var root in RootsOfUnity(degree))\n        {\n            Console.WriteLine(root);\n        }\n    }\n}\n",
    "input_language": "Java",
    "output_language": "C#"
  },
  {
    "id": 141,
    "input": "Translate C to C++:#include <stdio.h>\n#include <math.h>\n\n#define C 7\ntypedef struct { double x, y; } pt;\n\npt zero(void) { return (pt){ INFINITY, INFINITY }; }\n\n\nint is_zero(pt p) { return p.x > 1e20 || p.x < -1e20; }\n\npt neg(pt p) { return (pt){ p.x, -p.y }; }\n\npt dbl(pt p) {\n\tif (is_zero(p)) return p;\n\n\tpt r;\n\tdouble L = (3 * p.x * p.x) / (2 * p.y);\n\tr.x = L * L - 2 * p.x;\n\tr.y = L * (p.x - r.x) - p.y;\n\treturn r;\n}\n\npt add(pt p, pt q) {\n\tif (p.x == q.x && p.y == q.y) return dbl(p);\n\tif (is_zero(p)) return q;\n\tif (is_zero(q)) return p;\n\n\tpt r;\n\tdouble L = (q.y - p.y) / (q.x - p.x);\n\tr.x = L * L - p.x - q.x;\n\tr.y = L * (p.x - r.x) - p.y;\n\treturn r;\n}\n\npt mul(pt p, int n) {\n\tint i;\n\tpt r = zero();\n\n\tfor (i = 1; i <= n; i <<= 1) {\n\t\tif (i & n) r = add(r, p);\n\t\tp = dbl(p);\n\t}\n\treturn r;\n}\n\nvoid show(const char *s, pt p) {\n\tprintf(\"%s\", s);\n\tprintf(is_zero(p) ? \"Zero\\n\" : \"(%.3f, %.3f)\\n\", p.x, p.y);\n}\n\npt from_y(double y) {\n\tpt r;\n\tr.x = pow(y * y - C, 1.0/3);\n\tr.y = y;\n\treturn r;\n}\n\nint main(void) {\n\tpt a, b, c, d;\n\n\ta = from_y(1);\n\tb = from_y(2);\n\n\tshow(\"a = \", a);\n\tshow(\"b = \", b);\n\tshow(\"c = a + b = \", c = add(a, b));\n\tshow(\"d = -c = \", d = neg(c));\n\tshow(\"c + d = \", add(c, d));\n\tshow(\"a + b + d = \", add(a, add(b, d)));\n\tshow(\"a * 12345 = \", mul(a, 12345));\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\n\n\nclass EllipticPoint\n{\n    double m_x, m_y;\n    static constexpr double ZeroThreshold = 1e20;\n    static constexpr double B = 7; \n                                  \n    \n    void Double() noexcept\n    {\n        if(IsZero())\n        {\n            \n            return;\n        }\n        \n        \n        \n        if(m_y == 0)\n        {\n            \n            \n            *this = EllipticPoint();\n        }\n        else\n        {\n            double L = (3 * m_x * m_x) / (2 * m_y);\n            double newX = L * L -  2 * m_x;\n            m_y = L * (m_x - newX) - m_y;\n            m_x = newX;\n        }\n    }\n    \npublic:\n    friend std::ostream& operator<<(std::ostream&, const EllipticPoint&);\n\n    \n    constexpr EllipticPoint() noexcept : m_x(0), m_y(ZeroThreshold * 1.01) {}\n\n    \n    \n    explicit EllipticPoint(double yCoordinate) noexcept\n    {\n        m_y = yCoordinate;\n        m_x = cbrt(m_y * m_y - B);\n    }\n\n    \n    bool IsZero() const noexcept\n    {\n        \n        bool isNotZero =  abs(m_y) < ZeroThreshold;\n        return !isNotZero;\n    }\n\n    \n    EllipticPoint operator-() const noexcept\n    {\n        EllipticPoint negPt;\n        negPt.m_x = m_x;\n        negPt.m_y = -m_y;\n        \n        return negPt;\n    }\n\n    \n    EllipticPoint& operator+=(const EllipticPoint& rhs) noexcept\n    {\n        if(IsZero())\n        {\n            *this = rhs;\n        }\n        else if (rhs.IsZero())\n        {\n            \n            \n        }\n        else\n        {\n            double L = (rhs.m_y - m_y) / (rhs.m_x - m_x);\n            if(isfinite(L))\n            {\n                double newX = L * L - m_x - rhs.m_x;\n                m_y = L * (m_x - newX) - m_y;\n                m_x = newX;\n            }\n            else\n            {\n                if(signbit(m_y) != signbit(rhs.m_y))\n                {\n                    \n                    *this = EllipticPoint();\n                }\n                else\n                {\n                    \n                    Double();\n                }\n            }\n        }\n\n        return *this;\n    }\n\n    \n    EllipticPoint& operator-=(const EllipticPoint& rhs) noexcept\n    {\n        *this+= -rhs;\n        return *this;\n    }\n    \n    \n    EllipticPoint& operator*=(int rhs) noexcept\n    {\n        EllipticPoint r;\n        EllipticPoint p = *this;\n\n        if(rhs < 0)\n        {\n            \n            rhs = -rhs;\n            p = -p;\n        }\n        \n        for (int i = 1; i <= rhs; i <<= 1) \n        {\n            if (i & rhs) r += p;\n            p.Double();\n        }\n\n        *this = r;\n        return *this;\n    }\n};\n\n\ninline EllipticPoint operator+(EllipticPoint lhs, const EllipticPoint& rhs) noexcept\n{\n    lhs += rhs;\n    return lhs;\n}\n\n\ninline EllipticPoint operator-(EllipticPoint lhs, const EllipticPoint& rhs) noexcept\n{\n    lhs += -rhs;\n    return lhs;\n}\n\n\ninline EllipticPoint operator*(EllipticPoint lhs, const int rhs) noexcept\n{\n    lhs *= rhs;\n    return lhs;\n}\n\n\ninline EllipticPoint operator*(const int lhs, EllipticPoint rhs) noexcept\n{\n    rhs *= lhs;\n    return rhs;\n}\n\n\n\nostream& operator<<(ostream& os, const EllipticPoint& pt)\n{\n    if(pt.IsZero()) cout << \"(Zero)\\n\";\n    else cout << \"(\" << pt.m_x << \", \" << pt.m_y << \")\\n\";\n    return os;\n}\n\nint main(void) {\n    const EllipticPoint a(1), b(2);\n    cout << \"a = \" << a;\n    cout << \"b = \" << b;\n    const EllipticPoint c = a + b;\n    cout << \"c = a + b = \"       << c;\n    cout << \"a + b - c = \"       << a + b - c;\n    cout << \"a + b - (b + a) = \" << a + b - (b + a) << \"\\n\";\n\n    cout << \"a + a + a + a + a - 5 * a = \"         << a + a + a + a + a - 5 * a;\n    cout << \"a * 12345 = \"                         << a * 12345;\n    cout << \"a * -12345 = \"                        << a * -12345;\n    cout << \"a * 12345 + a * -12345 = \"            << a * 12345 + a * -12345;\n    cout << \"a * 12345 - (a * 12000 + a * 345) = \" << a * 12345 - (a * 12000 + a * 345);\n    cout << \"a * 12345 - (a * 12001 + a * 345) = \" << a * 12345 - (a * 12000 + a * 344) << \"\\n\";\n\n    const EllipticPoint zero;\n    EllipticPoint g;\n    cout << \"g = zero = \"      << g;\n    cout << \"g += a = \"        << (g+=a);\n    cout << \"g += zero = \"     << (g+=zero);\n    cout << \"g += b = \"        << (g+=b);\n    cout << \"b + b - b * 2 = \" << (b + b - b * 2) << \"\\n\";\n\n    EllipticPoint special(0);  \n    cout << \"special = \"      << special; \n    cout << \"special *= 2 = \" << (special*=2); \n    \n    return 0;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 142,
    "input": "Translate C to Java:#include <stdio.h>\n#include <stdlib.h>\n\nstruct replace_info {\n    int n;\n    char *text;\n};\n\nint compare(const void *a, const void *b)\n{\n    struct replace_info *x = (struct replace_info *) a;\n    struct replace_info *y = (struct replace_info *) b;\n    return x->n - y->n;\n}\n\nvoid generic_fizz_buzz(int max, struct replace_info *info, int info_length)\n{\n    int i, it;\n    int found_word;\n\n    for (i = 1; i < max; ++i) {\n        found_word = 0;\n\n        \n        for (it = 0; it < info_length; ++it) {\n            if (0 == i % info[it].n) {\n                printf(\"%s\", info[it].text);\n                found_word = 1;\n            }\n        }\n\n        if (0 == found_word)\n            printf(\"%d\", i);\n\n        printf(\"\\n\");\n    }\n}\n\nint main(void)\n{\n    struct replace_info info[3] = {\n        {5, \"Buzz\"},\n        {7, \"Baxx\"},\n        {3, \"Fizz\"}\n    };\n\n    \n    qsort(info, 3, sizeof(struct replace_info), compare);\n\n    \n    generic_fizz_buzz(20, info, 3);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class FizzBuzz {\n\n    public static void main(String[] args) {\n        Sound[] sounds = {new Sound(3, \"Fizz\"), new Sound(5, \"Buzz\"),  new Sound(7, \"Baxx\")};\n        for (int i = 1; i <= 20; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (Sound sound : sounds) {\n                sb.append(sound.generate(i));\n            }\n            System.out.println(sb.length() == 0 ? i : sb.toString());\n        }\n    }\n\n    private static class Sound {\n        private final int trigger;\n        private final String onomatopoeia;\n\n        public Sound(int trigger, String onomatopoeia) {\n            this.trigger = trigger;\n            this.onomatopoeia = onomatopoeia;\n        }\n\n        public String generate(int i) {\n            return i % trigger == 0 ? onomatopoeia : \"\";\n        }\n\n    }\n\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 143,
    "input": "Translate PHP to Go:<?php\nfile_put_contents('/dev/lp0', 'Hello world!');\n?>\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tlp0, err := os.Create(\"/dev/lp0\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer lp0.Close()\n\n\tfmt.Fprintln(lp0, \"Hello World!\")\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 144,
    "input": "Translate C++ to VB:#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\n\n\nsize_t consonants(const std::string& word) {\n    std::bitset<26> bits;\n    size_t bit = 0;\n    for (char ch : word) {\n        ch = std::tolower(static_cast<unsigned char>(ch));\n        if (ch < 'a' || ch > 'z')\n            continue;\n        switch (ch) {\n        case 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n        case 'u':\n            break;\n        default:\n            bit = ch - 'a';\n            if (bits.test(bit))\n                return 0;\n            bits.set(bit);\n            break;\n        }\n    }\n    return bits.count();\n}\n\nint main(int argc, char** argv) {\n    const char* filename(argc < 2 ? \"unixdict.txt\" : argv[1]);\n    std::ifstream in(filename);\n    if (!in) {\n        std::cerr << \"Cannot open file '\" << filename << \"'.\\n\";\n        return EXIT_FAILURE;\n    }\n    std::string word;\n    std::map<size_t, std::vector<std::string>, std::greater<int>> map;\n    while (getline(in, word)) {\n        if (word.size() <= 10)\n            continue;\n        size_t count = consonants(word);\n        if (count != 0)\n            map[count].push_back(word);\n    }\n    const int columns = 4;\n    for (const auto& p : map) {\n        std::cout << p.first << \" consonants (\" << p.second.size() << \"):\\n\";\n        int n = 0;\n        for (const auto& word : p.second) {\n            std::cout << std::left << std::setw(18) << word;\n            ++n;\n            if (n % columns == 0)\n                std::cout << '\\n';\n        }\n        if (n % columns != 0)\n            std::cout << '\\n';\n        std::cout << '\\n';\n    }\n    return EXIT_SUCCESS;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "with createobject(\"ADODB.Stream\")\n  .charset =\"UTF-8\"\n  .open\n  .loadfromfile(\"unixdict.txt\")\n  s=.readtext\nend with  \na=split (s,vblf)\n\ndim b(25)  \ndim c(128) \n\nwith new regexp\n  .pattern=\"([^aeiou])\"\n  .global=true\nfor each i in a\n  if len(trim(i))>10 then\n   set matches= .execute(i)   \n   rep=false\n   for each m in matches  \n     x=asc(m)  \n     c(x)=c(x)+1\n     if c(x)>1 then rep=true :exit for\n   next\n   erase c\n   if not rep then   \n     x1=matches.count\n     b(x1)=b(x1)&\" \"&i  \n   end if    \n  end if\nnext\nend with \n\n\nfor i=25 to 0 step -1\n  if b(i)<>\"\" then  wscript.echo i & \"  \"& b(i) & vbcrlf\nnext\n",
    "input_language": "C++",
    "output_language": "VB"
  },
  {
    "id": 145,
    "input": "Translate Python to Go:import copy, random\n\ndef bitcount(n):\n    return bin(n).count(\"1\")\n\ndef reoderingSign(i, j):\n    k = i >> 1\n    sum = 0\n    while k != 0:\n        sum += bitcount(k & j)\n        k = k >> 1\n    return 1.0 if ((sum & 1) == 0) else -1.0\n\nclass Vector:\n    def __init__(self, da):\n        self.dims = da\n\n    def dot(self, other):\n        return (self * other + other * self) * 0.5\n\n    def __getitem__(self, i):\n        return self.dims[i]\n\n    def __setitem__(self, i, v):\n        self.dims[i] = v\n\n    def __neg__(self):\n        return self * -1.0\n\n    def __add__(self, other):\n        result = copy.copy(other.dims)\n        for i in xrange(0, len(self.dims)):\n            result[i] += self.dims[i]\n        return Vector(result)\n\n    def __mul__(self, other):\n        if isinstance(other, Vector):\n            result = [0.0] * 32\n            for i in xrange(0, len(self.dims)):\n                if self.dims[i] != 0.0:\n                    for j in xrange(0, len(self.dims)):\n                        if other.dims[j] != 0.0:\n                            s = reoderingSign(i, j) * self.dims[i] * other.dims[j]\n                            k = i ^ j\n                            result[k] += s\n            return Vector(result)\n        else:\n            result = copy.copy(self.dims)\n            for i in xrange(0, len(self.dims)):\n                self.dims[i] *= other\n            return Vector(result)\n\n    def __str__(self):\n        return str(self.dims)\n\ndef e(n):\n    assert n <= 4, \"n must be less than 5\"\n    result = Vector([0.0] * 32)\n    result[1 << n] = 1.0\n    return result\n\ndef randomVector():\n    result = Vector([0.0] * 32)\n    for i in xrange(0, 5):\n        result += Vector([random.uniform(0, 1)]) * e(i)\n    return result\n\ndef randomMultiVector():\n    result = Vector([0.0] * 32)\n    for i in xrange(0, 32):\n        result[i] = random.uniform(0, 1)\n    return result\n\ndef main():\n    for i in xrange(0, 5):\n        for j in xrange(0, 5):\n            if i < j:\n                if e(i).dot(e(j))[0] != 0.0:\n                    print \"Unexpected non-null scalar product\"\n                    return\n                elif i == j:\n                    if e(i).dot(e(j))[0] == 0.0:\n                        print \"Unexpected non-null scalar product\"\n\n    a = randomMultiVector()\n    b = randomMultiVector()\n    c = randomMultiVector()\n    x = randomVector()\n\n    \n    print (a * b) * c\n    print a * (b * c)\n    print\n\n    \n    print a * (b + c)\n    print a * b + a * c\n    print\n\n    \n    print (a + b) * c\n    print a * c + b * c\n    print\n\n    \n    print x * x\n\nmain()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\ntype vector []float64\n\nfunc e(n uint) vector {\n    if n > 4 {\n        panic(\"n must be less than 5\")\n    }\n    result := make(vector, 32)\n    result[1<<n] = 1.0\n    return result\n}\n\nfunc cdot(a, b vector) vector {\n    return mul(vector{0.5}, add(mul(a, b), mul(b, a)))\n}\n\nfunc neg(x vector) vector {\n    return mul(vector{-1}, x)\n}\n\nfunc bitCount(i int) int {\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    i = (i + (i >> 4)) & 0x0F0F0F0F\n    i = i + (i >> 8)\n    i = i + (i >> 16)\n    return i & 0x0000003F\n}\n\nfunc reorderingSign(i, j int) float64 {\n    i >>= 1\n    sum := 0\n    for i != 0 {\n        sum += bitCount(i & j)\n        i >>= 1\n    }\n    cond := (sum & 1) == 0\n    if cond {\n        return 1.0\n    }\n    return -1.0\n}\n\nfunc add(a, b vector) vector {\n    result := make(vector, 32)\n    copy(result, a)\n    for i, _ := range b {\n        result[i] += b[i]\n    }\n    return result\n}\n\nfunc mul(a, b vector) vector {\n    result := make(vector, 32)\n    for i, _ := range a {\n        if a[i] != 0 {\n            for j, _ := range b {\n                if b[j] != 0 {\n                    s := reorderingSign(i, j) * a[i] * b[j]\n                    k := i ^ j\n                    result[k] += s\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc randomVector() vector {\n    result := make(vector, 32)\n    for i := uint(0); i < 5; i++ {\n        result = add(result, mul(vector{rand.Float64()}, e(i)))\n    }\n    return result\n}\n\nfunc randomMultiVector() vector {\n    result := make(vector, 32)\n    for i := 0; i < 32; i++ {\n        result[i] = rand.Float64()\n    }\n    return result\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n    for i := uint(0); i < 5; i++ {\n        for j := uint(0); j < 5; j++ {\n            if i < j {\n                if cdot(e(i), e(j))[0] != 0 {\n                    fmt.Println(\"Unexpected non-null scalar product.\")\n                    return\n                }\n            } else if i == j {\n                if cdot(e(i), e(j))[0] == 0 {\n                    fmt.Println(\"Unexpected null scalar product.\")\n                }\n            }\n        }\n    }\n\n    a := randomMultiVector()\n    b := randomMultiVector()\n    c := randomMultiVector()\n    x := randomVector()\n\n    \n    fmt.Println(mul(mul(a, b), c))\n    fmt.Println(mul(a, mul(b, c)))\n\n    \n    fmt.Println(mul(a, add(b, c)))\n    fmt.Println(add(mul(a, b), mul(a, c)))\n\n    \n    fmt.Println(mul(add(a, b), c))\n    fmt.Println(add(mul(a, c), mul(b, c)))\n\n    \n    fmt.Println(mul(x, x))\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 146,
    "input": "Translate C to Java:#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef int bool;\n\nchar grid[8][8];\n\nvoid placeKings() {\n    int r1, r2, c1, c2;\n    for (;;) {\n        r1 = rand() % 8;\n        c1 = rand() % 8;\n        r2 = rand() % 8;\n        c2 = rand() % 8;\n        if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1) {\n            grid[r1][c1] = 'K';\n            grid[r2][c2] = 'k';\n            return;\n        }\n    }\n}\n\nvoid placePieces(const char *pieces, bool isPawn) {\n    int n, r, c;\n    int numToPlace = rand() % strlen(pieces);\n    for (n = 0; n < numToPlace; ++n) {\n        do {\n            r = rand() % 8;\n            c = rand() % 8;\n        }\n        while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));\n        grid[r][c] = pieces[n];\n    }\n}\n\nvoid toFen() {\n    char fen[80], ch;\n    int r, c, countEmpty = 0, index = 0;\n    for (r = 0; r < 8; ++r) {\n        for (c = 0; c < 8; ++c) {\n            ch = grid[r][c];\n            printf(\"%2c \", ch == 0 ? '.' : ch);\n            if (ch == 0) {\n                countEmpty++;\n            }\n            else {\n                if (countEmpty > 0) {\n                    fen[index++] = countEmpty + 48;\n                    countEmpty = 0;               \n                }\n                fen[index++] = ch;\n            }\n        }\n        if (countEmpty > 0) {\n            fen[index++] = countEmpty + 48;\n            countEmpty = 0;\n        }\n        fen[index++]= '/';\n        printf(\"\\n\");\n    }\n    strcpy(fen + index, \" w - - 0 1\");\n    printf(\"%s\\n\", fen);\n}\n\nchar *createFen() {\n    placeKings();\n    placePieces(\"PPPPPPPP\", TRUE);\n    placePieces(\"pppppppp\", TRUE);\n    placePieces(\"RNBQBNR\", FALSE);\n    placePieces(\"rnbqbnr\", FALSE);\n    toFen();\n}\n\nint main() {\n    srand(time(NULL));\n    createFen();\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import static java.lang.Math.abs;\nimport java.util.Random;\n\npublic class Fen {\n    static Random rand = new Random();\n\n    public static void main(String[] args) {\n        System.out.println(createFen());\n    }\n\n    static String createFen() {\n        char[][] grid = new char[8][8];\n\n        placeKings(grid);\n        placePieces(grid, \"PPPPPPPP\", true);\n        placePieces(grid, \"pppppppp\", true);\n        placePieces(grid, \"RNBQBNR\", false);\n        placePieces(grid, \"rnbqbnr\", false);\n\n        return toFen(grid);\n    }\n\n    static void placeKings(char[][] grid) {\n        int r1, c1, r2, c2;\n        while (true) {\n            r1 = rand.nextInt(8);\n            c1 = rand.nextInt(8);\n            r2 = rand.nextInt(8);\n            c2 = rand.nextInt(8);\n            if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1)\n                break;\n        }\n        grid[r1][c1] = 'K';\n        grid[r2][c2] = 'k';\n    }\n\n    static void placePieces(char[][] grid, String pieces, boolean isPawn) {\n        int numToPlace = rand.nextInt(pieces.length());\n        for (int n = 0; n < numToPlace; n++) {\n            int r, c;\n            do {\n                r = rand.nextInt(8);\n                c = rand.nextInt(8);\n\n            } while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));\n\n            grid[r][c] = pieces.charAt(n);\n        }\n    }\n\n    static String toFen(char[][] grid) {\n        StringBuilder fen = new StringBuilder();\n        int countEmpty = 0;\n        for (int r = 0; r < 8; r++) {\n            for (int c = 0; c < 8; c++) {\n                char ch = grid[r][c];\n                System.out.printf(\"%2c \", ch == 0 ? '.' : ch);\n                if (ch == 0) {\n                    countEmpty++;\n                } else {\n                    if (countEmpty > 0) {\n                        fen.append(countEmpty);\n                        countEmpty = 0;\n                    }\n                    fen.append(ch);\n                }\n            }\n            if (countEmpty > 0) {\n                fen.append(countEmpty);\n                countEmpty = 0;\n            }\n            fen.append(\"/\");\n            System.out.println();\n        }\n        return fen.append(\" w - - 0 1\").toString();\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 147,
    "input": "Translate Java to Python:import java.awt.image.*;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.*;\n\npublic class HoughTransform\n{\n  public static ArrayData houghTransform(ArrayData inputData, int thetaAxisSize, int rAxisSize, int minContrast)\n  {\n    int width = inputData.width;\n    int height = inputData.height;\n    int maxRadius = (int)Math.ceil(Math.hypot(width, height));\n    int halfRAxisSize = rAxisSize >>> 1;\n    ArrayData outputData = new ArrayData(thetaAxisSize, rAxisSize);\n    \n    \n    double[] sinTable = new double[thetaAxisSize];\n    double[] cosTable = new double[thetaAxisSize];\n    for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n    {\n      double thetaRadians = theta * Math.PI / thetaAxisSize;\n      sinTable[theta] = Math.sin(thetaRadians);\n      cosTable[theta] = Math.cos(thetaRadians);\n    }\n    \n    for (int y = height - 1; y >= 0; y--)\n    {\n      for (int x = width - 1; x >= 0; x--)\n      {\n        if (inputData.contrast(x, y, minContrast))\n        {\n          for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n          {\n            double r = cosTable[theta] * x + sinTable[theta] * y;\n            int rScaled = (int)Math.round(r * halfRAxisSize / maxRadius) + halfRAxisSize;\n            outputData.accumulate(theta, rScaled, 1);\n          }\n        }\n      }\n    }\n    return outputData;\n  }\n  \n  public static class ArrayData\n  {\n    public final int[] dataArray;\n    public final int width;\n    public final int height;\n    \n    public ArrayData(int width, int height)\n    {\n      this(new int[width * height], width, height);\n    }\n    \n    public ArrayData(int[] dataArray, int width, int height)\n    {\n      this.dataArray = dataArray;\n      this.width = width;\n      this.height = height;\n    }\n    \n    public int get(int x, int y)\n    {  return dataArray[y * width + x];  }\n    \n    public void set(int x, int y, int value)\n    {  dataArray[y * width + x] = value;  }\n    \n    public void accumulate(int x, int y, int delta)\n    {  set(x, y, get(x, y) + delta);  }\n    \n    public boolean contrast(int x, int y, int minContrast)\n    {\n      int centerValue = get(x, y);\n      for (int i = 8; i >= 0; i--)\n      {\n        if (i == 4)\n          continue;\n        int newx = x + (i % 3) - 1;\n        int newy = y + (i / 3) - 1;\n        if ((newx < 0) || (newx >= width) || (newy < 0) || (newy >= height))\n          continue;\n        if (Math.abs(get(newx, newy) - centerValue) >= minContrast)\n          return true;\n      }\n      return false;\n    }\n    \n    public int getMax()\n    {\n      int max = dataArray[0];\n      for (int i = width * height - 1; i > 0; i--)\n        if (dataArray[i] > max)\n          max = dataArray[i];\n      return max;\n    }\n  }\n  \n  public static ArrayData getArrayDataFromImage(String filename) throws IOException\n  {\n    BufferedImage inputImage = ImageIO.read(new File(filename));\n    int width = inputImage.getWidth();\n    int height = inputImage.getHeight();\n    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);\n    ArrayData arrayData = new ArrayData(width, height);\n    \n    for (int y = 0; y < height; y++)\n    {\n      for (int x = 0; x < width; x++)\n      {\n        int rgbValue = rgbData[y * width + x];\n        rgbValue = (int)(((rgbValue & 0xFF0000) >>> 16) * 0.30 + ((rgbValue & 0xFF00) >>> 8) * 0.59 + (rgbValue & 0xFF) * 0.11);\n        arrayData.set(x, height - 1 - y, rgbValue);\n      }\n    }\n    return arrayData;\n  }\n  \n  public static void writeOutputImage(String filename, ArrayData arrayData) throws IOException\n  {\n    int max = arrayData.getMax();\n    BufferedImage outputImage = new BufferedImage(arrayData.width, arrayData.height, BufferedImage.TYPE_INT_ARGB);\n    for (int y = 0; y < arrayData.height; y++)\n    {\n      for (int x = 0; x < arrayData.width; x++)\n      {\n        int n = Math.min((int)Math.round(arrayData.get(x, y) * 255.0 / max), 255);\n        outputImage.setRGB(x, arrayData.height - 1 - y, (n << 16) | (n << 8) | 0x90 | -0x01000000);\n      }\n    }\n    ImageIO.write(outputImage, \"PNG\", new File(filename));\n    return;\n  }\n  \n  public static void main(String[] args) throws IOException\n  {\n    ArrayData inputData = getArrayDataFromImage(args[0]);\n    int minContrast = (args.length >= 4) ? 64 : Integer.parseInt(args[4]);\n    ArrayData outputData = houghTransform(inputData, Integer.parseInt(args[2]), Integer.parseInt(args[3]), minContrast);\n    writeOutputImage(args[1], outputData);\n    return;\n  }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from math import hypot, pi, cos, sin\nfrom PIL import Image\n\n\ndef hough(im, ntx=460, mry=360):\n    \"Calculate Hough transform.\"\n    pim = im.load()\n    nimx, mimy = im.size\n    mry = int(mry/2)*2          \n    him = Image.new(\"L\", (ntx, mry), 255)\n    phim = him.load()\n\n    rmax = hypot(nimx, mimy)\n    dr = rmax / (mry/2)\n    dth = pi / ntx\n\n    for jx in xrange(nimx):\n        for iy in xrange(mimy):\n            col = pim[jx, iy]\n            if col == 255: continue\n            for jtx in xrange(ntx):\n                th = dth * jtx\n                r = jx*cos(th) + iy*sin(th)\n                iry = mry/2 + int(r/dr+0.5)\n                phim[jtx, iry] -= 1\n    return him\n\n\ndef test():\n    \"Test Hough transform with pentagon.\"\n    im = Image.open(\"pentagon.png\").convert(\"L\")\n    him = hough(im)\n    him.save(\"ho5.bmp\")\n\n\nif __name__ == \"__main__\": test()\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 148,
    "input": "Translate PHP to Java:<?php\n\n\n\nfunction _commonPath($dirList)\n{\n\t$arr = array();\n\tforeach($dirList as $i => $path)\n\t{\n\t\t$dirList[$i]\t= explode('/', $path);\n\t\tunset($dirList[$i][0]);\n\t\t\n\t\t$arr[$i] = count($dirList[$i]);\n\t}\n\t\n\t$min = min($arr);\n\t\n\tfor($i = 0; $i < count($dirList); $i++)\n\t{\n\t\twhile(count($dirList[$i]) > $min)\n\t\t{\n\t\t\tarray_pop($dirList[$i]);\n\t\t}\n\t\t\n\t\t$dirList[$i] = '/' . implode('/' , $dirList[$i]);\n\t}\n\t\n\t$dirList = array_unique($dirList);\n\twhile(count($dirList) !== 1)\n\t{\n\t\t$dirList = array_map('dirname', $dirList);\n\t\t$dirList = array_unique($dirList);\n\t}\n\treset($dirList);\n\t\n\treturn current($dirList);\n}\n\n \n\n$dirs = array(\n '/home/user1/tmp/coverage/test',\n '/home/user1/tmp/covert/operator',\n '/home/user1/tmp/coven/members',\n);\n\n\nif('/home/user1/tmp' !== common_path($dirs))\n{\n  echo 'test fail';\n} else {\n  echo 'test success';\n}\n\n?>\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class CommonPath {\n\tpublic static String commonPath(String... paths){\n\t\tString commonPath = \"\";\n\t\tString[][] folders = new String[paths.length][];\n\t\tfor(int i = 0; i < paths.length; i++){\n\t\t\tfolders[i] = paths[i].split(\"/\"); \n\t\t}\n\t\tfor(int j = 0; j < folders[0].length; j++){\n\t\t\tString thisFolder = folders[0][j]; \n\t\t\tboolean allMatched = true; \n\t\t\tfor(int i = 1; i < folders.length && allMatched; i++){ \n\t\t\t\tif(folders[i].length < j){ \n\t\t\t\t\tallMatched = false; \n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tallMatched &= folders[i][j].equals(thisFolder); \n\t\t\t}\n\t\t\tif(allMatched){ \n\t\t\t\tcommonPath += thisFolder + \"/\"; \n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn commonPath;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[] paths = { \"/home/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths));\n\t\t\n\t\tString[] paths2 = { \"/hame/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths2));\n\t}\n}\n",
    "input_language": "PHP",
    "output_language": "Java"
  },
  {
    "id": 149,
    "input": "Translate C to Go:\n\n#include<graphics.h>\n#include<math.h>\n\n#define pi M_PI\n\nvoid sunflower(int winWidth, int winHeight, double diskRatio, int iter){\n\tdouble factor = .5 + sqrt(1.25),r,theta;\n\tdouble x = winWidth/2.0, y = winHeight/2.0;\n\tdouble maxRad = pow(iter,factor)/iter;\n\t\n\tint i;\n\t\n\tsetbkcolor(LIGHTBLUE);\n\t\n\tfor(i=0;i<=iter;i++){\n\t\tr = pow(i,factor)/iter;\n\t\t\n\t\tr/maxRad < diskRatio?setcolor(BLACK):setcolor(YELLOW);\n\t\t\n\t\ttheta = 2*pi*factor*i;\n\t\tcircle(x + r*sin(theta), y + r*cos(theta), 10 * i/(1.0*iter));\n\t}\n}\n\nint main()\n{\n\tinitwindow(1000,1000,\"Sunflower...\");\n\t\n\tsunflower(1000,1000,0.5,3000);\n\t\n\tgetch();\n\t\n\tclosegraph();\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"github.com/fogleman/gg\"\n    \"math\"\n)\n\nfunc main() {\n    dc := gg.NewContext(400, 400)\n    dc.SetRGB(1, 1, 1)\n    dc.Clear()\n    dc.SetRGB(0, 0, 1)\n    c := (math.Sqrt(5) + 1) / 2\n    numberOfSeeds := 3000\n    for i := 0; i <= numberOfSeeds; i++ {\n        fi := float64(i)\n        fn := float64(numberOfSeeds)\n        r := math.Pow(fi, c) / fn\n        angle := 2 * math.Pi * c * fi\n        x := r*math.Sin(angle) + 200\n        y := r*math.Cos(angle) + 200\n        fi /= fn / 5\n        dc.DrawCircle(x, y, fi)\n    }\n    dc.SetLineWidth(1)\n    dc.Stroke()\n    dc.SavePNG(\"sunflower_fractal.png\")\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 150,
    "input": "Translate Java to VB:import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\n\npublic class IQPuzzle {\n\n    public static void main(String[] args) {\n        System.out.printf(\"  \");\n        for ( int start = 1 ; start < Puzzle.MAX_PEGS ; start++ ) {\n            System.out.printf(\"  %,6d\", start);\n        }\n        System.out.printf(\"%n\");\n        for ( int start = 1 ; start < Puzzle.MAX_PEGS ; start++ ) {\n            System.out.printf(\"%2d\", start);\n            Map<Integer,Integer> solutions = solve(start);    \n            for ( int end = 1 ; end < Puzzle.MAX_PEGS ; end++ ) {\n                System.out.printf(\"  %,6d\", solutions.containsKey(end) ? solutions.get(end) : 0);\n            }\n            System.out.printf(\"%n\");\n        }\n        int moveNum = 0;\n        System.out.printf(\"%nOne Solution:%n\");\n        for ( Move m : oneSolution ) {\n            moveNum++;\n            System.out.printf(\"Move %d = %s%n\", moveNum, m);\n        }\n    }\n    \n    private static List<Move> oneSolution = null;\n    \n    private static Map<Integer, Integer> solve(int emptyPeg) {\n        Puzzle puzzle = new Puzzle(emptyPeg);\n        Map<Integer,Integer> solutions = new HashMap<>();\n        Stack<Puzzle> stack = new Stack<Puzzle>();\n        stack.push(puzzle);\n        while ( ! stack.isEmpty() ) {\n            Puzzle p = stack.pop();\n            if ( p.solved() ) {\n                solutions.merge(p.getLastPeg(), 1, (v1,v2) -> v1 + v2);\n                if ( oneSolution == null ) {\n                    oneSolution = p.moves;\n                }\n                continue;\n            }\n            for ( Move move : p.getValidMoves() ) {\n                Puzzle pMove = p.move(move);\n                stack.add(pMove);\n            }\n        }\n        \n        return solutions;\n    }\n    \n    private static class Puzzle {\n        \n        public static int MAX_PEGS = 16;\n        private boolean[] pegs = new boolean[MAX_PEGS];  \n        \n        private List<Move> moves;\n\n        public Puzzle(int emptyPeg) {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                pegs[i] = true;\n            }\n            pegs[emptyPeg] = false;\n            moves = new ArrayList<>();\n        }\n\n        public Puzzle() {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                pegs[i] = true;\n            }\n            moves = new ArrayList<>();\n        }\n\n        private static Map<Integer,List<Move>> validMoves = new HashMap<>(); \n        static {\n            validMoves.put(1, Arrays.asList(new Move(1, 2, 4), new Move(1, 3, 6)));\n            validMoves.put(2, Arrays.asList(new Move(2, 4, 7), new Move(2, 5, 9)));\n            validMoves.put(3, Arrays.asList(new Move(3, 5, 8), new Move(3, 6, 10)));\n            validMoves.put(4, Arrays.asList(new Move(4, 2, 1), new Move(4, 5, 6), new Move(4, 8, 13), new Move(4, 7, 11)));\n            validMoves.put(5, Arrays.asList(new Move(5, 8, 12), new Move(5, 9, 14)));\n            validMoves.put(6, Arrays.asList(new Move(6, 3, 1), new Move(6, 5, 4), new Move(6, 9, 13), new Move(6, 10, 15)));\n            validMoves.put(7, Arrays.asList(new Move(7, 4, 2), new Move(7, 8, 9)));\n            validMoves.put(8, Arrays.asList(new Move(8, 5, 3), new Move(8, 9, 10)));\n            validMoves.put(9, Arrays.asList(new Move(9, 5, 2), new Move(9, 8, 7)));\n            validMoves.put(10, Arrays.asList(new Move(10, 6, 3), new Move(10, 9, 8)));\n            validMoves.put(11, Arrays.asList(new Move(11, 7, 4), new Move(11, 12, 13)));\n            validMoves.put(12, Arrays.asList(new Move(12, 8, 5), new Move(12, 13, 14)));\n            validMoves.put(13, Arrays.asList(new Move(13, 12, 11), new Move(13, 8, 4), new Move(13, 9, 6), new Move(13, 14, 15)));\n            validMoves.put(14, Arrays.asList(new Move(14, 13, 12), new Move(14, 9, 5)));\n            validMoves.put(15, Arrays.asList(new Move(15, 14, 13), new Move(15, 10, 6)));\n        }\n        \n        public List<Move> getValidMoves() {\n            List<Move> moves = new ArrayList<Move>();\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    for ( Move testMove : validMoves.get(i) ) {\n                        if ( pegs[testMove.jump] && ! pegs[testMove.end] ) {\n                            moves.add(testMove);\n                        }\n                    }\n                }\n            }\n            return moves;\n        }\n\n        public boolean solved() {\n            boolean foundFirstPeg = false;\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    if ( foundFirstPeg ) {\n                        return false;\n                    }\n                    foundFirstPeg = true;\n                }\n            }\n            return true;\n        }\n        \n        public Puzzle move(Move move) {\n            Puzzle p = new Puzzle();\n            if ( ! pegs[move.start] || ! pegs[move.jump] || pegs[move.end] ) {\n                throw new RuntimeException(\"Invalid move.\");\n            }\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                p.pegs[i] = pegs[i];\n            }\n            p.pegs[move.start] = false;\n            p.pegs[move.jump] = false;\n            p.pegs[move.end] = true;\n            for ( Move m : moves ) {\n                p.moves.add(new Move(m.start, m.jump, m.end));\n            }\n            p.moves.add(new Move(move.start, move.jump, move.end));\n            return p;\n        }\n        \n        public int getLastPeg() {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    return i;\n                }\n            }\n            throw new RuntimeException(\"ERROR:  Illegal position.\");\n        }\n        \n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"[\");\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                sb.append(pegs[i] ? 1 : 0);\n                sb.append(\",\");\n            }\n            sb.setLength(sb.length()-1);            \n            sb.append(\"]\");\n            return sb.toString();\n        }\n    }\n    \n    private static class Move {\n        int start;\n        int jump;\n        int end;\n        \n        public Move(int s, int j, int e) {\n            start = s; jump = j; end = e;\n        }\n        \n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"{\");\n            sb.append(\"s=\" + start);\n            sb.append(\", j=\" + jump);\n            sb.append(\", e=\" + end);\n            sb.append(\"}\");\n            return sb.toString();\n        }\n    }\n\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Imports System, Microsoft.VisualBasic.DateAndTime\n\nPublic Module Module1\n    Const n As Integer = 5 \n    Dim Board As String \n    Dim Starting As Integer = 1 \n    Dim Target As Integer = 13 \n    Dim Moves As Integer() \n    Dim bi() As Integer \n    Dim ib() As Integer \n    Dim nl As Char = Convert.ToChar(10) \n\n    \n    Public Function Dou(s As String) As String\n        Dou = \"\" : Dim b As Boolean = True\n        For Each ch As Char In s\n            If b Then b = ch <> \" \"\n            If b Then Dou &= ch & \" \" Else Dou = \" \" & Dou\n        Next : Dou = Dou.TrimEnd()\n    End Function\n\n    \n    Public Function Fmt(s As String) As String\n        If s.Length < Board.Length Then Return s\n        Fmt = \"\" : For i As Integer = 1 To n : Fmt &= Dou(s.Substring(i * n - n, n)) &\n                If(i = n, s.Substring(Board.Length), \"\") & nl\n        Next\n    End Function\n\n    \n    Public Function Triangle(n As Integer) As Integer\n        Return (n * (n + 1)) / 2\n    End Function\n\n    \n    Public Function Init(s As String, pos As Integer) As String\n        Init = s : Mid(Init, pos, 1) = \"0\"\n    End Function\n\n    \n    Public Sub InitIndex()\n        ReDim bi(Triangle(n)), ib(n * n) : Dim j As Integer = 0\n        For i As Integer = 0 To ib.Length - 1\n            If i = 0 Then\n                ib(i) = 0 : bi(j) = 0 : j += 1\n            Else\n                If Board(i - 1) = \"1\" Then ib(i) = j : bi(j) = i : j += 1\n            End If\n        Next\n    End Sub\n\n    \n    Public Function solve(brd As String, pegsLeft As Integer) As String\n        If pegsLeft = 1 Then \n            If Target = 0 Then Return \"Completed\" \n            If brd(bi(Target) - 1) = \"1\" Then Return \"Completed\" Else Return \"fail\"\n        End If\n        For i = 1 To Board.Length \n            If brd(i - 1) = \"1\" Then \n                For Each mj In Moves \n                    Dim over As Integer = i + mj \n                    Dim land As Integer = i + 2 * mj \n                    \n                    If land >= 1 AndAlso land <= brd.Length _\n                                AndAlso brd(land - 1) = \"0\" _\n                                AndAlso brd(over - 1) = \"1\" Then\n                        setPegs(brd, \"001\", i, over, land) \n                        \n                        Dim Res As String = solve(brd.Substring(0, Board.Length), pegsLeft - 1)\n                        \n                        If Res.Length <> 4 Then _\n                            Return brd & info(i, over, land) & nl & Res\n                        setPegs(brd, \"110\", i, over, land) \n                    End If\n                Next\n            End If\n        Next\n        Return \"fail\"\n    End Function\n\n    \n    Function info(frm As Integer, over As Integer, dest As Integer) As String\n        Return \"  Peg from \" & ib(frm).ToString() & \" goes to \" & ib(dest).ToString() &\n            \", removing peg at \" & ib(over).ToString()\n    End Function\n\n    \n    Sub setPegs(ByRef board As String, pat As String, a As Integer, b As Integer, c As Integer)\n        Mid(board, a, 1) = pat(0) : Mid(board, b, 1) = pat(1) : Mid(board, c, 1) = pat(2)\n    End Sub\n\n    \n    Sub LimitIt(ByRef x As Integer, lo As Integer, hi As Integer)\n        x = Math.Max(Math.Min(x, hi), lo)\n    End Sub\n\n    Public Sub Main()\n        Dim t As Integer = Triangle(n) \n        LimitIt(Starting, 1, t) \n        LimitIt(Target, 0, t)\n        Dim stime As Date = Now() \n        Moves = {-n - 1, -n, -1, 1, n, n + 1} \n        Board = New String(\"1\", n * n) \n        For i As Integer = 0 To n - 2 \n            Mid(Board, i * (n + 1) + 2, n - 1 - i) = New String(\" \", n - 1 - i)\n        Next\n        InitIndex() \n        Dim B As String = Init(Board, bi(Starting)) \n        Console.WriteLine(Fmt(B & \"  Starting with peg removed from \" & Starting.ToString()))\n        Dim res As String() = solve(B.Substring(0, B.Length), t - 1).Split(nl)\n        Dim ts As String = (Now() - stime).TotalMilliseconds.ToString() & \" ms.\"\n        If res(0).Length = 4 Then\n            If Target = 0 Then\n                Console.WriteLine(\"Unable to find a solution with last peg left anywhere.\")\n            Else\n                Console.WriteLine(\"Unable to find a solution with last peg left at \" &\n                                  Target.ToString() & \".\")\n            End If\n            Console.WriteLine(\"Computation time: \" & ts)\n        Else\n            For Each Sol As String In res : Console.WriteLine(Fmt(Sol)) : Next\n            Console.WriteLine(\"Computation time to first found solution: \" & ts)\n        End If\n        If Diagnostics.Debugger.IsAttached Then Console.ReadLine()\n    End Sub\nEnd Module\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 151,
    "input": "Translate Java to Python:import java.math.BigInteger;\n\nclass IntegerPower {\n    public static void main(String[] args) {\n        BigInteger power = BigInteger.valueOf(5).pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValueExact()).intValueExact());\n        String str = power.toString();\n        int len = str.length();\n        System.out.printf(\"5**4**3**2 = %s...%s and has %d digits%n\",\n                str.substring(0, 20), str.substring(len - 20), len);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": ">>> y = str( 5**4**3**2 )\n>>> print (\"5**4**3**2 = %s...%s and has %i digits\" % (y[:20], y[-20:], len(y)))\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 152,
    "input": "Translate C++ to PHP:#include <iostream>\n#include <boost/multiprecision/gmp.hpp>\n#include <string>\n\nnamespace mp = boost::multiprecision;\n\nint main(int argc, char const *argv[])\n{\n    \n    \n    \n    \n    uint64_t tmpres = mp::pow(mp::mpz_int(4)\n                            , mp::pow(mp::mpz_int(3)\n                                    , 2).convert_to<uint64_t>()\n                                      ).convert_to<uint64_t>();\n    mp::mpz_int res = mp::pow(mp::mpz_int(5), tmpres);\n    std::string s = res.str();\n    std::cout << s.substr(0, 20) \n              << \"...\"\n              << s.substr(s.length() - 20, 20) << std::endl;\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\n$y = bcpow('5', bcpow('4', bcpow('3', '2')));\nprintf(\"5**4**3**2 = %s...%s and has %d digits\\n\", substr($y,0,20), substr($y,-20), strlen($y));\n?>\n",
    "input_language": "C++",
    "output_language": "PHP"
  },
  {
    "id": 153,
    "input": "Translate C to Go:#include <locale.h>\n#include <stdio.h>\n\nint main()\n{\n  unsigned long long int trillion = 1000000000000;\n\n  setlocale(LC_NUMERIC,\"\");\n\n  printf(\"Locale : %s, One Trillion : %'llu\\n\", setlocale(LC_CTYPE,NULL),trillion);\n\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    integers := []int{1_2_3, 0b1_0_1_0_1, 0xa_bc_d, 0o4_37, 0_43_7, 0x_beef}\n    for _, integer := range integers {\n        fmt.Printf(\"%d  \", integer)\n    }\n    floats := []float64{1_2_3_4.2_5, 6.0_22e4, 0x_1.5p-2}\n    for _, float := range floats {\n        fmt.Printf(\"%g  \", float)\n    }\n    fmt.Println()\n    \n    \n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 154,
    "input": "Translate C++ to Go:#include <iostream>\n\nbool ispr(unsigned int n) {\n    if ((n & 1) == 0 || n < 2) return n == 2;\n    for (unsigned int j = 3; j * j <= n; j += 2)\n      if (n % j == 0) return false; return true; }\n\nint main() {\n  unsigned int c = 0, nc, pc = 9, i, a, b, l,\n    ps[128]{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, nxt[128];\n  while (true) {\n    nc = 0;\n    for (i = 0; i < pc; i++) {\n        if (ispr(a = ps[i]))\n          printf(\"%8d%s\", a, ++c % 5 == 0 ? \"\\n\" : \" \");\n        for (b = a * 10, l = a % 10 + b++; b < l; b++)\n          nxt[nc++] = b;\n      }\n      if (nc > 1) for(i = 0, pc = nc; i < pc; i++) ps[i] = nxt[i];\n      else break;\n    }\n    printf(\"\\n%d descending primes found\", c);\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n    \"sort\"\n    \"strconv\"\n)\n\nfunc combinations(a []int, k int) [][]int {\n    n := len(a)\n    c := make([]int, k)\n    var combs [][]int\n    var combine func(start, end, index int)\n    combine = func(start, end, index int) {\n        if index == k {\n            t := make([]int, len(c))\n            copy(t, c)\n            combs = append(combs, t)\n            return\n        }\n        for i := start; i <= end && end-i+1 >= k-index; i++ {\n            c[index] = a[i]\n            combine(i+1, end, index+1)\n        }\n    }\n    combine(0, n-1, 0)\n    return combs\n}\n\nfunc powerset(a []int) (res [][]int) {\n    if len(a) == 0 {\n        return\n    }\n    for i := 1; i <= len(a); i++ {\n        res = append(res, combinations(a, i)...)\n    }\n    return\n}\n\nfunc main() {\n    ps := powerset([]int{9, 8, 7, 6, 5, 4, 3, 2, 1})\n    var descPrimes []int\n    for i := 1; i < len(ps); i++ {\n        s := \"\"\n        for _, e := range ps[i] {\n            s += string(e + '0')\n        }\n        p, _ := strconv.Atoi(s)\n        if rcu.IsPrime(p) {\n            descPrimes = append(descPrimes, p)\n        }\n    }\n    sort.Ints(descPrimes)\n    fmt.Println(\"There are\", len(descPrimes), \"descending primes, namely:\")\n    for i := 0; i < len(descPrimes); i++ {\n        fmt.Printf(\"%8d \", descPrimes[i])\n        if (i+1)%10 == 0 {\n            fmt.Println()\n        }\n    }\n    fmt.Println()\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 155,
    "input": "Translate C to VB:#include <stdio.h>\n#include <math.h>\n#include <unistd.h>\n\nconst char *shades = \".:!*oe&#%@\";\n\ndouble light[3] = { -50, 0, 50 };\nvoid normalize(double * v)\n{\n\tdouble len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n\tv[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n\tdouble d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n\treturn d < 0 ? -d : 0;\n}\n\ntypedef struct { double cx, cy, cz, r; } sphere_t;\n\n\nsphere_t pos = { 20, 20, 0, 20 }, neg = { 1, 1, -6, 20 };\n\n\nint hit_sphere(sphere_t *sph, double x, double y, double *z1, double *z2)\n{\n\tdouble zsq;\n\tx -= sph->cx;\n\ty -= sph->cy;\n\tzsq = sph->r * sph->r - (x * x + y * y);\n\tif (zsq < 0) return 0;\n\tzsq = sqrt(zsq);\n\t*z1 = sph->cz - zsq;\n\t*z2 = sph->cz + zsq;\n\treturn 1;\n}\n\nvoid draw_sphere(double k, double ambient)\n{\n\tint i, j, intensity, hit_result;\n\tdouble b;\n\tdouble vec[3], x, y, zb1, zb2, zs1, zs2;\n\tfor (i = floor(pos.cy - pos.r); i <= ceil(pos.cy + pos.r); i++) {\n\t\ty = i + .5;\n\t\tfor (j = floor(pos.cx - 2 * pos.r); j <= ceil(pos.cx + 2 * pos.r); j++) {\n\t\t\tx = (j - pos.cx) / 2. + .5 + pos.cx;\n\n\t\t\t\n\t\t\tif (!hit_sphere(&pos, x, y, &zb1, &zb2))\n\t\t\t\thit_result = 0;\n\n\t\t\t\n\t\t\telse if (!hit_sphere(&neg, x, y, &zs1, &zs2))\n\t\t\t\thit_result = 1;\n\n\t\t\t\n\t\t\telse if (zs1 > zb1) hit_result = 1;\n\n\t\t\t\n\t\t\telse if (zs2 > zb2) hit_result = 0;\n\n\t\t\t\n\t\t\telse if (zs2 > zb1) hit_result = 2;\n\t\t\telse\t\t    hit_result = 1;\n\n\t\t\tswitch(hit_result) {\n\t\t\tcase 0:\n\t\t\t\tputchar('+');\n\t\t\t\tcontinue;\n\t\t\tcase 1:\n\t\t\t\tvec[0] = x - pos.cx;\n\t\t\t\tvec[1] = y - pos.cy;\n\t\t\t\tvec[2] = zb1 - pos.cz;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvec[0] = neg.cx - x;\n\t\t\t\tvec[1] = neg.cy - y;\n\t\t\t\tvec[2] = neg.cz - zs2;\n\t\t\t}\n\n\t\t\tnormalize(vec);\n\t\t\tb = pow(dot(light, vec), k) + ambient;\n\t\t\tintensity = (1 - b) * (sizeof(shades) - 1);\n\t\t\tif (intensity < 0) intensity = 0;\n\t\t\tif (intensity >= sizeof(shades) - 1)\n\t\t\t\tintensity = sizeof(shades) - 2;\n\t\t\tputchar(shades[intensity]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n\nint main()\n{\n\tdouble ang = 0;\n\n\twhile (1) {\n\t\tprintf(\"\\033[H\");\n\t\tlight[1] = cos(ang * 2);\n\t\tlight[2] = cos(ang);\n\t\tlight[0] = sin(ang);\n\t\tnormalize(light);\n\t\tang += .05;\n\n\t\tdraw_sphere(2, .3);\n\t\tusleep(100000);\n\t}\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "\n\noption explicit               \n\nconst x_=0\nconst y_=1\nconst z_=2\nconst r_=3\n\nfunction clamp(x,b,t) \n  if x<b then \n     clamp=b \n  elseif x>t then\n    clamp =t \n  else \n    clamp=x \n  end if \nend function\n\nfunction dot(v,w) dot=v(x_)*w(x_)+v(y_)*w(y_)+v(z_)*w(z_): end function\n\nfunction normal (byval v) \n    dim ilen:ilen=1/sqr(dot(v,v)): \n    v(x_)=v(x_)*ilen: v(y_)=v(y_)*ilen: v(z_)=v(z_)*ilen:\n    normal=v:\nend function\n\nfunction hittest(s,x,y)\n   dim z\n   z = s(r_)^2 - (x-s(x_))^2 - (y-s(y_))^2\n   if z>=0  then\n     z=sqr(z)\n     hittest=array(s(z_)-z,s(z_)+z)\n   else\n     hittest=0\n  end if\nend function\n            \nsub deathstar(pos, neg, sun, k, amb)\n  dim x,y,shades,result,shade,hp,hn,xx,b \n  shades=array(\" \",\".\",\":\",\"!\",\"*\",\"o\",\"e\",\"&\",\"#\",\"%\",\"@\")\n  for y = pos(y_)-pos(r_)-0.5 to pos(y_)+pos(r_)+0.5 \n    for x = pos(x_)-pos(r_)-0.5 to pos(x_)+pos(r_)+.5\n      hp=hittest (pos, x, y)\n      hn=hittest(neg,x,y)\n      if not  isarray(hp) then\n         result=0\n      elseif not isarray(hn) then\n        result=1\n      elseif hn(0)>hp(0)  then\n        result=1        \n      elseif  hn(1)>hp(1) then\n        result=0\n      elseif hn(1)>hp(0) then\n        result=2\n      else\n        result=1\n      end if\n\n      shade=-1\n      select case result\n      case 0\n        shade=0        \n      case 1\n        xx=normal(array(x-pos(x_),y-pos(y_),hp(0)-pos(z_)))\n        \n      case 2\n        xx=normal(array(neg(x_)-x,neg(y_)-y,neg(z_)-hn(1)))\n        \n      end select\n      if shade <>0 then\n        b=dot(sun,xx)^k+amb\n        shade=clamp((1-b) *ubound(shades),1,ubound(shades))        \n      end if       \n      wscript.stdout.write string(2,shades(shade))\n    next\n    wscript.stdout.write vbcrlf\n  next\nend sub\n\ndeathstar array(20, 20, 0, 20),array(10,10,-15,10), normal(array(-2,1,3)), 2, 0.1\n",
    "input_language": "C",
    "output_language": "VB"
  },
  {
    "id": 156,
    "input": "Translate C to Go:\n\n\n#include <stdio.h>\n\nint Gcd(int v1, int v2)\n{\n\t\n\tint a, b, r;\n\tif (v1 < v2)\n\t{\n\t\ta = v2;\n\t\tb = v1;\n\t}\n\telse\n\t{\n\t\ta = v1;\n\t\tb = v2;\n\t}\n\tdo\n\t{\n\t\tr = a % b;\n\t\tif (r == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t} while (1 == 1);\n\treturn b;\n}\n\nint NotInList(int num, int numtrip, int *tripletslist)\n{\n\t\n\tfor (int i = 0; i < numtrip; i++)\n\t{\n\t\tif (num == tripletslist[i])\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n} \t\n\nint main()\n{\n\tint coprime[50];\n\tint gcd1, gcd2;\n\tint ntrip = 2;\n\tint n = 3;\n\t\n\t\n\tcoprime[0] = 1;\n\tcoprime[1] = 2;\n\n\twhile ( n < 50)\n\t{\n\t\tgcd1 = Gcd(n, coprime[ntrip-1]);\n\t\tgcd2 = Gcd(n, coprime[ntrip-2]);\n\t\t\n\t\tif (gcd1 == 1 && gcd2 == 1 && NotInList(n, ntrip, coprime))\n\t\t{\n\t\t\tcoprime[ntrip++] = n;\n\t\t\t\n\t\t\tn = 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tn++;\n\t\t}\n\t}\n\t\n\t\n\tprintf(\"\\n\");\n\tfor (int i = 0; i < ntrip; i++)\n\t{\n\t\tprintf(\"%2d \", coprime[i]);\n\t\tif ((i+1) % 10 == 0)\n\t\t{\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\tprintf(\"\\n\\nNumber of elements in coprime triplets: %d\\n\\n\", ntrip);\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nfunc contains(a []int, v int) bool {\n    for _, e := range a {\n        if e == v {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    const limit = 50\n    cpt := []int{1, 2}\n    for {\n        m := 1\n        l := len(cpt)\n        for contains(cpt, m) || rcu.Gcd(m, cpt[l-1]) != 1 || rcu.Gcd(m, cpt[l-2]) != 1 {\n            m++\n        }\n        if m >= limit {\n            break\n        }\n        cpt = append(cpt, m)\n    }\n    fmt.Printf(\"Coprime triplets under %d:\\n\", limit)\n    for i, t := range cpt {\n        fmt.Printf(\"%2d \", t)\n        if (i+1)%10 == 0 {\n            fmt.Println()\n        }\n    }\n    fmt.Printf(\"\\n\\nFound %d such numbers\\n\", len(cpt))\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 157,
    "input": "Translate C to C#:#include <stdio.h>\n#define LIMIT 100000\n\nint digitset(int num, int base) {\n    int set;\n    for (set = 0; num; num /= base)\n        set |= 1 << num % base;\n    return set;\n}\n\nint main() {\n    int i, c = 0;\n    for (i = 0; i < LIMIT; i++)\n        if (digitset(i,10) == digitset(i,16))\n            printf(\"%6d%c\", i, ++c%10 ? ' ' : '\\n');\n    printf(\"\\n\");\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "#include <iostream>\n#include <iomanip>\n#include <bitset>\n\nconst int LIMIT = 100000;\n\nstd::bitset<16> digitset(int num, int base) {\n    std::bitset<16> set;\n    for (; num; num /= base) set.set(num % base);\n    return set;\n}\n\nint main() {\n    int c = 0;\n    for (int i=0; i<LIMIT; i++) {\n        if (digitset(i,10) == digitset(i,16)) {\n            std::cout << std::setw(7) << i;\n            if (++c % 10 == 0) std::cout << std::endl;\n        }\n    }\n    std::cout << std::endl;\n    return 0;\n}\n",
    "input_language": "C",
    "output_language": "C#"
  },
  {
    "id": 158,
    "input": "Translate C++ to Java:#include <iostream>\n\nint main()\n{\n  int a, b;\n  std::cin >> a >> b;\n  std::cout << \"a+b = \" << a+b << \"\\n\";\n  std::cout << \"a-b = \" << a-b << \"\\n\";\n  std::cout << \"a*b = \" << a*b << \"\\n\";\n  std::cout << \"a/b = \" << a/b << \", remainder \" << a%b << \"\\n\";\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 159,
    "input": "Translate C to VB:#include <stdio.h>\n\nvoid recurse(unsigned int i)\n{\n  printf(\"%d\\n\", i);\n  recurse(i+1); \n}\n\nint main()\n{\n  recurse(0);\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Option Explicit\n\nSub Main()\n    Debug.Print \"The limit is : \" & Limite_Recursivite(0)\nEnd Sub\n\nFunction Limite_Recursivite(Cpt As Long) As Long\n    Cpt = Cpt + 1               \n    On Error Resume Next\n    Limite_Recursivite Cpt      \n    On Error GoTo 0\n    Limite_Recursivite = Cpt    \nEnd Function\n",
    "input_language": "C",
    "output_language": "VB"
  },
  {
    "id": 160,
    "input": "Translate Java to Go:public class VLQCode\n{\n  public static byte[] encode(long n)\n  {\n    int numRelevantBits = 64 - Long.numberOfLeadingZeros(n);\n    int numBytes = (numRelevantBits + 6) / 7;\n    if (numBytes == 0)\n      numBytes = 1;\n    byte[] output = new byte[numBytes];\n    for (int i = numBytes - 1; i >= 0; i--)\n    {\n      int curByte = (int)(n & 0x7F);\n      if (i != (numBytes - 1))\n        curByte |= 0x80;\n      output[i] = (byte)curByte;\n      n >>>= 7;\n    }\n    return output;\n  }\n  \n  public static long decode(byte[] b)\n  {\n    long n = 0;\n    for (int i = 0; i < b.length; i++)\n    {\n      int curByte = b[i] & 0xFF;\n      n = (n << 7) | (curByte & 0x7F);\n      if ((curByte & 0x80) == 0)\n        break;\n    }\n    return n;\n  }\n  \n  public static String byteArrayToString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      if (i > 0)\n        sb.append(\", \");\n      String s = Integer.toHexString(b[i] & 0xFF);\n      if (s.length() < 2)\n        s = \"0\" + s;\n      sb.append(s);\n    }\n    return sb.toString();\n  }\n  \n  public static void main(String[] args)\n  {\n    long[] testNumbers = { 2097152, 2097151, 1, 127, 128, 589723405834L };\n    for (long n : testNumbers)\n    {\n      byte[] encoded = encode(n);\n      long decoded = decode(encoded);\n      System.out.println(\"Original input=\" + n + \", encoded = [\" + byteArrayToString(encoded) + \"], decoded=\" + decoded + \", \" + ((n == decoded) ? \"OK\" : \"FAIL\"));\n    }\n  }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"encoding/binary\"\n)\n\nfunc main() {\n    buf := make([]byte, binary.MaxVarintLen64)\n    for _, x := range []int64{0x200000, 0x1fffff} {\n        v := buf[:binary.PutVarint(buf, x)]\n        fmt.Printf(\"%d encodes into %d bytes: %x\\n\", x, len(v), v)\n        x, _ = binary.Varint(v)\n        fmt.Println(x, \"decoded\")\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 161,
    "input": "Translate PHP to Python:\nfunction RGBtoHSV($r, $g, $b) {\n\t$r = $r/255.; // convert to range 0..1\n\t$g = $g/255.;\n\t$b = $b/255.;\n\t$cols = array(\"r\" => $r, \"g\" => $g, \"b\" => $b);\n\tasort($cols, SORT_NUMERIC);\n\t$min = key(array_slice($cols, 1)); // \"r\", \"g\" or \"b\"\n\t$max = key(array_slice($cols, -1)); // \"r\", \"g\" or \"b\"\n\n\tif($cols[$min] == $cols[$max]) {\n\t\t$h = 0;\n\t} else {\n\t\tif($max == \"r\") {\n\t\t\t$h = 60. * ( 0 + ( ($cols[\"g\"]-$cols[\"b\"]) / ($cols[$max]-$cols[$min]) ) );\n\t\t} elseif ($max == \"g\") {\n\t\t\t$h = 60. * ( 2 + ( ($cols[\"b\"]-$cols[\"r\"]) / ($cols[$max]-$cols[$min]) ) );\n\t\t} elseif ($max == \"b\") {\n\t\t\t$h = 60. * ( 4 + ( ($cols[\"r\"]-$cols[\"g\"]) / ($cols[$max]-$cols[$min]) ) );\n\t\t}\n\t\tif($h < 0) {\n\t\t\t$h += 360;\n\t\t}\n\t}\n\n\tif($cols[$max] == 0) {\n\t\t$s = 0;\n\t} else {\n\t\t$s = ( ($cols[$max]-$cols[$min])/$cols[$max] );\n\t\t$s = $s * 255;\n\t}\n\n\t$v = $cols[$max];\n\t$v = $v * 255;\n\n\treturn(array($h, $s, $v));\n}\n\n$filename = \"image.png\";\n$dimensions = getimagesize($filename);\n$w = $dimensions[0]; // width\n$h = $dimensions[1]; // height\n\n$im = imagecreatefrompng($filename);\n\nfor($hi=0; $hi < $h; $hi++) {\n\n\tfor($wi=0; $wi < $w; $wi++) {\n\t\t$rgb = imagecolorat($im, $wi, $hi);\n\n\t\t$r = ($rgb >> 16) & 0xFF;\n\t\t$g = ($rgb >> 8) & 0xFF;\n\t\t$b = $rgb & 0xFF;\n\t\t$hsv = RGBtoHSV($r, $g, $b);\n\n\t\t$brgb = imagecolorat($im, $wi, $hi+1);\n\t\t$br = ($brgb >> 16) & 0xFF;\n\t\t$bg = ($brgb >> 8) & 0xFF;\n\t\t$bb = $brgb & 0xFF;\n\t\t$bhsv = RGBtoHSV($br, $bg, $bb);\n\n\t\tif($hsv[2]-$bhsv[2] > 20) { \n                    imagesetpixel($im, $wi, $hi, imagecolorallocate($im, 255, 0, 0));\n\t\t} \n                else {\n\t\t    imagesetpixel($im, $wi, $hi, imagecolorallocate($im, 0, 0, 0));\n\t\t}\n\t\t\t\n        }\n        \n}\n\nheader('Content-Type: image/jpeg');\nimagepng($im);\nimagedestroy($im);\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\nimport numpy as np\nfrom scipy.ndimage.filters import convolve, gaussian_filter\nfrom scipy.misc import imread, imshow\n\t\ndef CannyEdgeDetector(im, blur = 1, highThreshold = 91, lowThreshold = 31):\n\tim = np.array(im, dtype=float) \n \n\t\n\tim2 = gaussian_filter(im, blur)\n\n\t\n\tim3h = convolve(im2,[[-1,0,1],[-2,0,2],[-1,0,1]]) \n\tim3v = convolve(im2,[[1,2,1],[0,0,0],[-1,-2,-1]])\n\n\t\n\tgrad = np.power(np.power(im3h, 2.0) + np.power(im3v, 2.0), 0.5)\n\ttheta = np.arctan2(im3v, im3h)\n\tthetaQ = (np.round(theta * (5.0 / np.pi)) + 5) % 5 \n\n\t\n\tgradSup = grad.copy()\n\tfor r in range(im.shape[0]):\n\t\tfor c in range(im.shape[1]):\n\t\t\t\n\t\t\tif r == 0 or r == im.shape[0]-1 or c == 0 or c == im.shape[1] - 1:\n\t\t\t\tgradSup[r, c] = 0\n\t\t\t\tcontinue\n\t\t\ttq = thetaQ[r, c] % 4\n\n\t\t\tif tq == 0: \n\t\t\t\tif grad[r, c] <= grad[r, c-1] or grad[r, c] <= grad[r, c+1]:\n\t\t\t\t\tgradSup[r, c] = 0\n\t\t\tif tq == 1: \n\t\t\t\tif grad[r, c] <= grad[r-1, c+1] or grad[r, c] <= grad[r+1, c-1]:\n\t\t\t\t\tgradSup[r, c] = 0\n\t\t\tif tq == 2: \n\t\t\t\tif grad[r, c] <= grad[r-1, c] or grad[r, c] <= grad[r+1, c]:\n\t\t\t\t\tgradSup[r, c] = 0\n\t\t\tif tq == 3: \n\t\t\t\tif grad[r, c] <= grad[r-1, c-1] or grad[r, c] <= grad[r+1, c+1]:\n\t\t\t\t\tgradSup[r, c] = 0\n\n\t\n\tstrongEdges = (gradSup > highThreshold)\n\n\t\n\tthresholdedEdges = np.array(strongEdges, dtype=np.uint8) + (gradSup > lowThreshold)\n\n\t\n\t\n\tfinalEdges = strongEdges.copy()\n\tcurrentPixels = []\n\tfor r in range(1, im.shape[0]-1):\n\t\tfor c in range(1, im.shape[1]-1):\t\n\t\t\tif thresholdedEdges[r, c] != 1:\n\t\t\t\tcontinue \n\t\t\t\n\t\t\t\n\t\t\tlocalPatch = thresholdedEdges[r-1:r+2,c-1:c+2]\n\t\t\tpatchMax = localPatch.max()\n\t\t\tif patchMax == 2:\n\t\t\t\tcurrentPixels.append((r, c))\n\t\t\t\tfinalEdges[r, c] = 1\n\n\t\n\twhile len(currentPixels) > 0:\n\t\tnewPix = []\n\t\tfor r, c in currentPixels:\n\t\t\tfor dr in range(-1, 2):\n\t\t\t\tfor dc in range(-1, 2):\n\t\t\t\t\tif dr == 0 and dc == 0: continue\n\t\t\t\t\tr2 = r+dr\n\t\t\t\t\tc2 = c+dc\n\t\t\t\t\tif thresholdedEdges[r2, c2] == 1 and finalEdges[r2, c2] == 0:\n\t\t\t\t\t\t\n\t\t\t\t\t\tnewPix.append((r2, c2))\n\t\t\t\t\t\tfinalEdges[r2, c2] = 1\n\t\tcurrentPixels = newPix\n\n\treturn finalEdges\n\nif __name__==\"__main__\":\n\tim = imread(\"test.jpg\", mode=\"L\") \n\tfinalEdges = CannyEdgeDetector(im)\n\timshow(finalEdges)\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 162,
    "input": "Translate Java to Python:import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:    %.4f, %.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y: %.4f, %.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y    : %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y : %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 163,
    "input": "Translate C to VB:#include <stdio.h>\n\nint main(int argc, char **argv) {\n\n   int user1 = 0, user2 = 0;\n   printf(\"Enter two integers.  Space delimited, please:  \");\n   scanf(\"%d %d\",&user1, &user2);\n   int array[user1][user2];\n   array[user1/2][user2/2] = user1 + user2;\n   printf(\"array[%d][%d] is %d\\n\",user1/2,user2/2,array[user1/2][user2/2]);\n\n   return 0;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Module Program\n    Sub Main()\n        Console.WriteLine(\"Enter two space-delimited integers:\")\n        Dim input = Console.ReadLine().Split()\n        Dim rows = Integer.Parse(input(0))\n        Dim cols = Integer.Parse(input(1))\n\n        \n        Dim arr(rows - 1, cols - 1) As Integer\n\n        arr(0, 0) = 2\n        Console.WriteLine(arr(0, 0))\n    End Sub\nEnd Module\n",
    "input_language": "C",
    "output_language": "VB"
  },
  {
    "id": 164,
    "input": "Translate PHP to Go:<?php\n  $code = 'echo \"hello world\"';\n  eval($code);\n  $code = 'return \"hello world\"';\n  print eval($code);\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\nimport (\n\t\"fmt\"\n\t\"bitbucket.org/binet/go-eval/pkg/eval\"\n\t\"go/token\"\n)\n\nfunc main() {\n\tw := eval.NewWorld();\n\tfset := token.NewFileSet();\n\n\tcode, err := w.Compile(fset, \"1 + 2\")\n\tif err != nil {\n\t\tfmt.Println(\"Compile error\");\n\t\treturn\n\t}\n\n\tval, err := code.Run();\n\tif err != nil {\n\t\tfmt.Println(\"Run time error\");\n\t\treturn;\n\t}\n\tfmt.Println(\"Return value:\", val) \n\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 165,
    "input": "Translate C to PHP:#include <stdio.h>\n#include <string.h>\n\n\nvoid longmulti(const char *a, const char *b, char *c)\n{\n\tint i = 0, j = 0, k = 0, n, carry;\n\tint la, lb;\n\n\t\n\tif (!strcmp(a, \"0\") || !strcmp(b, \"0\")) {\n\t\tc[0] = '0', c[1] = '\\0';\n\t\treturn;\n\t}\n\n\t\n\tif (a[0] == '-') { i = 1; k = !k; }\n\tif (b[0] == '-') { j = 1; k = !k; }\n\n\t\n\tif (i || j) {\n\t\tif (k) c[0] = '-';\n\t\tlongmulti(a + i, b + j, c + k);\n\t\treturn;\n\t}\n\n\tla = strlen(a);\n\tlb = strlen(b);\n\tmemset(c, '0', la + lb);\n\tc[la + lb] = '\\0';\n\n#\tdefine I(a) (a - '0')\n\tfor (i = la - 1; i >= 0; i--) {\n\t\tfor (j = lb - 1, k = i + j + 1, carry = 0; j >= 0; j--, k--) {\n\t\t\tn = I(a[i]) * I(b[j]) + I(c[k]) + carry;\n\t\t\tcarry = n / 10;\n\t\t\tc[k] = (n % 10) + '0';\n\t\t}\n\t\tc[k] += carry;\n\t}\n#\tundef I\n\tif (c[0] == '0') memmove(c, c + 1, la + lb);\n\n\treturn;\n}\n\nint main()\n{\n\tchar c[1024];\n\tlongmulti(\"-18446744073709551616\", \"-18446744073709551616\", c);\n\tprintf(\"%s\\n\", c);\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\nfunction longMult($a, $b)\n{\n  $as = (string) $a;\n  $bs = (string) $b;\n  for($pi = 0, $ai = strlen($as) - 1; $ai >= 0; $pi++, $ai--)\n    {\n      for($p = 0; $p < $pi; $p++)\n        {\n          $regi[$ai][] = 0;\n        }\n      for($bi = strlen($bs) - 1; $bi >= 0; $bi--)\n        {\n          $regi[$ai][] = $as[$ai] * $bs[$bi];\n        }\n    }\n  return $regi;\n}\n\nfunction longAdd($arr)\n{\n  $outer = count($arr);\n  $inner = count($arr[$outer-1]) + $outer;\n  for($i = 0; $i <= $inner; $i++)\n    {\n      for($o = 0; $o < $outer; $o++)\n        {\n          $val  = isset($arr[$o][$i]) ? $arr[$o][$i] : 0;\n          @$sum[$i] += $val;\n        }\n    }\n  return $sum;\n}\n\nfunction carry($arr)\n{\n  for($i = 0; $i < count($arr); $i++)\n    {\n      $s = (string) $arr[$i];\n      switch(strlen($s))\n        {\n          case 2:\n            $arr[$i] = $s{1};\n            @$arr[$i+1] += $s{0};\n            break;\n          case 3:\n            $arr[$i] = $s{2};\n            @$arr[$i+1] += $s{0}.$s{1};\n            break;\n        }\n    }\n  return ltrim(implode('',array_reverse($arr)),'0');\n}\n\nfunction lm($a,$b)\n{\n  return carry(longAdd(longMult($a,$b)));\n}\n\nif(lm('18446744073709551616','18446744073709551616') == '340282366920938463463374607431768211456')\n  {\n    echo 'pass!';\n  }; // 2^64 * 2^64\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 166,
    "input": "Translate C to Python:#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUFFER_SIZE 128\n\ntypedef unsigned char character;\ntypedef character *string;\n\ntypedef struct node_t node;\nstruct node_t {\n    enum tag_t {\n        NODE_LEAF,\n        NODE_TREE,\n        NODE_SEQ,\n    } tag;\n\n    union {\n        string str;\n        node *root;\n    } data;\n\n    node *next;\n};\n\nnode *allocate_node(enum tag_t tag) {\n    node *n = malloc(sizeof(node));\n    if (n == NULL) {\n        fprintf(stderr, \"Failed to allocate node for tag: %d\\n\", tag);\n        exit(1);\n    }\n    n->tag = tag;\n    n->next = NULL;\n    return n;\n}\n\nnode *make_leaf(string str) {\n    node *n = allocate_node(NODE_LEAF);\n    n->data.str = str;\n    return n;\n}\n\nnode *make_tree() {\n    node *n = allocate_node(NODE_TREE);\n    n->data.root = NULL;\n    return n;\n}\n\nnode *make_seq() {\n    node *n = allocate_node(NODE_SEQ);\n    n->data.root = NULL;\n    return n;\n}\n\nvoid deallocate_node(node *n) {\n    if (n == NULL) {\n        return;\n    }\n\n    deallocate_node(n->next);\n    n->next = NULL;\n\n    if (n->tag == NODE_LEAF) {\n        free(n->data.str);\n        n->data.str = NULL;\n    } else if (n->tag == NODE_TREE || n->tag == NODE_SEQ) {\n        deallocate_node(n->data.root);\n        n->data.root = NULL;\n    } else {\n        fprintf(stderr, \"Cannot deallocate node with tag: %d\\n\", n->tag);\n        exit(1);\n    }\n\n    free(n);\n}\n\nvoid append(node *root, node *elem) {\n    if (root == NULL) {\n        fprintf(stderr, \"Cannot append to uninitialized node.\");\n        exit(1);\n    }\n    if (elem == NULL) {\n        return;\n    }\n\n    if (root->tag == NODE_SEQ || root->tag == NODE_TREE) {\n        if (root->data.root == NULL) {\n            root->data.root = elem;\n        } else {\n            node *it = root->data.root;\n            while (it->next != NULL) {\n                it = it->next;\n            }\n            it->next = elem;\n        }\n    } else {\n        fprintf(stderr, \"Cannot append to node with tag: %d\\n\", root->tag);\n        exit(1);\n    }\n}\n\nsize_t count(node *n) {\n    if (n == NULL) {\n        return 0;\n    }\n\n    if (n->tag == NODE_LEAF) {\n        return 1;\n    }\n    if (n->tag == NODE_TREE) {\n        size_t sum = 0;\n        node *it = n->data.root;\n        while (it != NULL) {\n            sum += count(it);\n            it = it->next;\n        }\n        return sum;\n    }\n    if (n->tag == NODE_SEQ) {\n        size_t prod = 1;\n        node *it = n->data.root;\n        while (it != NULL) {\n            prod *= count(it);\n            it = it->next;\n        }\n        return prod;\n    }\n\n    fprintf(stderr, \"Cannot count node with tag: %d\\n\", n->tag);\n    exit(1);\n}\n\nvoid expand(node *n, size_t pos) {\n    if (n == NULL) {\n        return;\n    }\n\n    if (n->tag == NODE_LEAF) {\n        printf(n->data.str);\n    } else if (n->tag == NODE_TREE) {\n        node *it = n->data.root;\n        while (true) {\n            size_t cnt = count(it);\n            if (pos < cnt) {\n                expand(it, pos);\n                break;\n            }\n            pos -= cnt;\n            it = it->next;\n        }\n    } else if (n->tag == NODE_SEQ) {\n        size_t prod = pos;\n        node *it = n->data.root;\n        while (it != NULL) {\n            size_t cnt = count(it);\n\n            size_t rem = prod % cnt;\n            expand(it, rem);\n\n            it = it->next;\n        }\n    } else {\n        fprintf(stderr, \"Cannot expand node with tag: %d\\n\", n->tag);\n        exit(1);\n    }\n}\n\nstring allocate_string(string src) {\n    size_t len = strlen(src);\n    string out = calloc(len + 1, sizeof(character));\n    if (out == NULL) {\n        fprintf(stderr, \"Failed to allocate a copy of the string.\");\n        exit(1);\n    }\n    strcpy(out, src);\n    return out;\n}\n\nnode *parse_seq(string input, size_t *pos);\n\nnode *parse_tree(string input, size_t *pos) {\n    node *root = make_tree();\n\n    character buffer[BUFFER_SIZE] = { 0 };\n    size_t bufpos = 0;\n    size_t depth = 0;\n    bool asSeq = false;\n    bool allow = false;\n\n    while (input[*pos] != 0) {\n        character c = input[(*pos)++];\n        if (c == '\\\\') {\n            c = input[(*pos)++];\n            if (c == 0) {\n                break;\n            }\n            buffer[bufpos++] = '\\\\';\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        } else if (c == '{') {\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n            asSeq = true;\n            depth++;\n        } else if (c == '}') {\n            if (depth-- > 0) {\n                buffer[bufpos++] = c;\n                buffer[bufpos] = 0;\n            } else {\n                if (asSeq) {\n                    size_t new_pos = 0;\n                    node *seq = parse_seq(buffer, &new_pos);\n                    append(root, seq);\n                } else {\n                    append(root, make_leaf(allocate_string(buffer)));\n                }\n                break;\n            }\n        } else if (c == ',') {\n            if (depth == 0) {\n                if (asSeq) {\n                    size_t new_pos = 0;\n                    node *seq = parse_seq(buffer, &new_pos);\n                    append(root, seq);\n                    bufpos = 0;\n                    buffer[bufpos] = 0;\n                    asSeq = false;\n                } else {\n                    append(root, make_leaf(allocate_string(buffer)));\n                    bufpos = 0;\n                    buffer[bufpos] = 0;\n                }\n            } else {\n                buffer[bufpos++] = c;\n                buffer[bufpos] = 0;\n            }\n        } else {\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        }\n    }\n\n    return root;\n}\n\nnode *parse_seq(string input, size_t *pos) {\n    node *root = make_seq();\n\n    character buffer[BUFFER_SIZE] = { 0 };\n    size_t bufpos = 0;\n\n    while (input[*pos] != 0) {\n        character c = input[(*pos)++];\n        if (c == '\\\\') {\n            c = input[(*pos)++];\n            if (c == 0) {\n                break;\n            }\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        } else if (c == '{') {\n            node *tree = parse_tree(input, pos);\n            if (bufpos > 0) {\n                append(root, make_leaf(allocate_string(buffer)));\n                bufpos = 0;\n                buffer[bufpos] = 0;\n            }\n            append(root, tree);\n        } else {\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        }\n    }\n\n    if (bufpos > 0) {\n        append(root, make_leaf(allocate_string(buffer)));\n        bufpos = 0;\n        buffer[bufpos] = 0;\n    }\n\n    return root;\n}\n\nvoid test(string input) {\n    size_t pos = 0;\n    node *n = parse_seq(input, &pos);\n    size_t cnt = count(n);\n    size_t i;\n\n    printf(\"Pattern: %s\\n\", input);\n\n    for (i = 0; i < cnt; i++) {\n        expand(n, i);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    deallocate_node(n);\n}\n\nint main() {\n    test(\"~/{Downloads,Pictures}/*.{jpg,gif,png}\");\n    test(\"It{{em,alic}iz,erat}e{d,}, please.\");\n    test(\"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\");\n\n    \n    \n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def getitem(s, depth=0):\n    out = [\"\"]\n    while s:\n        c = s[0]\n        if depth and (c == ',' or c == '}'):\n            return out,s\n        if c == '{':\n            x = getgroup(s[1:], depth+1)\n            if x:\n                out,s = [a+b for a in out for b in x[0]], x[1]\n                continue\n        if c == '\\\\' and len(s) > 1:\n            s, c = s[1:], c + s[1]\n\n        out, s = [a+c for a in out], s[1:]\n\n    return out,s\n\ndef getgroup(s, depth):\n    out, comma = [], False\n    while s:\n        g,s = getitem(s, depth)\n        if not s: break\n        out += g\n\n        if s[0] == '}':\n            if comma: return out, s[1:]\n            return ['{' + a + '}' for a in out], s[1:]\n\n        if s[0] == ',':\n            comma,s = True, s[1:]\n\n    return None\n\n\nfor s in .split('\\n'):\n    print \"\\n\\t\".join([s] + getitem(s)[0]) + \"\\n\"\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 167,
    "input": "Translate Java to Go:public class Pali23 {\n\tpublic static boolean isPali(String x){\n\t\treturn x.equals(new StringBuilder(x).reverse().toString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(long i = 0, count = 0; count < 6;i++){\n\t\t\tif((i & 1) == 0 && (i != 0)) continue; \n\t\t\t\n\t\t\t\n\t\t\tif(isPali(Long.toBinaryString(i)) && isPali(Long.toString(i, 3))){\n\t\t\t\tSystem.out.println(i + \", \" + Long.toBinaryString(i) + \", \" + Long.toString(i, 3));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n)\n\nfunc isPalindrome2(n uint64) bool {\n    x := uint64(0)\n    if (n & 1) == 0 {\n        return n == 0\n    }\n    for x < n {\n        x = (x << 1) | (n & 1)\n        n >>= 1\n    }\n    return n == x || n == (x>>1)\n}\n\nfunc reverse3(n uint64) uint64 {\n    x := uint64(0)\n    for n != 0 {\n        x = x*3 + (n % 3)\n        n /= 3\n    }\n    return x\n}\n\nfunc show(n uint64) {\n    fmt.Println(\"Decimal :\", n)\n    fmt.Println(\"Binary  :\", strconv.FormatUint(n, 2))\n    fmt.Println(\"Ternary :\", strconv.FormatUint(n, 3))\n    fmt.Println(\"Time    :\", time.Since(start))\n    fmt.Println()\n}\n\nfunc min(a, b uint64) uint64 {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc max(a, b uint64) uint64 {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nvar start time.Time\n\nfunc main() {\n    start = time.Now()\n    fmt.Println(\"The first 7 numbers which are palindromic in both binary and ternary are :\\n\")\n    show(0)\n    cnt := 1\n    var lo, hi, pow2, pow3 uint64 = 0, 1, 1, 1\n    for {\n        i := lo\n        for ; i < hi; i++ {\n            n := (i*3+1)*pow3 + reverse3(i)\n            if !isPalindrome2(n) {\n                continue\n            }\n            show(n)\n            cnt++\n            if cnt >= 7 {\n                return\n            }\n        }\n\n        if i == pow3 {\n            pow3 *= 3\n        } else {\n            pow2 *= 4\n        }\n\n        for {\n            for pow2 <= pow3 {\n                pow2 *= 4\n            }\n\n            lo2 := (pow2/pow3 - 1) / 3\n            hi2 := (pow2*2/pow3-1)/3 + 1\n            lo3 := pow3 / 3\n            hi3 := pow3\n\n            if lo2 >= hi3 {\n                pow3 *= 3\n            } else if lo3 >= hi2 {\n                pow2 *= 4\n            } else {\n                lo = max(lo2, lo3)\n                hi = min(hi2, hi3)\n                break\n            }\n        }\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 168,
    "input": "Translate C to Java:#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <time.h>\n\nbool is_prime(unsigned int n) {\n    assert(n < 64);\n    static bool isprime[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0,\n                             0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,\n                             0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n                             0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0};\n    return isprime[n];\n}\n\nvoid swap(unsigned int* a, size_t i, size_t j) {\n    unsigned int tmp = a[i];\n    a[i] = a[j];\n    a[j] = tmp;\n}\n\nbool prime_triangle_row(unsigned int* a, size_t length) {\n    if (length == 2)\n        return is_prime(a[0] + a[1]);\n    for (size_t i = 1; i + 1 < length; i += 2) {\n        if (is_prime(a[0] + a[i])) {\n            swap(a, i, 1);\n            if (prime_triangle_row(a + 1, length - 1))\n                return true;\n            swap(a, i, 1);\n        }\n    }\n    return false;\n}\n\nint prime_triangle_count(unsigned int* a, size_t length) {\n    int count = 0;\n    if (length == 2) {\n        if (is_prime(a[0] + a[1]))\n            ++count;\n    } else {\n        for (size_t i = 1; i + 1 < length; i += 2) {\n            if (is_prime(a[0] + a[i])) {\n                swap(a, i, 1);\n                count += prime_triangle_count(a + 1, length - 1);\n                swap(a, i, 1);\n            }\n        }\n    }\n    return count;\n}\n\nvoid print(unsigned int* a, size_t length) {\n    if (length == 0)\n        return;\n    printf(\"%2u\", a[0]);\n    for (size_t i = 1; i < length; ++i)\n        printf(\" %2u\", a[i]);\n    printf(\"\\n\");\n}\n\nint main() {\n    clock_t start = clock();\n    for (unsigned int n = 2; n < 21; ++n) {\n        unsigned int a[n];\n        for (unsigned int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        if (prime_triangle_row(a, n))\n            print(a, n);\n    }\n    printf(\"\\n\");\n    for (unsigned int n = 2; n < 21; ++n) {\n        unsigned int a[n];\n        for (unsigned int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        if (n > 2)\n            printf(\" \");\n        printf(\"%d\", prime_triangle_count(a, n));\n    }\n    printf(\"\\n\");\n    clock_t end = clock();\n    double duration = (end - start + 0.0) / CLOCKS_PER_SEC;\n    printf(\"\\nElapsed time: %f seconds\\n\", duration);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class PrimeTriangle {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (findRow(a, 0, i))\n                printRow(a);                \n        }\n        System.out.println();\n        StringBuilder s = new StringBuilder();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (i > 2)\n                s.append(\" \");\n            s.append(countRows(a, 0, i));\n        }\n        System.out.println(s);\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"\\nElapsed time: %d milliseconds\\n\", finish - start);\n    }\n\n    private static void printRow(int[] a) {\n        for (int i = 0; i < a.length; ++i) {\n            if (i != 0)\n                System.out.print(\" \");\n            System.out.printf(\"%2d\", a[i]);\n        }\n        System.out.println();\n    }\n\n    private static boolean findRow(int[] a, int start, int length) {\n        if (length == 2)\n            return isPrime(a[start] + a[start + 1]);\n        for (int i = 1; i + 1 < length; i += 2) {\n            if (isPrime(a[start] + a[start + i])) {\n                swap(a, start + i, start + 1);\n                if (findRow(a, start + 1, length - 1))\n                    return true;\n                swap(a, start + i, start + 1);\n            }\n        }\n        return false;\n    }\n\n    private static int countRows(int[] a, int start, int length) {\n        int count = 0;\n        if (length == 2) {\n            if (isPrime(a[start] + a[start + 1]))\n                ++count;\n        } else {\n            for (int i = 1; i + 1 < length; i += 2) {\n                if (isPrime(a[start] + a[start + i])) {\n                    swap(a, start + i, start + 1);\n                    count += countRows(a, start + 1, length - 1);\n                    swap(a, start + i, start + 1);\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void swap(int[] a, int i, int j) {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    private static boolean isPrime(int n) {\n        return ((1L << n) & 0x28208a20a08a28acL) != 0;\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 169,
    "input": "Translate PHP to Go:for ($i = 10; $i >= 0; $i--)\n  echo \"$i\\n\";\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "for i := 10; i >= 0; i-- {\n  fmt.Println(i)\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 170,
    "input": "Translate C to Java:#include <stdio.h>\n#include <math.h>\n\n#define C 7\ntypedef struct { double x, y; } pt;\n\npt zero(void) { return (pt){ INFINITY, INFINITY }; }\n\n\nint is_zero(pt p) { return p.x > 1e20 || p.x < -1e20; }\n\npt neg(pt p) { return (pt){ p.x, -p.y }; }\n\npt dbl(pt p) {\n\tif (is_zero(p)) return p;\n\n\tpt r;\n\tdouble L = (3 * p.x * p.x) / (2 * p.y);\n\tr.x = L * L - 2 * p.x;\n\tr.y = L * (p.x - r.x) - p.y;\n\treturn r;\n}\n\npt add(pt p, pt q) {\n\tif (p.x == q.x && p.y == q.y) return dbl(p);\n\tif (is_zero(p)) return q;\n\tif (is_zero(q)) return p;\n\n\tpt r;\n\tdouble L = (q.y - p.y) / (q.x - p.x);\n\tr.x = L * L - p.x - q.x;\n\tr.y = L * (p.x - r.x) - p.y;\n\treturn r;\n}\n\npt mul(pt p, int n) {\n\tint i;\n\tpt r = zero();\n\n\tfor (i = 1; i <= n; i <<= 1) {\n\t\tif (i & n) r = add(r, p);\n\t\tp = dbl(p);\n\t}\n\treturn r;\n}\n\nvoid show(const char *s, pt p) {\n\tprintf(\"%s\", s);\n\tprintf(is_zero(p) ? \"Zero\\n\" : \"(%.3f, %.3f)\\n\", p.x, p.y);\n}\n\npt from_y(double y) {\n\tpt r;\n\tr.x = pow(y * y - C, 1.0/3);\n\tr.y = y;\n\treturn r;\n}\n\nint main(void) {\n\tpt a, b, c, d;\n\n\ta = from_y(1);\n\tb = from_y(2);\n\n\tshow(\"a = \", a);\n\tshow(\"b = \", b);\n\tshow(\"c = a + b = \", c = add(a, b));\n\tshow(\"d = -c = \", d = neg(c));\n\tshow(\"c + d = \", add(c, d));\n\tshow(\"a + b + d = \", add(a, add(b, d)));\n\tshow(\"a * 12345 = \", mul(a, 12345));\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import static java.lang.Math.*;\nimport java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Pt a = Pt.fromY(1);\n        Pt b = Pt.fromY(2);\n        System.out.printf(\"a = %s%n\", a);\n        System.out.printf(\"b = %s%n\", b);\n        Pt c = a.plus(b);\n        System.out.printf(\"c = a + b = %s%n\", c);\n        Pt d = c.neg();\n        System.out.printf(\"d = -c = %s%n\", d);\n        System.out.printf(\"c + d = %s%n\", c.plus(d));\n        System.out.printf(\"a + b + d = %s%n\", a.plus(b).plus(d));\n        System.out.printf(\"a * 12345 = %s%n\", a.mult(12345));\n    }\n}\n\nclass Pt {\n    final static int bCoeff = 7;\n\n    double x, y;\n\n    Pt(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    static Pt zero() {\n        return new Pt(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    boolean isZero() {\n        return this.x > 1e20 || this.x < -1e20;\n    }\n\n    static Pt fromY(double y) {\n        return new Pt(cbrt(pow(y, 2) - bCoeff), y);\n    }\n\n    Pt dbl() {\n        if (isZero())\n            return this;\n        double L = (3 * this.x * this.x) / (2 * this.y);\n        double x2 = pow(L, 2) - 2 * this.x;\n        return new Pt(x2, L * (this.x - x2) - this.y);\n    }\n\n    Pt neg() {\n        return new Pt(this.x, -this.y);\n    }\n\n    Pt plus(Pt q) {\n        if (this.x == q.x && this.y == q.y)\n            return dbl();\n\n        if (isZero())\n            return q;\n\n        if (q.isZero())\n            return this;\n\n        double L = (q.y - this.y) / (q.x - this.x);\n        double xx = pow(L, 2) - this.x - q.x;\n        return new Pt(xx, L * (this.x - xx) - this.y);\n    }\n\n    Pt mult(int n) {\n        Pt r = Pt.zero();\n        Pt p = this;\n        for (int i = 1; i <= n; i <<= 1) {\n            if ((i & n) != 0)\n                r = r.plus(p);\n            p = p.dbl();\n        }\n        return r;\n    }\n\n    @Override\n    public String toString() {\n        if (isZero())\n            return \"Zero\";\n        return String.format(Locale.US, \"(%.3f,%.3f)\", this.x, this.y);\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 171,
    "input": "Translate Java to VB:for (Integer i = 0; i < 5; i++) {\n    String line = '';\n\n    for (Integer j = 0; j < i; j++) {\n        line += '*';\n    }\n\n    System.debug(line);\n}\n\nList<String> lines = new List<String> {\n    '*',\n    '**',\n    '***',\n    '****',\n    '*****'\n};\n\nfor (String line : lines) {\n    System.debug(line);\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Public OutConsole As Scripting.TextStream\nFor i = 0 To 4\n    For j = 0 To i\n        OutConsole.Write \"*\"\n    Next j \n    OutConsole.WriteLine\nNext i\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 172,
    "input": "Translate Java to Python:import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport javax.xml.ws.Holder;\n\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\npublic class XmlValidation {\n\tpublic static void main(String... args) throws MalformedURLException {\n\t\tURL schemaLocation = new URL(\"http:\n\t\tURL documentLocation = new URL(\"http:\n\t\tif (validate(schemaLocation, documentLocation)) {\n\t\t\tSystem.out.println(\"document is valid\");\n\t\t} else {\n\t\t\tSystem.out.println(\"document is invalid\");\n\t\t}\n\t}\n\n\t\n\tpublic static boolean minimalValidate(URL schemaLocation, URL documentLocation) {\n\t\tSchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);\n\t\ttry {\n\t\t\tValidator validator = factory.newSchema(schemaLocation).newValidator();\n\t\t\tvalidator.validate(new StreamSource(documentLocation.toString()));\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t\n\tpublic static boolean validate(URL schemaLocation, URL documentLocation) {\n\t\tSchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);\n\t\tfinal Holder<Boolean> valid = new Holder<>(true);\n\t\ttry {\n\t\t\tValidator validator = factory.newSchema(schemaLocation).newValidator();\n\t\t\t\n\t\t\tvalidator.setErrorHandler(new ErrorHandler(){\n\t\t\t\t@Override\n\t\t\t\tpublic void warning(SAXParseException exception) {\n\t\t\t\t\tSystem.out.println(\"warning: \" + exception.getMessage());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void error(SAXParseException exception) {\n\t\t\t\t\tSystem.out.println(\"error: \" + exception.getMessage());\n\t\t\t\t\tvalid.value = false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void fatalError(SAXParseException exception) throws SAXException {\n\t\t\t\t\tSystem.out.println(\"fatal error: \" + exception.getMessage());\n\t\t\t\t\tthrow exception;\n\t\t\t\t}});\n\t\t\tvalidator.validate(new StreamSource(documentLocation.toString()));\n\t\t\treturn valid.value;\n\t\t} catch (SAXException e) {\n\t\t\t\n\t\t\treturn false;\n\t\t} catch (Exception e) {\n\t\t\t\n\t\t\tSystem.err.println(e);\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\nfrom __future__ import print_function\nimport lxml\nfrom lxml import etree\n\nif __name__==\"__main__\":\n\n\tparser = etree.XMLParser(dtd_validation=True)\n\tschema_root = etree.XML()\n\tschema = etree.XMLSchema(schema_root)\n\n\t\n\tparser = etree.XMLParser(schema = schema)\n\ttry:\n\t\troot = etree.fromstring(\"<a>5</a>\", parser)\n\t\tprint (\"Finished validating good xml\")\n\texcept lxml.etree.XMLSyntaxError as err:\n\t\tprint (err)\n\n\t\n\tparser = etree.XMLParser(schema = schema)\n\ttry:\n\t\troot = etree.fromstring(\"<a>5<b>foobar</b></a>\", parser)\n\texcept lxml.etree.XMLSyntaxError as err:\n\t\tprint (err)\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 173,
    "input": "Translate C# to Go:using System;\nusing System.Collections.Generic;\n\nnamespace PeacefulChessQueenArmies {\n    using Position = Tuple<int, int>;\n\n    enum Piece {\n        Empty,\n        Black,\n        White\n    }\n\n    class Program {\n        static bool IsAttacking(Position queen, Position pos) {\n            return queen.Item1 == pos.Item1\n                || queen.Item2 == pos.Item2\n                || Math.Abs(queen.Item1 - pos.Item1) == Math.Abs(queen.Item2 - pos.Item2);\n        }\n\n        static bool Place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n            if (m == 0) {\n                return true;\n            }\n            bool placingBlack = true;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    var pos = new Position(i, j);\n                    foreach (var queen in pBlackQueens) {\n                        if (queen.Equals(pos) || !placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    foreach (var queen in pWhiteQueens) {\n                        if (queen.Equals(pos) || placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    if (placingBlack) {\n                        pBlackQueens.Add(pos);\n                        placingBlack = false;\n                    } else {\n                        pWhiteQueens.Add(pos);\n                        if (Place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                            return true;\n                        }\n                        pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n                        pWhiteQueens.RemoveAt(pWhiteQueens.Count - 1);\n                        placingBlack = true;\n                    }\n                inner: { }\n                }\n            }\n            if (!placingBlack) {\n                pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n            }\n            return false;\n        }\n\n        static void PrintBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n            var board = new Piece[n * n];\n\n            foreach (var queen in blackQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.Black;\n            }\n            foreach (var queen in whiteQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.White;\n            }\n\n            for (int i = 0; i < board.Length; i++) {\n                if (i != 0 && i % n == 0) {\n                    Console.WriteLine();\n                }\n                switch (board[i]) {\n                    case Piece.Black:\n                        Console.Write(\"B \");\n                        break;\n                    case Piece.White:\n                        Console.Write(\"W \");\n                        break;\n                    case Piece.Empty:\n                        int j = i / n;\n                        int k = i - j * n;\n                        if (j % 2 == k % 2) {\n                            Console.Write(\"  \");\n                        } else {\n                            Console.Write(\"# \");\n                        }\n                        break;\n                }\n            }\n\n            Console.WriteLine(\"\\n\");\n        }\n\n        static void Main() {\n            var nms = new int[,] {\n                {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},\n                {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},\n                {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},\n                {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},\n            };\n            for (int i = 0; i < nms.GetLength(0); i++) {\n                Console.WriteLine(\"{0} black and {0} white queens on a {1} x {1} board:\", nms[i, 1], nms[i, 0]);\n                List<Position> blackQueens = new List<Position>();\n                List<Position> whiteQueens = new List<Position>();\n                if (Place(nms[i, 1], nms[i, 0], blackQueens, whiteQueens)) {\n                    PrintBoard(nms[i, 0], blackQueens, whiteQueens);\n                } else {\n                    Console.WriteLine(\"No solution exists.\\n\");\n                }\n            }\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nconst (\n    empty = iota\n    black\n    white\n)\n\nconst (\n    bqueen  = 'B'\n    wqueen  = 'W'\n    bbullet = '•'\n    wbullet = '◦'\n)\n\ntype position struct{ i, j int }\n\nfunc iabs(i int) int {\n    if i < 0 {\n        return -i\n    }\n    return i\n}\n\nfunc place(m, n int, pBlackQueens, pWhiteQueens *[]position) bool {\n    if m == 0 {\n        return true\n    }\n    placingBlack := true\n    for i := 0; i < n; i++ {\n    inner:\n        for j := 0; j < n; j++ {\n            pos := position{i, j}\n            for _, queen := range *pBlackQueens {\n                if queen == pos || !placingBlack && isAttacking(queen, pos) {\n                    continue inner\n                }\n            }\n            for _, queen := range *pWhiteQueens {\n                if queen == pos || placingBlack && isAttacking(queen, pos) {\n                    continue inner\n                }\n            }\n            if placingBlack {\n                *pBlackQueens = append(*pBlackQueens, pos)\n                placingBlack = false\n            } else {\n                *pWhiteQueens = append(*pWhiteQueens, pos)\n                if place(m-1, n, pBlackQueens, pWhiteQueens) {\n                    return true\n                }\n                *pBlackQueens = (*pBlackQueens)[0 : len(*pBlackQueens)-1]\n                *pWhiteQueens = (*pWhiteQueens)[0 : len(*pWhiteQueens)-1]\n                placingBlack = true\n            }\n        }\n    }\n    if !placingBlack {\n        *pBlackQueens = (*pBlackQueens)[0 : len(*pBlackQueens)-1]\n    }\n    return false\n}\n\nfunc isAttacking(queen, pos position) bool {\n    if queen.i == pos.i {\n        return true\n    }\n    if queen.j == pos.j {\n        return true\n    }\n    if iabs(queen.i-pos.i) == iabs(queen.j-pos.j) {\n        return true\n    }\n    return false\n}\n\nfunc printBoard(n int, blackQueens, whiteQueens []position) {\n    board := make([]int, n*n)\n    for _, queen := range blackQueens {\n        board[queen.i*n+queen.j] = black\n    }\n    for _, queen := range whiteQueens {\n        board[queen.i*n+queen.j] = white\n    }\n\n    for i, b := range board {\n        if i != 0 && i%n == 0 {\n            fmt.Println()\n        }\n        switch b {\n        case black:\n            fmt.Printf(\"%c \", bqueen)\n        case white:\n            fmt.Printf(\"%c \", wqueen)\n        case empty:\n            if i%2 == 0 {\n                fmt.Printf(\"%c \", bbullet)\n            } else {\n                fmt.Printf(\"%c \", wbullet)\n            }\n        }\n    }\n    fmt.Println(\"\\n\")\n}\n\nfunc main() {\n    nms := [][2]int{\n        {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},\n        {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},\n        {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},\n        {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},\n    }\n    for _, nm := range nms {\n        n, m := nm[0], nm[1]\n        fmt.Printf(\"%d black and %d white queens on a %d x %d board:\\n\", m, m, n, n)\n        var blackQueens, whiteQueens []position\n        if place(m, n, &blackQueens, &whiteQueens) {\n            printBoard(n, blackQueens, whiteQueens)\n        } else {\n            fmt.Println(\"No solution exists.\\n\")\n        }\n    }\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 174,
    "input": "Translate Java to Python:import java.math.BigInteger;\nimport java.util.List;\n\npublic class Base58CheckEncoding {\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    private static final BigInteger BIG0 = BigInteger.ZERO;\n    private static final BigInteger BIG58 = BigInteger.valueOf(58);\n\n    private static String convertToBase58(String hash) {\n        return convertToBase58(hash, 16);\n    }\n\n    private static String convertToBase58(String hash, int base) {\n        BigInteger x;\n        if (base == 16 && hash.substring(0, 2).equals(\"0x\")) {\n            x = new BigInteger(hash.substring(2), 16);\n        } else {\n            x = new BigInteger(hash, base);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (x.compareTo(BIG0) > 0) {\n            int r = x.mod(BIG58).intValue();\n            sb.append(ALPHABET.charAt(r));\n            x = x.divide(BIG58);\n        }\n\n        return sb.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"25420294593250030202636073700053352635053786165627414518\";\n        String b = convertToBase58(s, 10);\n        System.out.printf(\"%s -> %s\\n\", s, b);\n\n        List<String> hashes = List.of(\n            \"0x61\",\n            \"0x626262\",\n            \"0x636363\",\n            \"0x73696d706c792061206c6f6e6720737472696e67\",\n            \"0x516b6fcd0f\",\n            \"0xbf4f89001e670274dd\",\n            \"0x572e4794\",\n            \"0xecac89cad93923c02321\",\n            \"0x10c8511e\"\n        );\n        for (String hash : hashes) {\n            String b58 = convertToBase58(hash);\n            System.out.printf(\"%-56s -> %s\\n\", hash, b58);\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef convertToBase58(num):\n    sb = ''\n    while (num > 0):\n        r = num % 58\n        sb = sb + ALPHABET[r]\n        num = num // 58;\n    return sb[::-1]\n\ns = 25420294593250030202636073700053352635053786165627414518\nb = convertToBase58(s)\nprint(\"%-56d -> %s\" % (s, b))\n\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\nfor num in hash_arr:\n    b = convertToBase58(num)\n    print(\"0x%-54x -> %s\" % (num, b))\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 175,
    "input": "Translate PHP to Python:function addsub($x, $y) {\n  return array($x + $y, $x - $y);\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def addsub(x, y):\n  return x + y, x - y\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 176,
    "input": "Translate Go to VB:package main\n\nimport \"fmt\"\n\ntype Item struct {\n\tName           string\n\tValue          int\n\tWeight, Volume float64\n}\n\ntype Result struct {\n\tCounts []int\n\tSum    int\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc Knapsack(items []Item, weight, volume float64) (best Result) {\n\tif len(items) == 0 {\n\t\treturn\n\t}\n\tn := len(items) - 1\n\tmaxCount := min(int(weight/items[n].Weight), int(volume/items[n].Volume))\n\tfor count := 0; count <= maxCount; count++ {\n\t\tsol := Knapsack(items[:n],\n\t\t\tweight-float64(count)*items[n].Weight,\n\t\t\tvolume-float64(count)*items[n].Volume)\n\t\tsol.Sum += items[n].Value * count\n\t\tif sol.Sum > best.Sum {\n\t\t\tsol.Counts = append(sol.Counts, count)\n\t\t\tbest = sol\n\t\t}\n\t}\n\treturn\n}\n\nfunc main() {\n\titems := []Item{\n\t\t{\"Panacea\", 3000, 0.3, 0.025},\n\t\t{\"Ichor\", 1800, 0.2, 0.015},\n\t\t{\"Gold\", 2500, 2.0, 0.002},\n\t}\n\tvar sumCount, sumValue int\n\tvar sumWeight, sumVolume float64\n\n\tresult := Knapsack(items, 25, 0.25)\n\n\tfor i := range result.Counts {\n\t\tfmt.Printf(\"%-8s x%3d  -> Weight: %4.1f  Volume: %5.3f  Value: %6d\\n\",\n\t\t\titems[i].Name, result.Counts[i], items[i].Weight*float64(result.Counts[i]),\n\t\t\titems[i].Volume*float64(result.Counts[i]), items[i].Value*result.Counts[i])\n\n\t\tsumCount += result.Counts[i]\n\t\tsumValue += items[i].Value * result.Counts[i]\n\t\tsumWeight += items[i].Weight * float64(result.Counts[i])\n\t\tsumVolume += items[i].Volume * float64(result.Counts[i])\n\t}\n\n\tfmt.Printf(\"TOTAL (%3d items) Weight: %4.1f  Volume: %5.3f  Value: %6d\\n\",\n\t\tsumCount, sumWeight, sumVolume, sumValue)\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Function Min(E1, E2): Min = IIf(E1 < E2, E1, E2): End Function \n\nSub Main()\nConst Value = 0, Weight = 1, Volume = 2, PC = 3, IC = 4, GC = 5\nDim P&, I&, G&, A&, M, Cur(Value To Volume)\nDim S As New Collection: S.Add Array(0) \n\nConst SackW = 25, SackV = 0.25\nDim Panacea: Panacea = Array(3000, 0.3, 0.025)\nDim Ichor:     Ichor = Array(1800, 0.2, 0.015)\nDim Gold:       Gold = Array(2500, 2, 0.002)\n\n  For P = 0 To Int(Min(SackW / Panacea(Weight), SackV / Panacea(Volume)))\n    For I = 0 To Int(Min(SackW / Ichor(Weight), SackV / Ichor(Volume)))\n      For G = 0 To Int(Min(SackW / Gold(Weight), SackV / Gold(Volume)))\n        For A = Value To Volume: Cur(A) = G * Gold(A) + I * Ichor(A) + P * Panacea(A): Next\n        If Cur(Value) >= S(1)(Value) And Cur(Weight) <= SackW And Cur(Volume) <= SackV Then _\n          S.Add Array(Cur(Value), Cur(Weight), Cur(Volume), P, I, G), , 1\n  Next G, I, P\n  \n  Debug.Print \"Value\", \"Weight\", \"Volume\", \"PanaceaCount\", \"IchorCount\", \"GoldCount\"\n  For Each M In S \n    If M(Value) = S(1)(Value) Then Debug.Print M(Value), M(Weight), M(Volume), M(PC), M(IC), M(GC)\n  Next\nEnd Sub\n",
    "input_language": "Go",
    "output_language": "VB"
  },
  {
    "id": 177,
    "input": "Translate Java to VB:String str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n\nSystem.out.println(\"äàâáçñßæεбế\".toUpperCase());\nSystem.out.println(\"ÄÀÂÁÇÑSSÆΕБẾ\".toLowerCase()); \n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Sub Main()\nConst TESTSTRING As String = \"alphaBETA\"\nDebug.Print \"initial   =                                      \" _\n   & TESTSTRING\nDebug.Print \"uppercase =                                      \" _\n   & UCase(TESTSTRING)\nDebug.Print \"lowercase =                                      \" _\n   & LCase(TESTSTRING)\nDebug.Print \"first letter capitalized =                       \" _\n   & StrConv(TESTSTRING, vbProperCase)\nDebug.Print \"length (in characters) =                         \" _\n   & CStr(Len(TESTSTRING))\nDebug.Print \"length (in bytes) =                              \" _\n   & CStr(LenB(TESTSTRING))\nDebug.Print \"reversed =                                       \" _\n   & StrReverse(TESTSTRING)\nDebug.Print \"first position of letter A (case-sensitive) =    \" _\n   & InStr(1, TESTSTRING, \"A\", vbBinaryCompare)\nDebug.Print \"first position of letter A (case-insensitive) =  \" _\n   & InStr(1, TESTSTRING, \"A\", vbTextCompare)\nDebug.Print \"concatenated with \n   & TESTSTRING & \"123\"\nEnd Sub\n",
    "input_language": "Java",
    "output_language": "VB"
  },
  {
    "id": 178,
    "input": "Translate Java to Go:import java.math.BigInteger;\nimport java.util.List;\n\npublic class Base58CheckEncoding {\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    private static final BigInteger BIG0 = BigInteger.ZERO;\n    private static final BigInteger BIG58 = BigInteger.valueOf(58);\n\n    private static String convertToBase58(String hash) {\n        return convertToBase58(hash, 16);\n    }\n\n    private static String convertToBase58(String hash, int base) {\n        BigInteger x;\n        if (base == 16 && hash.substring(0, 2).equals(\"0x\")) {\n            x = new BigInteger(hash.substring(2), 16);\n        } else {\n            x = new BigInteger(hash, base);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (x.compareTo(BIG0) > 0) {\n            int r = x.mod(BIG58).intValue();\n            sb.append(ALPHABET.charAt(r));\n            x = x.divide(BIG58);\n        }\n\n        return sb.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"25420294593250030202636073700053352635053786165627414518\";\n        String b = convertToBase58(s, 10);\n        System.out.printf(\"%s -> %s\\n\", s, b);\n\n        List<String> hashes = List.of(\n            \"0x61\",\n            \"0x626262\",\n            \"0x636363\",\n            \"0x73696d706c792061206c6f6e6720737472696e67\",\n            \"0x516b6fcd0f\",\n            \"0xbf4f89001e670274dd\",\n            \"0x572e4794\",\n            \"0xecac89cad93923c02321\",\n            \"0x10c8511e\"\n        );\n        for (String hash : hashes) {\n            String b58 = convertToBase58(hash);\n            System.out.printf(\"%-56s -> %s\\n\", hash, b58);\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"math/big\"\n    \"strings\"\n)\n\nconst alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nvar big0 = new(big.Int)\nvar big58 = big.NewInt(58)\n\nfunc reverse(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}\n\nfunc convertToBase58(hash string, base int) (string, error) {\n    var x, ok = new(big.Int).SetString(hash, base)\n    if !ok {\n        return \"\", fmt.Errorf(\"'%v' is not a valid integer in base '%d'\", hash, base)\n    }\n    var sb strings.Builder\n    var rem = new(big.Int)\n    for x.Cmp(big0) == 1 {\n        x.QuoRem(x, big58, rem)\n        r := rem.Int64()\n        sb.WriteByte(alphabet[r])\n    }\n    return reverse(sb.String()), nil\n}\n\nfunc main() {\n    s := \"25420294593250030202636073700053352635053786165627414518\"\n    b, err := convertToBase58(s, 10)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(s, \"->\", b)\n    hashes := [...]string{\n        \"0x61\",\n        \"0x626262\",\n        \"0x636363\",\n        \"0x73696d706c792061206c6f6e6720737472696e67\",\n        \"0x516b6fcd0f\",\n        \"0xbf4f89001e670274dd\",\n        \"0x572e4794\",\n        \"0xecac89cad93923c02321\",\n        \"0x10c8511e\",\n    }\n    for _, hash := range hashes {\n        b58, err := convertToBase58(hash, 0)\n        if err != nil {\n            log.Fatal(err)\n        }\n        fmt.Printf(\"%-56s -> %s\\n\", hash, b58)\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 179,
    "input": "Translate C to Python:\n\n#include <stdio.h>\n\nchar vowels[] = {'a','e','i','o','u','\\n'};\n\nint len(char * str) {\n\tint i = 0;\n\twhile (str[i] != '\\n') i++;\n\treturn i;\n}\n\nint  isvowel(char c){\n\tint b = 0;\n\tint v = len(vowels);\n\tfor(int i = 0; i < v;i++) {\n\t\tif(c == vowels[i]) {\n\t\t\tb = 1;\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn b;\n}\n\nint isletter(char c){\n\treturn ((c >= 'a') && (c <= 'z') || (c >= 'A') && (c <= 'Z'));\n}\n\nint isconsonant(char c){\n\treturn isletter(c) && !isvowel(c);\n}\n\nint cVowels(char * str) {\n\tint i = 0;\n\tint count = 0;\n\twhile (str[i] != '\\n') {\n\t\tif (isvowel(str[i])) {\n\t\t\tcount++;;\n\t\t}\n\t\ti++;\n\t}\n\treturn count;\n}\n\nint cConsonants(char * str ) {\n\tint i = 0;\n\tint count = 0;\n\twhile (str[i] != '\\n') {\n\t\tif (isconsonant(str[i])) {\n\t\t\tcount++;\n\t\t}\n\t\ti++;\n\t}\n\treturn count;\n}\n\nint main() {\n\n\tchar buff[] = \"This is 1 string\\n\";\n\tprintf(\"%4d, %4d, %4d, %s\\n\", cVowels(buff), cConsonants(buff), len(buff), buff);\n\n\tchar buff2[] = \"This is a second string\\n\";\n\tprintf(\"%4d, %4d, %4d, %s\\n\", cVowels(buff2), cConsonants(buff2), len(buff2),  buff2);\n\n\n\tprintf(\"a: %d\\n\", isvowel('a'));\n\tprintf(\"b: %d\\n\", isvowel('b'));\n\tprintf(\"Z: %d\\n\", isconsonant('Z'));\n\tprintf(\"1: %d\\n\", isletter('1'));\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 180,
    "input": "Translate C++ to Go:#include <windows.h>\n#include <string>\n#include <iostream>\n \nconst int BMP_SIZE = 612;\n \nclass myBitmap {\npublic:\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\n    ~myBitmap() {\n        DeleteObject( pen ); DeleteObject( brush );\n        DeleteDC( hdc ); DeleteObject( bmp );\n    }\n    bool create( int w, int h ) {\n        BITMAPINFO bi;\n        ZeroMemory( &bi, sizeof( bi ) );\n        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\n        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\n        bi.bmiHeader.biCompression = BI_RGB;\n        bi.bmiHeader.biPlanes      = 1;\n        bi.bmiHeader.biWidth       =  w;\n        bi.bmiHeader.biHeight      = -h;\n        HDC dc = GetDC( GetConsoleWindow() );\n        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\n        if( !bmp ) return false;\n        hdc = CreateCompatibleDC( dc );\n        SelectObject( hdc, bmp );\n        ReleaseDC( GetConsoleWindow(), dc );\n        width = w; height = h;\n        return true;\n    }\n    void clear( BYTE clr = 0 ) {\n        memset( pBits, clr, width * height * sizeof( DWORD ) );\n    }\n    void setBrushColor( DWORD bClr ) {\n        if( brush ) DeleteObject( brush );\n        brush = CreateSolidBrush( bClr );\n        SelectObject( hdc, brush );\n    }\n    void setPenColor( DWORD c ) {\n        clr = c; createPen();\n    }\n    void setPenWidth( int w ) {\n        wid = w; createPen();\n    }\n    void saveBitmap( std::string path ) {\n        BITMAPFILEHEADER fileheader;\n        BITMAPINFO       infoheader;\n        BITMAP           bitmap;\n        DWORD            wb;\n        GetObject( bmp, sizeof( bitmap ), &bitmap );\n        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\n        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\n        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\n        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\n        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\n        infoheader.bmiHeader.biCompression = BI_RGB;\n        infoheader.bmiHeader.biPlanes = 1;\n        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\n        infoheader.bmiHeader.biHeight = bitmap.bmHeight;\n        infoheader.bmiHeader.biWidth = bitmap.bmWidth;\n        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\n        fileheader.bfType    = 0x4D42;\n        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\n        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\n        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\n        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, \n                                  FILE_ATTRIBUTE_NORMAL, NULL );\n        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\n        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\n        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\n        CloseHandle( file );\n        delete [] dwpBits;\n    }\n    HDC getDC() const     { return hdc; }\n    int getWidth() const  { return width; }\n    int getHeight() const { return height; }\nprivate:\n    void createPen() {\n        if( pen ) DeleteObject( pen );\n        pen = CreatePen( PS_SOLID, wid, clr );\n        SelectObject( hdc, pen );\n    }\n    HBITMAP bmp; HDC    hdc;\n    HPEN    pen; HBRUSH brush;\n    void    *pBits; int    width, height, wid;\n    DWORD    clr;\n};\nclass sierpinski {\npublic:\n    void draw( int o ) {\n        colors[0] = 0xff0000; colors[1] = 0x00ff33; colors[2] = 0x0033ff;\n        colors[3] = 0xffff00; colors[4] = 0x00ffff; colors[5] = 0xffffff;\n        bmp.create( BMP_SIZE, BMP_SIZE ); HDC dc = bmp.getDC(); \n        drawTri( dc, 0, 0, ( float )BMP_SIZE, ( float )BMP_SIZE, o / 2 );\n        bmp.setPenColor( colors[0] ); MoveToEx( dc, BMP_SIZE >> 1, 0, NULL ); \n        LineTo( dc, 0, BMP_SIZE - 1 ); LineTo( dc, BMP_SIZE - 1, BMP_SIZE - 1 );\n        LineTo( dc, BMP_SIZE >> 1, 0 ); bmp.saveBitmap( \"./st.bmp\" );\n    }\nprivate:\n    void drawTri( HDC dc, float l, float t, float r, float b, int i ) {\n        float w = r - l, h = b - t, hh = h / 2.f, ww = w / 4.f; \n        if( i ) {\n            drawTri( dc, l + ww, t, l + ww * 3.f, t + hh, i - 1 );\n            drawTri( dc, l, t + hh, l + w / 2.f, t + h, i - 1 );\n            drawTri( dc, l + w / 2.f, t + hh, l + w, t + h, i - 1 );\n        }\n        bmp.setPenColor( colors[i % 6] );\n        MoveToEx( dc, ( int )( l + ww ),          ( int )( t + hh ), NULL );\n        LineTo  ( dc, ( int )( l + ww * 3.f ),    ( int )( t + hh ) );\n        LineTo  ( dc, ( int )( l + ( w / 2.f ) ), ( int )( t + h ) );\n        LineTo  ( dc, ( int )( l + ww ),          ( int )( t + hh ) );\n    }\n    myBitmap bmp;\n    DWORD colors[6];\n};\nint main(int argc, char* argv[]) {\n    sierpinski s; s.draw( 12 );\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"image/color\"\n    \"image/draw\"\n    \"image/png\"\n    \"os\"\n)\n\nfunc main() {\n    const order = 8\n    const width = 1 << order\n    const margin = 10\n    bounds := image.Rect(-margin, -margin, width+2*margin, width+2*margin)\n    im := image.NewGray(bounds)\n    gBlack := color.Gray{0}\n    gWhite := color.Gray{255}\n    draw.Draw(im, bounds, image.NewUniform(gWhite), image.ZP, draw.Src)\n\n    for y := 0; y < width; y++ {\n        for x := 0; x < width; x++ {\n            if x&y == 0 {\n                im.SetGray(x, y, gBlack)\n            }\n        }\n    }\n    f, err := os.Create(\"sierpinski.png\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    if err = png.Encode(f, im); err != nil {\n        fmt.Println(err)\n    }\n    if err = f.Close(); err != nil {\n        fmt.Println(err)\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 181,
    "input": "Translate Java to Go:import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n  \"fmt\"\n  \"math\"\n)\n\nvar (\n  d1 = []float64{27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6,\n    23.1, 19.6, 19.0, 21.7, 21.4}\n  d2 = []float64{27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2,\n    21.9, 22.1, 22.9, 20.5, 24.4}\n  d3 = []float64{17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8}\n  d4 = []float64{21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8,\n    20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8}\n  d5 = []float64{19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0}\n  d6 = []float64{28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7,\n    23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2}\n  d7 = []float64{30.02, 29.99, 30.11, 29.97, 30.01, 29.99}\n  d8 = []float64{29.89, 29.93, 29.72, 29.98, 30.02, 29.98}\n  x  = []float64{3.0, 4.0, 1.0, 2.1}\n  y  = []float64{490.2, 340.0, 433.9}\n)\n\nfunc main() {\n  fmt.Printf(\"%.6f\\n\", pValue(d1, d2))\n  fmt.Printf(\"%.6f\\n\", pValue(d3, d4))\n  fmt.Printf(\"%.6f\\n\", pValue(d5, d6))\n  fmt.Printf(\"%.6f\\n\", pValue(d7, d8))\n  fmt.Printf(\"%.6f\\n\", pValue(x, y))\n}\n\nfunc mean(a []float64) float64 {\n  sum := 0.\n  for _, x := range a {\n    sum += x\n  }\n  return sum / float64(len(a))\n}\n\nfunc sv(a []float64) float64 {\n  m := mean(a)\n  sum := 0.\n  for _, x := range a {\n    d := x - m\n    sum += d * d\n  }\n  return sum / float64(len(a)-1)\n}\n\nfunc welch(a, b []float64) float64 {\n  return (mean(a) - mean(b)) /\n    math.Sqrt(sv(a)/float64(len(a))+sv(b)/float64(len(b)))\n}\n\nfunc dof(a, b []float64) float64 {\n  sva := sv(a)\n  svb := sv(b)\n  n := sva/float64(len(a)) + svb/float64(len(b))\n  return n * n /\n    (sva*sva/float64(len(a)*len(a)*(len(a)-1)) +\n      svb*svb/float64(len(b)*len(b)*(len(b)-1)))\n}\n\nfunc simpson0(n int, upper float64, f func(float64) float64) float64 {\n  sum := 0.\n  nf := float64(n)\n  dx0 := upper / nf\n  sum += f(0) * dx0\n  sum += f(dx0*.5) * dx0 * 4\n  x0 := dx0\n  for i := 1; i < n; i++ {\n    x1 := float64(i+1) * upper / nf\n    xmid := (x0 + x1) * .5\n    dx := x1 - x0\n    sum += f(x0) * dx * 2\n    sum += f(xmid) * dx * 4\n    x0 = x1\n  }\n  return (sum + f(upper)*dx0) / 6\n}\n\nfunc pValue(a, b []float64) float64 {\n  ν := dof(a, b)\n  t := welch(a, b)\n  g1, _ := math.Lgamma(ν / 2)\n  g2, _ := math.Lgamma(.5)\n  g3, _ := math.Lgamma(ν/2 + .5)\n  return simpson0(2000, ν/(t*t+ν),\n    func(r float64) float64 { return math.Pow(r, ν/2-1) / math.Sqrt(1-r) }) /\n    math.Exp(g1+g2-g3)\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 182,
    "input": "Translate C to PHP:#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct func_t *func;\ntypedef struct func_t {\n        func (*fn) (func, func);\n        func _;\n        int num;\n} func_t;\n\nfunc new(func(*f)(func, func), func _) {\n        func x = malloc(sizeof(func_t));\n        x->fn = f;\n        x->_ = _;       \n        x->num = 0;\n        return x;\n}\n\nfunc call(func f, func n) {\n        return f->fn(f, n);\n}\n\nfunc Y(func(*f)(func, func)) {\n        func g = new(f, 0);\n        g->_ = g;\n        return g;\n}\n\nfunc num(int n) {\n        func x = new(0, 0);\n        x->num = n;\n        return x;\n}\n\n\nfunc fac(func self, func n) {\n        int nn = n->num;\n        return nn > 1   ? num(nn * call(self->_, num(nn - 1))->num)\n                        : num(1);\n}\n\nfunc fib(func self, func n) {\n        int nn = n->num;\n        return nn > 1\n                ? num(  call(self->_, num(nn - 1))->num +\n                        call(self->_, num(nn - 2))->num )\n                : num(1);\n}\n\nvoid show(func n) { printf(\" %d\", n->num); }\n\nint main() {\n        int i;\n        func f = Y(fac);\n        printf(\"fac: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        f = Y(fib);\n        printf(\"fib: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        return 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\nfunction Y($f) {\n  $g = function($w) use($f) {\n    return $f(function() use($w) {\n      return call_user_func_array($w($w), func_get_args());\n    });\n  };\n  return $g($g);\n}\n\n$fibonacci = Y(function($f) {\n  return function($i) use($f) { return ($i <= 1) ? $i : ($f($i-1) + $f($i-2)); };\n});\n\necho $fibonacci(10), \"\\n\";\n\n$factorial = Y(function($f) {\n  return function($i) use($f) { return ($i <= 1) ? 1 : ($f($i - 1) * $i); };\n});\n\necho $factorial(10), \"\\n\";\n?>\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 183,
    "input": "Translate C to Java:#include <stdlib.h>\n#include <time.h>\n#include <stdio.h>\n\nint main() {\n    int a[10][10], i, j;\n\n    srand(time(NULL));\n    for (i = 0; i < 10; i++)\n        for (j = 0; j < 10; j++)\n            a[i][j] = rand() % 20 + 1;\n\n    for (i = 0; i < 10; i++) {\n        for (j = 0; j < 10; j++) {\n            printf(\" %d\", a[i][j]);\n            if (a[i][j] == 20)\n                goto Done;\n        }\n        printf(\"\\n\");\n    }\nDone:\n    printf(\"\\n\");\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.util.Random;\n\npublic class NestedLoopTest {\n    public static final Random gen = new Random();\n    public static void main(String[] args) {\n        int[][] a = new int[10][10];\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[i].length; j++)\n                a[i][j] = gen.nextInt(20) + 1;\n\n        Outer:for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[i].length; j++) {\n                System.out.print(\" \" + a[i][j]);\n                if (a[i][j] == 20)\n                    break Outer; \n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 184,
    "input": "Translate C to Go:\n\n#include<graphics.h>\n\nvoid vibratingRectangles(int winWidth,int winHeight,int leastLength,int leastWidth,int num, int msec)\n{\n\tint color = 1,i,x = winWidth/2, y = winHeight/2;\n\t\n\twhile(!kbhit()){\n\t\tsetcolor(color++);\n\t\tfor(i=num;i>0;i--){\n\t\t\trectangle(x - i*leastLength,y - i*leastWidth,x + i*leastLength,y + i*leastWidth);\n\t\t\tdelay(msec);\n\t\t}\n\n\t\tif(color>MAXCOLORS){\n\t\t\tcolor = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinitwindow(1000,1000,\"Vibrating Rectangles...\");\n\t\n\tvibratingRectangles(1000,1000,30,15,20,500);\n\t\n\tclosegraph();\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/gif\"\n    \"log\"\n    \"os\"\n)\n\nvar (\n    black   = color.RGBA{0, 0, 0, 255}\n    red     = color.RGBA{255, 0, 0, 255}\n    green   = color.RGBA{0, 255, 0, 255}\n    blue    = color.RGBA{0, 0, 255, 255}\n    magenta = color.RGBA{255, 0, 255, 255}\n    cyan    = color.RGBA{0, 255, 255, 255}\n    yellow  = color.RGBA{255, 255, 0, 255}\n    white   = color.RGBA{255, 255, 255, 255}\n)\n\nvar palette = []color.Color{red, green, blue, magenta, cyan, yellow, white, black}\n\nfunc hline(img *image.Paletted, x1, y, x2 int, ci uint8) {\n    for ; x1 <= x2; x1++ {\n        img.SetColorIndex(x1, y, ci)\n    }\n}\n\nfunc vline(img *image.Paletted, x, y1, y2 int, ci uint8) {\n    for ; y1 <= y2; y1++ {\n        img.SetColorIndex(x, y1, ci)\n    }\n}\n\nfunc setBackgroundColor(img *image.Paletted, w, h int, ci uint8) {\n    for x := 0; x < w; x++ {\n        for y := 0; y < h; y++ {\n            img.SetColorIndex(x, y, ci)\n        }\n    }\n}\n\nfunc drawRectangle(img *image.Paletted, x1, y1, x2, y2 int, ci uint8) {\n    hline(img, x1, y1, x2, ci)\n    hline(img, x1, y2, x2, ci)\n    vline(img, x1, y1, y2, ci)\n    vline(img, x2, y1, y2, ci)\n}\n\nfunc main() {\n    const nframes = 140\n    const delay = 10 \n    width, height := 500, 500\n    anim := gif.GIF{LoopCount: nframes}\n    rect := image.Rect(0, 0, width, height)\n    for c := uint8(0); c < 7; c++ {\n        for f := 0; f < 20; f++ {\n            img := image.NewPaletted(rect, palette)\n            setBackgroundColor(img, width, height, 7) \n            for r := 0; r < 20; r++ {\n                ix := c\n                if r < f {\n                    ix = (ix + 1) % 7\n                }\n                x := width * (r + 1) / 50\n                y := height * (r + 1) / 50\n                w := width - x\n                h := height - y\n                drawRectangle(img, x, y, w, h, ix)\n            }\n            anim.Delay = append(anim.Delay, delay)\n            anim.Image = append(anim.Image, img)\n        }\n    }\n    file, err := os.Create(\"vibrating.gif\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close() \n    if err2 := gif.EncodeAll(file, &anim); err != nil {\n        log.Fatal(err2)\n    }   \n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 185,
    "input": "Translate PHP to Python:<?php\nclass Example {\n  function foo($x) {\n    return 42 + $x;\n  }\n}\n\n$example = new Example();\n\n$name = 'foo';\necho $example->$name(5), \"\\n\";        // prints \"47\"\n\necho call_user_func(array($example, $name), 5), \"\\n\";\n?>\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "class Example(object):\n     def foo(self, x):\n             return 42 + x\n\nname = \"foo\"\ngetattr(Example(), name)(5)      \n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 186,
    "input": "Translate Java to Python:import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PalindromicGapfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 20 palindromic gapful numbers ending in:\");\n        displayMap(getPalindromicGapfulEnding(20, 20));\n\n        System.out.printf(\"%nLast 15 of first 100 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(15, 100));\n\n        System.out.printf(\"%nLast 10 of first 1000 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(10, 1000));\n    }\n    \n    private static void displayMap(Map<Integer,List<Long>> map) {\n        for ( int key = 1 ; key <= 9 ; key++ ) {\n            System.out.println(key + \" : \" + map.get(key));\n        }\n    }\n    \n    public static Map<Integer,List<Long>> getPalindromicGapfulEnding(int countReturned, int firstHowMany) {\n        Map<Integer,List<Long>> map = new HashMap<>();\n        Map<Integer,Integer> mapCount = new HashMap<>();\n        for ( int i = 1 ; i <= 9 ; i++ ) {\n            map.put(i, new ArrayList<>());\n            mapCount.put(i, 0);\n        }\n        boolean notPopulated = true;\n        for ( long n = 101 ; notPopulated ; n = nextPalindrome(n) ) {\n            if ( isGapful(n) ) {\n                int index = (int) (n % 10);\n                if ( mapCount.get(index) < firstHowMany ) {\n                    map.get(index).add(n);\n                    mapCount.put(index, mapCount.get(index) + 1);\n                    if ( map.get(index).size() > countReturned ) {\n                        map.get(index).remove(0);\n                    }\n                }\n                boolean finished = true;\n                for ( int i = 1 ; i <= 9 ; i++ ) {\n                    if ( mapCount.get(i) < firstHowMany ) {\n                        finished = false;\n                        break;\n                    }\n                }\n                if ( finished ) {\n                    notPopulated = false;\n                }\n            }\n        }\n        return map;\n    }\n    \n    public static boolean isGapful(long n) {\n        String s = Long.toString(n);\n        return n % Long.parseLong(\"\" + s.charAt(0) + s.charAt(s.length()-1)) == 0;\n    }\n    \n    public static int length(long n) {\n        int length = 0;\n        while ( n > 0 ) {\n            length += 1;\n            n /= 10;\n        }\n        return length;\n    }\n    \n    public static long nextPalindrome(long n) {\n        int length = length(n);\n        if ( length % 2 == 0 ) {\n            length /= 2;\n            while ( length > 0 ) {\n                n /= 10;\n                length--;\n            }\n            n += 1;\n            if ( powerTen(n) ) {\n                return Long.parseLong(n + reverse(n/10));\n            }\n            return Long.parseLong(n + reverse(n));\n        }\n        length = (length - 1) / 2;\n        while ( length > 0 ) {\n            n /= 10;\n            length--;\n        }\n        n += 1;\n        if ( powerTen(n) ) {\n            return Long.parseLong(n + reverse(n/100));\n        }\n        return Long.parseLong(n + reverse(n/10));\n    }\n    \n    private static boolean powerTen(long n) {\n        while ( n > 9 && n % 10 == 0 ) {\n            n /= 10;\n        }\n        return n == 1;\n    }\n        \n    private static String reverse(long n) {\n        return (new StringBuilder(n + \"\")).reverse().toString();\n    }\n\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from itertools import count\nfrom pprint import pformat\nimport re\nimport heapq\n\n\ndef pal_part_gen(odd=True):\n    for i in count(1):\n        fwd = str(i)\n        rev = fwd[::-1][1:] if odd else fwd[::-1]\n        yield int(fwd + rev)\n\ndef pal_ordered_gen():\n    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))\n\ndef is_gapful(x):\n    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)\n\nif __name__ == '__main__':\n    start = 100\n    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:\n        print(f\"\\nLast {last} of the first {mx} binned-by-last digit \" \n              f\"gapful numbers >= {start}\")\n        bin = {i: [] for i in range(1, 10)}\n        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))\n        while any(len(val) < mx for val in bin.values()):\n            g = next(gen)\n            val = bin[g % 10]\n            if len(val) < mx:\n                val.append(g)\n        b = {k:v[-last:] for k, v in bin.items()}\n        txt = pformat(b, width=220)\n        print('', re.sub(r\"[{},\\[\\]]\", '', txt))\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 187,
    "input": "Translate C# to Go:class Program\n{\n    static void Main(string[] args)\n    {\n        CultureInfo ci=CultureInfo.CreateSpecificCulture(\"en-US\");\n        string dateString = \"March 7 2009 7:30pm EST\";\n        string format = \"MMMM d yyyy h:mmtt z\";\n        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(\"EST\",\"+6\"),format,ci) ;\n        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;\n        Console.WriteLine(newDateTime.ToString(format).Replace(\"-5\",\"EST\")); \n\n        Console.ReadLine();\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nconst taskDate = \"March 7 2009 7:30pm EST\"\nconst taskFormat = \"January 2 2006 3:04pm MST\"\n\nfunc main() {\n    if etz, err := time.LoadLocation(\"US/Eastern\"); err == nil {\n        time.Local = etz\n    }\n    fmt.Println(\"Input:             \", taskDate)\n    t, err := time.Parse(taskFormat, taskDate)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    t = t.Add(12 * time.Hour)\n    fmt.Println(\"+12 hrs:           \", t)\n    if _, offset := t.Zone(); offset == 0 {\n        fmt.Println(\"No time zone info.\")\n        return\n    }\n    atz, err := time.LoadLocation(\"US/Arizona\")\n    if err == nil {\n        fmt.Println(\"+12 hrs in Arizona:\", t.In(atz))\n    }\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 188,
    "input": "Translate Go to VB:package main\n\nimport (\n    \"crypto/des\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"log\"\n)\n\nfunc main() {\n    key, err := hex.DecodeString(\"0e329232ea6d0d73\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    c, err := des.NewCipher(key)\n    if err != nil {\n        log.Fatal(err)\n    }\n    src, err := hex.DecodeString(\"8787878787878787\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    dst := make([]byte, des.BlockSize)\n    c.Encrypt(dst, src)\n    fmt.Printf(\"%x\\n\", dst)\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Imports System.IO\nImports System.Security.Cryptography\n\nModule Module1\n\n    \n    Function ByteArrayToString(ba As Byte()) As String\n        Return BitConverter.ToString(ba).Replace(\"-\", \"\")\n    End Function\n\n    \n    \n    Function Encrypt(messageBytes As Byte(), passwordBytes As Byte()) As Byte()\n        Dim iv As Byte() = {&H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0}\n\n        \n        Dim provider As New DESCryptoServiceProvider\n        Dim transform = provider.CreateEncryptor(passwordBytes, iv)\n        Dim mode = CryptoStreamMode.Write\n\n        \n        Dim memStream As New MemoryStream\n        Dim cryptoStream As New CryptoStream(memStream, transform, mode)\n        cryptoStream.Write(messageBytes, 0, messageBytes.Length)\n        cryptoStream.FlushFinalBlock()\n\n        \n        Dim encryptedMessageBytes(memStream.Length - 1) As Byte\n        memStream.Position = 0\n        memStream.Read(encryptedMessageBytes, 0, encryptedMessageBytes.Length)\n\n        Return encryptedMessageBytes\n    End Function\n\n    \n    \n    Function Decrypt(encryptedMessageBytes As Byte(), passwordBytes As Byte()) As Byte()\n        Dim iv As Byte() = {&H0, &H0, &H0, &H0, &H0, &H0, &H0, &H0}\n\n        \n        Dim provider As New DESCryptoServiceProvider\n        Dim transform = provider.CreateDecryptor(passwordBytes, iv)\n        Dim mode = CryptoStreamMode.Write\n\n        \n        Dim memStream As New MemoryStream\n        Dim cryptoStream As New CryptoStream(memStream, transform, mode)\n        cryptoStream.Write(encryptedMessageBytes, 0, encryptedMessageBytes.Length)\n        cryptoStream.FlushFinalBlock()\n\n        \n        Dim decryptedMessageBytes(memStream.Length - 1) As Byte\n        memStream.Position = 0\n        memStream.Read(decryptedMessageBytes, 0, decryptedMessageBytes.Length)\n\n        Return decryptedMessageBytes\n    End Function\n\n    Sub Main()\n        Dim keyBytes As Byte() = {&HE, &H32, &H92, &H32, &HEA, &H6D, &HD, &H73}\n        Dim plainBytes As Byte() = {&H87, &H87, &H87, &H87, &H87, &H87, &H87, &H87}\n\n        Dim encStr = Encrypt(plainBytes, keyBytes)\n        Console.WriteLine(\"Encoded: {0}\", ByteArrayToString(encStr))\n\n        Dim decStr = Decrypt(encStr, keyBytes)\n        Console.WriteLine(\"Decoded: {0}\", ByteArrayToString(decStr))\n    End Sub\n\nEnd Module\n",
    "input_language": "Go",
    "output_language": "VB"
  },
  {
    "id": 189,
    "input": "Translate C++ to Go:#include <algorithm>\n#include <iostream>\n#include <string>\n\ndouble jaro(const std::string s1, const std::string s2) {\n    const uint l1 = s1.length(), l2 = s2.length();\n    if (l1 == 0)\n        return l2 == 0 ? 1.0 : 0.0;\n    const uint match_distance = std::max(l1, l2) / 2 - 1;\n    bool s1_matches[l1];\n    bool s2_matches[l2];\n    std::fill(s1_matches, s1_matches + l1, false);\n    std::fill(s2_matches, s2_matches + l2, false);\n    uint matches = 0;\n    for (uint i = 0; i < l1; i++)\n    {\n        const int end = std::min(i + match_distance + 1, l2);\n        for (int k = std::max(0u, i - match_distance); k < end; k++)\n            if (!s2_matches[k] && s1[i] == s2[k])\n            {\n                s1_matches[i] = true;\n                s2_matches[k] = true;\n                matches++;\n                break;\n            }\n    }\n    if (matches == 0)\n        return 0.0;\n    double t = 0.0;\n    uint k = 0;\n    for (uint i = 0; i < l1; i++)\n        if (s1_matches[i])\n        {\n            while (!s2_matches[k]) k++;\n            if (s1[i] != s2[k]) t += 0.5;\n            k++;\n        }\n\n    const double m = matches;\n    return (m / l1 + m / l2 + (m - t) / m) / 3.0;\n}\n\nint main() {\n    using namespace std;\n    cout << jaro(\"MARTHA\", \"MARHTA\") << endl;\n    cout << jaro(\"DIXON\", \"DICKSONX\") << endl;\n    cout << jaro(\"JELLYFISH\", \"SMELLYFISH\") << endl;\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc jaro(str1, str2 string) float64 {\n    if len(str1) == 0 && len(str2) == 0 {\n        return 1\n    }\n    if len(str1) == 0 || len(str2) == 0 {\n        return 0\n    }\n    match_distance := len(str1)\n    if len(str2) > match_distance {\n        match_distance = len(str2)\n    }\n    match_distance = match_distance/2 - 1\n    str1_matches := make([]bool, len(str1))\n    str2_matches := make([]bool, len(str2))\n    matches := 0.\n    transpositions := 0.\n    for i := range str1 {\n        start := i - match_distance\n        if start < 0 {\n            start = 0\n        }\n        end := i + match_distance + 1\n        if end > len(str2) {\n            end = len(str2)\n        }\n        for k := start; k < end; k++ {\n            if str2_matches[k] {\n                continue\n            }\n            if str1[i] != str2[k] {\n                continue\n            }\n            str1_matches[i] = true\n            str2_matches[k] = true\n            matches++\n            break\n        }\n    }\n    if matches == 0 {\n        return 0\n    }\n    k := 0\n    for i := range str1 {\n        if !str1_matches[i] {\n            continue\n        }\n        for !str2_matches[k] {\n            k++\n        }\n        if str1[i] != str2[k] {\n            transpositions++\n        }\n        k++\n    }\n    transpositions /= 2\n    return (matches/float64(len(str1)) +\n        matches/float64(len(str2)) +\n        (matches-transpositions)/matches) / 3\n}\n\nfunc main() {\n    fmt.Printf(\"%f\\n\", jaro(\"MARTHA\", \"MARHTA\"))\n    fmt.Printf(\"%f\\n\", jaro(\"DIXON\", \"DICKSONX\"))\n    fmt.Printf(\"%f\\n\", jaro(\"JELLYFISH\", \"SMELLYFISH\"))\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 190,
    "input": "Translate PHP to C#:<?\nclass Foo {\n}\n$obj = new Foo();\n$obj->bar = 42;\n$obj->baz = true;\n\nvar_dump(get_object_vars($obj));\n?>\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\n\npublic static class Reflection\n{\n    public static void Main() {\n        var t = new TestClass();\n        var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;\n        foreach (var prop in GetPropertyValues(t, flags)) {\n            Console.WriteLine(prop);\n        }\n        foreach (var field in GetFieldValues(t, flags)) {\n            Console.WriteLine(field);\n        }\n    }\n\n    public static IEnumerable<(string name, object value)> GetPropertyValues<T>(T obj, BindingFlags flags) =>\n        from p in typeof(T).GetProperties(flags)\n        where p.GetIndexParameters().Length == 0 \n        select (p.Name, p.GetValue(obj, null));\n    \n    public static IEnumerable<(string name, object value)> GetFieldValues<T>(T obj, BindingFlags flags) =>\n        typeof(T).GetFields(flags).Select(f => (f.Name, f.GetValue(obj)));\n    \n    class TestClass\n    {\n        private int privateField = 7;\n        public int PublicNumber { get; } = 4;\n        private int PrivateNumber { get; } = 2;\n    }\n\n}\n",
    "input_language": "PHP",
    "output_language": "C#"
  },
  {
    "id": 191,
    "input": "Translate Java to Go:import java.util.Random;\n\npublic class NestedLoopTest {\n    public static final Random gen = new Random();\n    public static void main(String[] args) {\n        int[][] a = new int[10][10];\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[i].length; j++)\n                a[i][j] = gen.nextInt(20) + 1;\n\n        Outer:for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[i].length; j++) {\n                System.out.print(\" \" + a[i][j]);\n                if (a[i][j] == 20)\n                    break Outer; \n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n\n    values := make([][]int, 10)\n    for i := range values {\n        values[i] = make([]int, 10)\n        for j := range values[i] {\n            values[i][j] = rand.Intn(20) + 1\n        }\n    }\n\nouterLoop:\n    for i, row := range values {\n        fmt.Printf(\"%3d)\", i)\n        for _, value := range row {\n            fmt.Printf(\" %3d\", value)\n            if value == 20 {\n                break outerLoop\n            }\n        }\n        fmt.Printf(\"\\n\")\n    }\n    fmt.Printf(\"\\n\")\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 192,
    "input": "Translate Go to VB:package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"rcu\"\n    \"sort\"\n)\n\nfunc main() {\n    arithmetic := []int{1}\n    primes := []int{}\n    limit := int(1e6)\n    for n := 3; len(arithmetic) < limit; n++ {\n        divs := rcu.Divisors(n)\n        if len(divs) == 2 {\n            primes = append(primes, n)\n            arithmetic = append(arithmetic, n)\n        } else {\n            mean := float64(rcu.SumInts(divs)) / float64(len(divs))\n            if mean == math.Trunc(mean) {\n                arithmetic = append(arithmetic, n)\n            }\n        }\n    }\n    fmt.Println(\"The first 100 arithmetic numbers are:\")\n    rcu.PrintTable(arithmetic[0:100], 10, 3, false)\n\n    for _, x := range []int{1e3, 1e4, 1e5, 1e6} {\n        last := arithmetic[x-1]\n        lastc := rcu.Commatize(last)\n        fmt.Printf(\"\\nThe %sth arithmetic number is: %s\\n\", rcu.Commatize(x), lastc)\n        pcount := sort.SearchInts(primes, last) + 1\n        if !rcu.IsPrime(last) {\n            pcount--\n        }\n        comp := x - pcount - 1 \n        compc := rcu.Commatize(comp)\n        fmt.Printf(\"The count of such numbers <= %s which are composite is %s.\\n\", lastc, compc)\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "\n\n\nfunction isarit_compo(i)\n     cnt=0\n     sum=0\n     for j=1 to sqr(i)\n       if (i mod j)=0 then \n          k=i\\j \n             \n         if k=j then \n            cnt=cnt+1:sum=sum+j \n         else  \n            cnt=cnt+2:sum=sum+j+k \n         end if\n       end if\n     next\n   avg= sum/cnt\n   isarit_compo= array((fix(avg)=avg),-(cnt>2))\nend function\n\nfunction rpad(a,n) rpad=right(space(n)&a,n) :end function\n\ndim s1\nsub print(s) \n  s1=s1& rpad(s,4)\n  if len(s1)=40 then wscript.stdout.writeline s1:s1=\"\"\nend sub\n\n\ncntr=0\ncntcompo=0\ni=1\nwscript.stdout.writeline \"the first 100 arithmetic numbers are:\"\ndo\n  a=isarit_compo(i)\n  if a(0) then  \n    cntcompo=cntcompo+a(1)\n    cntr=cntr+1\n    if cntr<=100 then print i\n    if cntr=1000 then wscript.stdout.writeline vbcrlf&\"1000th   : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=10000 then wscript.stdout.writeline vbcrlf& \"10000th  : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=100000 then wscript.stdout.writeline vbcrlf &\"100000th : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6):exit do\n  end if \n  i=i+1\nloop\n",
    "input_language": "Go",
    "output_language": "VB"
  },
  {
    "id": 193,
    "input": "Translate C++ to Python:#include <iostream>\n#include <string>\n#include <map>\n\ntemplate<typename map_type>\nmap_type merge(const map_type& original, const map_type& update) {\n    map_type result(update);\n    result.insert(original.begin(), original.end());\n    return result;\n}\n\nint main() {\n    typedef std::map<std::string, std::string> map;\n    map original{\n        {\"name\", \"Rocket Skates\"},\n        {\"price\", \"12.75\"},\n        {\"color\", \"yellow\"}\n    };\n    map update{\n        {\"price\", \"15.25\"},\n        {\"color\", \"red\"},\n        {\"year\", \"1974\"}\n    };\n    map merged(merge(original, update));\n    for (auto&& i : merged)\n        std::cout << \"key: \" << i.first << \", value: \" << i.second << '\\n';\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "base = {\"name\":\"Rocket Skates\", \"price\":12.75, \"color\":\"yellow\"}\nupdate = {\"price\":15.25, \"color\":\"red\", \"year\":1974}\n\nresult = {**base, **update}\n\nprint(result)\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 194,
    "input": "Translate PHP to Python:$allowed = ['zip', 'rar', '7z', 'gz', 'archive', 'A##', 'tar.bz2'];\n$lc_allowed = array_map('strtolower', $allowed);\n\n$tests = [\n    ['MyData.a##',true],\n    ['MyData.tar.Gz',true],\n    ['MyData.gzip',false],\n    ['MyData.7z.backup',false],\n    ['MyData...',false],\n    ['MyData',false],\n    ['archive.tar.gz', true]\n];\n\nforeach ($tests as $test) {\n    $ext = pathinfo($test[0], PATHINFO_EXTENSION);\n    if (in_array(strtolower($ext), $lc_allowed)) {\n        $result = 'true';\n    } else {\n        $result = 'false';\n    }\n    printf(\"%20s : %s \\n\", $test[0],$result);\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 195,
    "input": "Translate C++ to Python:#include <algorithm>\n#include <iostream>\n#include <map>\n#include <vector>\n\nstd::ostream &operator<<(std::ostream &os, std::vector<std::pair<int, int>> &v) {\n    for (auto &p : v) {\n        auto sum = p.first + p.second;\n        auto prod = p.first * p.second;\n        os << '[' << p.first << \", \" << p.second << \"] S=\" << sum << \" P=\" << prod;\n    }\n    return os << '\\n';\n}\n\nvoid print_count(const std::vector<std::pair<int, int>> &candidates) {\n    auto c = candidates.size();\n    if (c == 0) {\n        std::cout << \"no candidates\\n\";\n    } else if (c == 1) {\n        std::cout << \"one candidate\\n\";\n    } else {\n        std::cout << c << \" candidates\\n\";\n    }\n}\n\nauto setup() {\n    std::vector<std::pair<int, int>> candidates;\n\n    \n    for (int x = 2; x <= 98; x++) {\n        \n        for (int y = x + 1; y <= 98; y++) {\n            if (x + y <= 100) {\n                candidates.push_back(std::make_pair(x, y));\n            }\n        }\n    }\n\n    return candidates;\n}\n\nvoid remove_by_sum(std::vector<std::pair<int, int>> &candidates, const int sum) {\n    candidates.erase(std::remove_if(\n        candidates.begin(), candidates.end(),\n        [sum](const std::pair<int, int> &pair) {\n            auto s = pair.first + pair.second;\n            return s == sum;\n        }\n    ), candidates.end());\n}\n\nvoid remove_by_prod(std::vector<std::pair<int, int>> &candidates, const int prod) {\n    candidates.erase(std::remove_if(\n        candidates.begin(), candidates.end(),\n        [prod](const std::pair<int, int> &pair) {\n            auto p = pair.first * pair.second;\n            return p == prod;\n        }\n    ), candidates.end());\n}\n\nvoid statement1(std::vector<std::pair<int, int>> &candidates) {\n    std::map<int, int> uniqueMap;\n\n    std::for_each(\n        candidates.cbegin(), candidates.cend(),\n        [&uniqueMap](const std::pair<int, int> &pair) {\n            auto prod = pair.first * pair.second;\n            uniqueMap[prod]++;\n        }\n    );\n\n    bool loop;\n    do {\n        loop = false;\n        for (auto &pair : candidates) {\n            auto prod = pair.first * pair.second;\n            if (uniqueMap[prod] == 1) {\n                auto sum = pair.first + pair.second;\n                remove_by_sum(candidates, sum);\n\n                loop = true;\n                break;\n            }\n        }\n    } while (loop);\n}\n\nvoid statement2(std::vector<std::pair<int, int>> &candidates) {\n    std::map<int, int> uniqueMap;\n\n    std::for_each(\n        candidates.cbegin(), candidates.cend(),\n        [&uniqueMap](const std::pair<int, int> &pair) {\n            auto prod = pair.first * pair.second;\n            uniqueMap[prod]++;\n        }\n    );\n\n    bool loop;\n    do {\n        loop = false;\n        for (auto &pair : candidates) {\n            auto prod = pair.first * pair.second;\n            if (uniqueMap[prod] > 1) {\n                remove_by_prod(candidates, prod);\n\n                loop = true;\n                break;\n            }\n        }\n    } while (loop);\n}\n\nvoid statement3(std::vector<std::pair<int, int>> &candidates) {\n    std::map<int, int> uniqueMap;\n\n    std::for_each(\n        candidates.cbegin(), candidates.cend(),\n        [&uniqueMap](const std::pair<int, int> &pair) {\n            auto sum = pair.first + pair.second;\n            uniqueMap[sum]++;\n        }\n    );\n\n    bool loop;\n    do {\n        loop = false;\n        for (auto &pair : candidates) {\n            auto sum = pair.first + pair.second;\n            if (uniqueMap[sum] > 1) {\n                remove_by_sum(candidates, sum);\n\n                loop = true;\n                break;\n            }\n        }\n    } while (loop);\n}\n\nint main() {\n    auto candidates = setup();\n    print_count(candidates);\n\n    statement1(candidates);\n    print_count(candidates);\n\n    statement2(candidates);\n    print_count(candidates);\n\n    statement3(candidates);\n    print_count(candidates);\n\n    std::cout << candidates;\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\nfrom collections import Counter\n\ndef decompose_sum(s):\n    return [(a,s-a) for a in range(2,int(s/2+1))]\n\n\nall_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100)\n\n\nproduct_counts = Counter(c*d for c,d in all_pairs)\nunique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)\ns_pairs = [(a,b) for a,b in all_pairs if\n    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))]\n\n\nproduct_counts = Counter(c*d for c,d in s_pairs)\np_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1]\n\n\nsum_counts = Counter(c+d for c,d in p_pairs)\nfinal_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1]\n\nprint(final_pairs)\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 196,
    "input": "Translate Python to VB:from collections import namedtuple\nfrom pprint import pprint as pp\n\nOpInfo = namedtuple('OpInfo', 'prec assoc')\nL, R = 'Left Right'.split()\n\nops = {\n '^': OpInfo(prec=4, assoc=R),\n '*': OpInfo(prec=3, assoc=L),\n '/': OpInfo(prec=3, assoc=L),\n '+': OpInfo(prec=2, assoc=L),\n '-': OpInfo(prec=2, assoc=L),\n '(': OpInfo(prec=9, assoc=L),\n ')': OpInfo(prec=0, assoc=L),\n }\n\nNUM, LPAREN, RPAREN = 'NUMBER ( )'.split()\n\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    tokenvals = []\n    for token in tokens:\n        if token in ops:\n            tokenvals.append((token, ops[token]))\n        \n        \n        else:    \n            tokenvals.append((NUM, token))\n    return tokenvals\n\ndef shunting(tokenvals):\n    outq, stack = [], []\n    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]\n    for token, val in tokenvals:\n        note = action = ''\n        if token is NUM:\n            action = 'Add number to output'\n            outq.append(val)\n            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        elif token in ops:\n            t1, (p1, a1) = token, val\n            v = t1\n            note = 'Pop ops from stack to output' \n            while stack:\n                t2, (p2, a2) = stack[-1]\n                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):\n                    if t1 != RPAREN:\n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            break\n                    else:        \n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            stack.pop()\n                            action = '(Pop & discard \"(\")'\n                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                            break\n                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                    v = note = ''\n                else:\n                    note = ''\n                    break\n                note = '' \n            note = '' \n            if t1 != RPAREN:\n                stack.append((token, val))\n                action = 'Push op token to stack'\n            else:\n                action = 'Discard \")\"'\n            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n    note = 'Drain stack to output'\n    while stack:\n        v = ''\n        t2, (p2, a2) = stack[-1]\n        action = '(Pop op)'\n        stack.pop()\n        outq.append(t2)\n        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        v = note = ''\n    return table\n\nif __name__ == '__main__':\n    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'\n    print( 'For infix expression: %r\\n' % infix )\n    rp = shunting(get_input(infix))\n    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output RPN is: %r' % rp[-1][2])\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Module Module1\n    Class SymbolType\n        Public ReadOnly symbol As String\n        Public ReadOnly precedence As Integer\n        Public ReadOnly rightAssociative As Boolean\n\n        Public Sub New(symbol As String, precedence As Integer, rightAssociative As Boolean)\n            Me.symbol = symbol\n            Me.precedence = precedence\n            Me.rightAssociative = rightAssociative\n        End Sub\n    End Class\n\n    ReadOnly Operators As Dictionary(Of String, SymbolType) = New Dictionary(Of String, SymbolType) From\n    {\n        {\"^\", New SymbolType(\"^\", 4, True)},\n        {\"*\", New SymbolType(\"*\", 3, False)},\n        {\"/\", New SymbolType(\"/\", 3, False)},\n        {\"+\", New SymbolType(\"+\", 2, False)},\n        {\"-\", New SymbolType(\"-\", 2, False)}\n    }\n\n    Function ToPostfix(infix As String) As String\n        Dim tokens = infix.Split(\" \")\n        Dim stack As New Stack(Of String)\n        Dim output As New List(Of String)\n\n        Dim Print = Sub(action As String) Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {String.Join(\" \", stack.Reverse())} ]\", $\"out[ {String.Join(\" \", output)} ]\")\n\n        For Each token In tokens\n            Dim iv As Integer\n            Dim op1 As SymbolType\n            Dim op2 As SymbolType\n            If Integer.TryParse(token, iv) Then\n                output.Add(token)\n                Print(token)\n            ElseIf Operators.TryGetValue(token, op1) Then\n                While stack.Count > 0 AndAlso Operators.TryGetValue(stack.Peek(), op2)\n                    Dim c = op1.precedence.CompareTo(op2.precedence)\n                    If c < 0 OrElse Not op1.rightAssociative AndAlso c <= 0 Then\n                        output.Add(stack.Pop())\n                    Else\n                        Exit While\n                    End If\n                End While\n                stack.Push(token)\n                Print(token)\n            ElseIf token = \"(\" Then\n                stack.Push(token)\n                Print(token)\n            ElseIf token = \")\" Then\n                Dim top = \"\"\n                While stack.Count > 0\n                    top = stack.Pop()\n                    If top <> \"(\" Then\n                        output.Add(top)\n                    Else\n                        Exit While\n                    End If\n                End While\n                If top <> \"(\" Then\n                    Throw New ArgumentException(\"No matching left parenthesis.\")\n                End If\n                Print(token)\n            End If\n        Next\n        While stack.Count > 0\n            Dim top = stack.Pop()\n            If Not Operators.ContainsKey(top) Then\n                Throw New ArgumentException(\"No matching right parenthesis.\")\n            End If\n            output.Add(top)\n        End While\n        Print(\"pop\")\n        Return String.Join(\" \", output)\n    End Function\n\n    Sub Main()\n        Dim infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"\n        Console.WriteLine(ToPostfix(infix))\n    End Sub\n\nEnd Module\n",
    "input_language": "Python",
    "output_language": "VB"
  },
  {
    "id": 197,
    "input": "Translate C to Go:#!/usr/local/bin/script_gcc.sh\n\n#include <errno.h>\n#include <libgen.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n\n\n\ntypedef char  *STRING;\ntypedef enum{FALSE=0, TRUE=1} BOOL;\nconst STRING ENDCAT = NULL;\n\n\n#define DIALECT \"c\" \nconst STRING\n  CC=\"gcc\",\n  COPTS=\"-lm -x \"DIALECT,\n  IEXT=\".\"DIALECT,\n  OEXT=\".out\";\nconst BOOL OPT_CACHE = TRUE;\n\n\nchar strcat_out[BUFSIZ];\n\nSTRING STRCAT(STRING argv, ... ){\n  va_list ap;\n  va_start(ap, argv);\n  STRING arg;\n  strcat_out[0]='\\0';\n  for(arg=argv; arg != ENDCAT; arg=va_arg(ap, STRING)){\n     strncat(strcat_out, arg, sizeof strcat_out);\n  }\n  va_end(ap);\n  return strndup(strcat_out, sizeof strcat_out);\n}\n\nchar itoa_out[BUFSIZ];\n\nSTRING itoa_(int i){\n  sprintf(itoa_out, \"%d\", i);\n  return itoa_out;\n}\n\ntime_t modtime(STRING filename){\n  struct stat buf;\n  if(stat(filename, &buf) != EXIT_SUCCESS)perror(filename);\n  return buf.st_mtime;\n}\n\n\nBOOL compile(STRING srcpath, STRING binpath){\n  int out;\n  STRING compiler_command=STRCAT(CC, \" \", COPTS, \" -o \", binpath, \" -\", ENDCAT);\n  FILE *src=fopen(srcpath, \"r\"),\n       *compiler=popen(compiler_command, \"w\");\n  char buf[BUFSIZ];\n  BOOL shebang;\n\n  for(shebang=TRUE; fgets(buf, sizeof buf, src); shebang=FALSE)\n    if(!shebang)fwrite(buf, strlen(buf), 1, compiler);\n\n  out=pclose(compiler);\n  return out;\n}\n\nvoid main(int argc, STRING *argv, STRING *envp){\n\n  STRING binpath,\n         srcpath=argv[1],\n         argv0_basename=STRCAT(basename((char*)srcpath ), ENDCAT),\n         *dirnamew, *dirnamex;\n  argv++; \n\n\n  STRING paths[] = {\n    dirname(strdup(srcpath)), \n    STRCAT(getenv(\"HOME\"), \"/bin\", ENDCAT),\n    \"/usr/local/bin\",\n    \".\",\n    STRCAT(getenv(\"HOME\"), \"/tmp\", ENDCAT),\n    getenv(\"HOME\"),\n    STRCAT(getenv(\"HOME\"), \"/Desktop\", ENDCAT),\n\n    ENDCAT\n  };\n\n  for(dirnamew = paths; *dirnamew; dirnamew++){\n    if(access(*dirnamew, W_OK) == EXIT_SUCCESS) break;\n  }\n\n\n  if(OPT_CACHE == FALSE){\n    binpath=STRCAT(*dirnamew, \"/\", argv0_basename, itoa_(getpid()), OEXT, ENDCAT);\n    if(compile(srcpath, binpath) == EXIT_SUCCESS){\n      if(fork()){\n        sleep(0.1); unlink(binpath);\n      } else {\n        execvp(binpath, argv);\n      }\n    }\n  } else {\n\n    time_t modtime_srcpath = modtime(srcpath);\n    for(dirnamex = paths; *dirnamex; dirnamex++){\n      binpath=STRCAT(*dirnamex, \"/\", argv0_basename, OEXT, ENDCAT);\n      if((access(binpath, X_OK) == EXIT_SUCCESS) && (modtime(binpath) >= modtime_srcpath))\n        execvp(binpath, argv);\n    }\n  }\n\n  binpath=STRCAT(*dirnamew, \"/\", argv0_basename, OEXT, ENDCAT);\n  if(compile(srcpath, binpath) == EXIT_SUCCESS)\n    execvp(binpath, argv);\n\n  perror(STRCAT(binpath, \": executable not available\", ENDCAT));\n  exit(errno);\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    if len(os.Args) > 1 {\n        fmt.Println(os.Args[1])\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 198,
    "input": "Translate C++ to Go:#include <iomanip>\n#include <iostream>\n#include <vector>\n\nstd::vector<bool> prime_sieve(int limit) {\n    std::vector<bool> sieve(limit, true);\n    if (limit > 0)\n        sieve[0] = false;\n    if (limit > 1)\n        sieve[1] = false;\n    for (int i = 4; i < limit; i += 2)\n        sieve[i] = false;\n    for (int p = 3, sq = 9; sq < limit; p += 2) {\n        if (sieve[p]) {\n            for (int q = sq; q < limit; q += p << 1)\n                sieve[q] = false;\n        }\n        sq += (p + 1) << 2;\n    }\n    return sieve;\n}\n\nvoid print_non_twin_prime_sums(const std::vector<bool>& sums) {\n    int count = 0;\n    for (size_t i = 2; i < sums.size(); i += 2) {\n        if (!sums[i]) {\n            ++count;\n            std::cout << std::setw(4) << i << (count % 10 == 0 ? '\\n' : ' ');\n        }\n    }\n    std::cout << \"\\nFound \" << count << '\\n';\n}\n\nint main() {\n    const int limit = 100001;\n\n    std::vector<bool> sieve = prime_sieve(limit + 2);\n    \n    for (size_t i = 0; i < limit; ++i) {\n        if (sieve[i] && !((i > 1 && sieve[i - 2]) || sieve[i + 2]))\n            sieve[i] = false;\n    }\n\n    std::vector<bool> twin_prime_sums(limit, false);\n    for (size_t i = 0; i < limit; ++i) {\n        if (sieve[i]) {\n            for (size_t j = i; i + j < limit; ++j) {\n                if (sieve[j])\n                    twin_prime_sums[i + j] = true;\n            }\n        }\n    }\n\n    std::cout << \"Non twin prime sums:\\n\";\n    print_non_twin_prime_sums(twin_prime_sums);\n\n    sieve[1] = true;\n    for (size_t i = 1; i + 1 < limit; ++i) {\n        if (sieve[i])\n            twin_prime_sums[i + 1] = true;\n    }\n\n    std::cout << \"\\nNon twin prime sums (including 1):\\n\";\n    print_non_twin_prime_sums(twin_prime_sums);\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nconst limit = 100000 \n\nfunc nonTwinSums(twins []int) []int {\n    sieve := make([]bool, limit+1)\n    for i := 0; i < len(twins); i++ {\n        for j := i; j < len(twins); j++ {\n            sum := twins[i] + twins[j]\n            if sum > limit {\n                break\n            }\n            sieve[sum] = true\n        }\n    }\n    var res []int\n    for i := 2; i < limit; i += 2 {\n        if !sieve[i] {\n            res = append(res, i)\n        }\n    }\n    return res\n}\n\nfunc main() {\n    primes := rcu.Primes(limit)[2:] \n    twins := []int{3}\n    for i := 0; i < len(primes)-1; i++ {\n        if primes[i+1]-primes[i] == 2 {\n            if twins[len(twins)-1] != primes[i] {\n                twins = append(twins, primes[i])\n            }\n            twins = append(twins, primes[i+1])\n        }\n    }\n    fmt.Println(\"Non twin prime sums:\")\n    ntps := nonTwinSums(twins)\n    rcu.PrintTable(ntps, 10, 4, false)\n    fmt.Println(\"Found\", len(ntps))\n\n    fmt.Println(\"\\nNon twin prime sums (including 1):\")\n    twins = append([]int{1}, twins...)\n    ntps = nonTwinSums(twins)\n    rcu.PrintTable(ntps, 10, 4, false)\n    fmt.Println(\"Found\", len(ntps))\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 199,
    "input": "Translate C++ to VB:#include <cstdint>\n#include <iostream>\n#include <string>\n\nusing integer = uint64_t;\n\nbool square_free(integer n) {\n    if (n % 4 == 0)\n        return false;\n    for (integer p = 3; p * p <= n; p += 2) {\n        integer count = 0;\n        for (; n % p == 0; n /= p) {\n            if (++count > 1)\n                return false;\n        }\n    }\n    return true;\n}\n\nvoid print_square_free_numbers(integer from, integer to) {\n    std::cout << \"Square-free numbers between \" << from\n        << \" and \" << to << \":\\n\";\n    std::string line;\n    for (integer i = from; i <= to; ++i) {\n        if (square_free(i)) {\n            if (!line.empty())\n                line += ' ';\n            line += std::to_string(i);\n            if (line.size() >= 80) {\n                std::cout << line << '\\n';\n                line.clear();\n            }\n        }\n    }\n    if (!line.empty())\n        std::cout << line << '\\n';\n}\n\nvoid print_square_free_count(integer from, integer to) {\n    integer count = 0;\n    for (integer i = from; i <= to; ++i) {\n        if (square_free(i))\n            ++count;\n    }\n    std::cout << \"Number of square-free numbers between \"\n        << from << \" and \" << to << \": \" << count << '\\n';\n}\n\nint main() {\n    print_square_free_numbers(1, 145);\n    print_square_free_numbers(1000000000000LL, 1000000000145LL);\n    print_square_free_count(1, 100);\n    print_square_free_count(1, 1000);\n    print_square_free_count(1, 10000);\n    print_square_free_count(1, 100000);\n    print_square_free_count(1, 1000000);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Module Module1\n\n    Function Sieve(limit As Long) As List(Of Long)\n        Dim primes As New List(Of Long) From {2}\n        Dim c(limit + 1) As Boolean\n        Dim p = 3L\n        While True\n            Dim p2 = p * p\n            If p2 > limit Then\n                Exit While\n            End If\n            For i = p2 To limit Step 2 * p\n                c(i) = True\n            Next\n            While True\n                p += 2\n                If Not c(p) Then\n                    Exit While\n                End If\n            End While\n        End While\n        For i = 3 To limit Step 2\n            If Not c(i) Then\n                primes.Add(i)\n            End If\n        Next\n        Return primes\n    End Function\n\n    Function SquareFree(from As Long, to_ As Long) As List(Of Long)\n        Dim limit = CType(Math.Sqrt(to_), Long)\n        Dim primes = Sieve(limit)\n        Dim results As New List(Of Long)\n\n        Dim i = from\n        While i <= to_\n            For Each p In primes\n                Dim p2 = p * p\n                If p2 > i Then\n                    Exit For\n                End If\n                If (i Mod p2) = 0 Then\n                    i += 1\n                    Continue While\n                End If\n            Next\n            results.Add(i)\n            i += 1\n        End While\n\n        Return results\n    End Function\n\n    ReadOnly TRILLION As Long = 1_000_000_000_000\n\n    Sub Main()\n        Console.WriteLine(\"Square-free integers from 1 to 145:\")\n        Dim sf = SquareFree(1, 145)\n        For index = 0 To sf.Count - 1\n            Dim v = sf(index)\n            If index > 1 AndAlso (index Mod 20) = 0 Then\n                Console.WriteLine()\n            End If\n            Console.Write(\"{0,4}\", v)\n        Next\n        Console.WriteLine()\n        Console.WriteLine()\n\n        Console.WriteLine(\"Square-free integers from {0} to {1}:\", TRILLION, TRILLION + 145)\n        sf = SquareFree(TRILLION, TRILLION + 145)\n        For index = 0 To sf.Count - 1\n            Dim v = sf(index)\n            If index > 1 AndAlso (index Mod 5) = 0 Then\n                Console.WriteLine()\n            End If\n            Console.Write(\"{0,14}\", v)\n        Next\n        Console.WriteLine()\n        Console.WriteLine()\n\n        Console.WriteLine(\"Number of square-free integers:\")\n        For Each to_ In {100, 1_000, 10_000, 100_000, 1_000_000}\n            Console.WriteLine(\"   from 1 to {0} = {1}\", to_, SquareFree(1, to_).Count)\n        Next\n    End Sub\n\nEnd Module\n",
    "input_language": "C++",
    "output_language": "VB"
  },
  {
    "id": 200,
    "input": "Translate Python to Go:from optparse import OptionParser\n[...]\nparser = OptionParser()\nparser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                  help=\"write report to FILE\", metavar=\"FILE\")\nparser.add_option(\"-q\", \"--quiet\",\n                  action=\"store_false\", dest=\"verbose\", default=True,\n                  help=\"don't print status messages to stdout\")\n\n(options, args) = parser.parse_args()\n\nexample:\n\n<yourscript> --file=outfile -q\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\nfunc main() {\n    b := flag.Bool(\"b\", false, \"just a boolean\")\n    s := flag.String(\"s\", \"\", \"any ol' string\")\n    n := flag.Int(\"n\", 0, \"your lucky number\")\n    flag.Parse()\n    fmt.Println(\"b:\", *b)\n    fmt.Println(\"s:\", *s)\n    fmt.Println(\"n:\", *n)\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 201,
    "input": "Translate Python to Go:from itertools import product, compress\n\nfact = lambda n: n and n*fact(n - 1) or 1\ncombo_count = lambda total, coins, perm:\\\n                    sum(perm and fact(len(x)) or 1\n                        for x in (list(compress(coins, c))\n                                  for c in product(*([(0, 1)]*len(coins))))\n                        if sum(x) == total)\n\ncases = [(6,  [1, 2, 3, 4, 5]),\n         (6,  [1, 1, 2, 3, 3, 4, 5]),\n         (40, [1, 2, 3, 4, 5, 5, 5, 5, 15, 15, 10, 10, 10, 10, 25, 100])]\n\nfor perm in [False, True]:\n    print(f'Order matters: {perm}')\n    for s, c in cases:\n        print(f'{combo_count(s, c, perm):7d} ways for {s:2d} total from coins {c}')\n    print()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nvar cnt = 0  \nvar cnt2 = 0 \nvar wdth = 0 \n\nfunc factorial(n int) int {\n    prod := 1\n    for i := 2; i <= n; i++ {\n        prod *= i\n    }\n    return prod\n}\n\nfunc count(want int, used []int, sum int, have, uindices, rindices []int) {\n    if sum == want {\n        cnt++\n        cnt2 += factorial(len(used))\n        if cnt < 11 {\n            uindicesStr := fmt.Sprintf(\"%v\", uindices)\n            fmt.Printf(\"  indices %*s => used %v\\n\", wdth, uindicesStr, used)\n        }\n    } else if sum < want && len(have) != 0 {\n        thisCoin := have[0]\n        index := rindices[0]\n        rest := have[1:]\n        rindices := rindices[1:]\n        count(want, append(used, thisCoin), sum+thisCoin, rest,\n            append(uindices, index), rindices)\n        count(want, used, sum, rest, uindices, rindices)\n    }\n}\n\nfunc countCoins(want int, coins []int, width int) {\n    fmt.Printf(\"Sum %d from coins %v\\n\", want, coins)\n    cnt = 0\n    cnt2 = 0\n    wdth = -width\n    rindices := make([]int, len(coins))\n    for i := range rindices {\n        rindices[i] = i\n    }\n    count(want, []int{}, 0, coins, []int{}, rindices)\n    if cnt > 10 {\n        fmt.Println(\"  .......\")\n        fmt.Println(\"  (only the first 10 ways generated are shown)\")\n    }\n    fmt.Println(\"Number of ways - order unimportant :\", cnt, \"(as above)\")\n    fmt.Println(\"Number of ways - order important   :\", cnt2, \"(all perms of above indices)\\n\")\n}\n\nfunc main() {\n    countCoins(6, []int{1, 2, 3, 4, 5}, 7)\n    countCoins(6, []int{1, 1, 2, 3, 3, 4, 5}, 9)\n    countCoins(40, []int{1, 2, 3, 4, 5, 5, 5, 5, 15, 15, 10, 10, 10, 10, 25, 100}, 20)\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 202,
    "input": "Translate Java to Go:public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc computePerfect(n int64) bool {\n    var sum int64\n    for i := int64(1); i < n; i++ {\n        if n%i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\n\n\nfunc isPerfect(n int64) bool {\n    switch n {\n    case 6, 28, 496, 8128, 33550336, 8589869056,\n        137438691328, 2305843008139952128:\n        return true\n    }\n    return false\n}\n\n\nfunc main() {\n    for n := int64(1); ; n++ {\n        if isPerfect(n) != computePerfect(n) {\n            panic(\"bug\")\n        }\n        if n%1e3 == 0 {\n            fmt.Println(\"tested\", n)\n        }\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 203,
    "input": "Translate C# to Go:using System;\nusing System.Reflection;\n\npublic class Rosetta\n{\n    public static void Main()\n    {\n        \n        BindingFlags flags = BindingFlags.Instance | BindingFlags.Static\n            | BindingFlags.Public | BindingFlags.NonPublic\n            | BindingFlags.DeclaredOnly;\n\n        foreach (var method in typeof(TestForMethodReflection).GetMethods(flags))\n            Console.WriteLine(method);\n    }\n    \n    class TestForMethodReflection\n    {\n        public void MyPublicMethod() {}\n        private void MyPrivateMethod() {}\n        \n        public static void MyPublicStaticMethod() {}\n        private static void MyPrivateStaticMethod() {}\n    }\n    \n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"reflect\"\n)\n\ntype t int \n\n\nfunc (r t) Twice() t       { return r * 2 }\nfunc (r t) Half() t        { return r / 2 }\nfunc (r t) Less(r2 t) bool { return r < r2 }\nfunc (r t) privateMethod() {}\n\nfunc main() {\n\treport(t(0))\n\treport(image.Point{})\n}\n\nfunc report(x interface{}) {\n\tv := reflect.ValueOf(x)\n\tt := reflect.TypeOf(x) \n\tn := t.NumMethod()\n\tfmt.Printf(\"Type %v has %d exported methods:\\n\", t, n)\n\tconst format = \"%-6s %-46s %s\\n\"\n\tfmt.Printf(format, \"Name\", \"Method expression\", \"Method value\")\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Printf(format,\n\t\t\tt.Method(i).Name,\n\t\t\tt.Method(i).Func.Type(),\n\t\t\tv.Method(i).Type(),\n\t\t)\n\t}\n\tfmt.Println()\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 204,
    "input": "Translate C++ to C#:auto strA = R\"(this is\na newline-separated\nraw string)\";\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "string path = @\"C:\\Windows\\System32\";\nstring multiline = @\"Line 1.\nLine 2.\nLine 3.\";\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 205,
    "input": "Translate C to Go:#include <stdio.h>\n#include <string.h>\n\n\nvoid longmulti(const char *a, const char *b, char *c)\n{\n\tint i = 0, j = 0, k = 0, n, carry;\n\tint la, lb;\n\n\t\n\tif (!strcmp(a, \"0\") || !strcmp(b, \"0\")) {\n\t\tc[0] = '0', c[1] = '\\0';\n\t\treturn;\n\t}\n\n\t\n\tif (a[0] == '-') { i = 1; k = !k; }\n\tif (b[0] == '-') { j = 1; k = !k; }\n\n\t\n\tif (i || j) {\n\t\tif (k) c[0] = '-';\n\t\tlongmulti(a + i, b + j, c + k);\n\t\treturn;\n\t}\n\n\tla = strlen(a);\n\tlb = strlen(b);\n\tmemset(c, '0', la + lb);\n\tc[la + lb] = '\\0';\n\n#\tdefine I(a) (a - '0')\n\tfor (i = la - 1; i >= 0; i--) {\n\t\tfor (j = lb - 1, k = i + j + 1, carry = 0; j >= 0; j--, k--) {\n\t\t\tn = I(a[i]) * I(b[j]) + I(c[k]) + carry;\n\t\t\tcarry = n / 10;\n\t\t\tc[k] = (n % 10) + '0';\n\t\t}\n\t\tc[k] += carry;\n\t}\n#\tundef I\n\tif (c[0] == '0') memmove(c, c + 1, la + lb);\n\n\treturn;\n}\n\nint main()\n{\n\tchar c[1024];\n\tlongmulti(\"-18446744073709551616\", \"-18446744073709551616\", c);\n\tprintf(\"%s\\n\", c);\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "\n\n\n\n\n\n\n\n\npackage main\n\nimport \"fmt\"\n\n\nfunc d(b byte) byte {\n    if b < '0' || b > '9' {\n        panic(\"digit 0-9 expected\")\n    }\n    return b - '0'\n}\n\n\nfunc add(x, y string) string {\n    if len(y) > len(x) {\n        x, y = y, x\n    }\n    b := make([]byte, len(x)+1)\n    var c byte\n    for i := 1; i <= len(x); i++ {\n        if i <= len(y) {\n            c += d(y[len(y)-i])\n        }\n        s := d(x[len(x)-i]) + c\n        c = s / 10\n        b[len(b)-i] = (s % 10) + '0'\n    }\n    if c == 0 {\n        return string(b[1:])\n    }\n    b[0] = c + '0'\n    return string(b)\n}\n\n\nfunc mulDigit(x string, y byte) string {\n    if y == '0' {\n        return \"0\"\n    }\n    y = d(y)\n    b := make([]byte, len(x)+1)\n    var c byte\n    for i := 1; i <= len(x); i++ {\n        s := d(x[len(x)-i])*y + c\n        c = s / 10\n        b[len(b)-i] = (s % 10) + '0'\n    }\n    if c == 0 {\n        return string(b[1:])\n    }\n    b[0] = c + '0'\n    return string(b)\n}\n\n\nfunc mul(x, y string) string {\n    result := mulDigit(x, y[len(y)-1])\n    for i, zeros := 2, \"\"; i <= len(y); i++ {\n        zeros += \"0\"\n        result = add(result, mulDigit(x, y[len(y)-i])+zeros)\n    }\n    return result\n}\n\n\nconst n = \"18446744073709551616\"\n\nfunc main() {\n    fmt.Println(mul(n, n))\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 206,
    "input": "Translate PHP to Python:<?php\n$time = new DateTime('March 7 2009 7:30pm EST');\n$time->modify('+12 hours');\necho $time->format('c');\n?>\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import datetime\n\ndef mt():\n\tdatime1=\"March 7 2009 7:30pm EST\"\n\tformatting = \"%B %d %Y %I:%M%p \"\n\tdatime2 = datime1[:-3]  \n\ttdelta = datetime.timedelta(hours=12)\t\t\n\ts3 = datetime.datetime.strptime(datime2, formatting)\n\tdatime2 = s3+tdelta\n\tprint datime2.strftime(\"%B %d %Y %I:%M%p %Z\") + datime1[-3:]\n\nmt()\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 207,
    "input": "Translate C to C++:#include <locale.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\n\n\nuint64_t digit_sum(uint64_t n, uint64_t sum) {\n    ++sum;\n    while (n > 0 && n % 10 == 0) {\n        sum -= 9;\n        n /= 10;\n    }\n    return sum;\n}\n\ninline bool divisible(uint64_t n, uint64_t d) {\n    if ((d & 1) == 0 && (n & 1) == 1)\n        return false;\n    return n % d == 0;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n\n    uint64_t previous = 1, gap = 0, sum = 0;\n    int niven_index = 0, gap_index = 1;\n\n    printf(\"Gap index  Gap    Niven index    Niven number\\n\");\n    for (uint64_t niven = 1; gap_index <= 32; ++niven) {\n        sum = digit_sum(niven, sum);\n        if (divisible(niven, sum)) {\n            if (niven > previous + gap) {\n                gap = niven - previous;\n                printf(\"%'9d %'4llu %'14d %'15llu\\n\", gap_index++,\n                       gap, niven_index, previous);\n            }\n            previous = niven;\n            ++niven_index;\n        }\n    }\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <cstdint>\n#include <iomanip>\n#include <iostream>\n\n\n\nuint64_t digit_sum(uint64_t n, uint64_t sum) {\n    ++sum;\n    while (n > 0 && n % 10 == 0) {\n        sum -= 9;\n        n /= 10;\n    }\n    return sum;\n}\n\ninline bool divisible(uint64_t n, uint64_t d) {\n    if ((d & 1) == 0 && (n & 1) == 1)\n        return false;\n    return n % d == 0;\n}\n\nint main() {\n    \n    std::cout.imbue(std::locale(\"\"));\n\n    uint64_t previous = 1, gap = 0, sum = 0;\n    int niven_index = 0, gap_index = 1;\n\n    std::cout << \"Gap index  Gap    Niven index    Niven number\\n\";\n    for (uint64_t niven = 1; gap_index <= 32; ++niven) {\n        sum = digit_sum(niven, sum);\n        if (divisible(niven, sum)) {\n            if (niven > previous + gap) {\n                gap = niven - previous;\n                std::cout << std::setw(9) << gap_index++\n                    << std::setw(5) << gap\n                    << std::setw(15) << niven_index\n                    << std::setw(16) << previous << '\\n';\n            }\n            previous = niven;\n            ++niven_index;\n        }\n    }\n    return 0;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 208,
    "input": "Translate C++ to Go:#include <iomanip>\n#include <iostream>\n#include <boost/math/constants/constants.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing big_float = boost::multiprecision::cpp_dec_float_100;\n\nbig_float f(unsigned int n) {\n    big_float pi(boost::math::constants::pi<big_float>());\n    return exp(sqrt(big_float(n)) * pi);\n}\n\nint main() {\n    std::cout << \"Ramanujan's constant using formula f(N) = exp(pi*sqrt(N)):\\n\"\n        << std::setprecision(80) << f(163) << '\\n';\n    std::cout << \"\\nResult with last four Heegner numbers:\\n\";\n    std::cout << std::setprecision(30);\n    for (unsigned int n : {19, 43, 67, 163}) {\n        auto x = f(n);\n        auto c = ceil(x);\n        auto pc = 100.0 * (x/c);\n        std::cout << \"f(\" << n << \") = \" << x << \" = \"\n            << pc << \"% of \" << c << '\\n';\n    }\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"github.com/ALTree/bigfloat\"\n    \"math/big\"\n)\n\nconst (\n    prec = 256 \n    ps   = \"3.1415926535897932384626433832795028841971693993751058209749445923078164\"\n)\n\nfunc q(d int64) *big.Float {\n    pi, _ := new(big.Float).SetPrec(prec).SetString(ps)\n    t := new(big.Float).SetPrec(prec).SetInt64(d)\n    t.Sqrt(t)\n    t.Mul(pi, t)\n    return bigfloat.Exp(t)\n}\n\nfunc main() {\n    fmt.Println(\"Ramanujan's constant to 32 decimal places is:\")\n    fmt.Printf(\"%.32f\\n\", q(163))\n    heegners := [4][2]int64{\n        {19, 96},\n        {43, 960},\n        {67, 5280},\n        {163, 640320},\n    }\n    fmt.Println(\"\\nHeegner numbers yielding 'almost' integers:\")\n    t := new(big.Float).SetPrec(prec)\n    for _, h := range heegners {\n        qh := q(h[0])\n        c := h[1]*h[1]*h[1] + 744\n        t.SetInt64(c)\n        t.Sub(t, qh)\n        fmt.Printf(\"%3d: %51.32f ≈ %18d (diff: %.32f)\\n\", h[0], qh, c, t)\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 209,
    "input": "Translate Python to Go:import os\n\nfrom collections import Counter\nfrom functools import reduce\nfrom itertools import permutations\n\nBASES = (\"A\", \"C\", \"G\", \"T\")\n\n\ndef deduplicate(sequences):\n    \n    sequences = set(sequences)\n    duplicates = set()\n\n    for s, t in permutations(sequences, 2):\n        if s != t and s in t:\n            duplicates.add(s)\n\n    return sequences - duplicates\n\n\ndef smash(s, t):\n    \n    for i in range(len(s)):\n        if t.startswith(s[i:]):\n            return s[:i] + t\n    return s + t\n\n\ndef shortest_superstring(sequences):\n    \n    sequences = deduplicate(sequences)\n    shortest = \"\".join(sequences)\n\n    for perm in permutations(sequences):\n        superstring = reduce(smash, perm)\n        if len(superstring) < len(shortest):\n            shortest = superstring\n\n    return shortest\n\n\ndef shortest_superstrings(sequences):\n    \n    sequences = deduplicate(sequences)\n\n    shortest = set([\"\".join(sequences)])\n    shortest_length = sum(len(s) for s in sequences)\n\n    for perm in permutations(sequences):\n        superstring = reduce(smash, perm)\n        superstring_length = len(superstring)\n        if superstring_length < shortest_length:\n            shortest.clear()\n            shortest.add(superstring)\n            shortest_length = superstring_length\n        elif superstring_length == shortest_length:\n            shortest.add(superstring)\n\n    return shortest\n\n\ndef print_report(sequence):\n    \n    buf = [f\"Nucleotide counts for {sequence}:\\n\"]\n\n    counts = Counter(sequence)\n    for base in BASES:\n        buf.append(f\"{base:>10}{counts.get(base, 0):>12}\")\n\n    other = sum(v for k, v in counts.items() if k not in BASES)\n    buf.append(f\"{'Other':>10}{other:>12}\")\n\n    buf.append(\" \" * 5 + \"_\" * 17)\n    buf.append(f\"{'Total length':>17}{sum(counts.values()):>5}\")\n\n    print(os.linesep.join(buf), \"\\n\")\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"TA\", \"AAG\", \"TA\", \"GAA\", \"TA\"),\n        (\"CATTAGGG\", \"ATTAG\", \"GGG\", \"TA\"),\n        (\"AAGAUGGA\", \"GGAGCGCAUC\", \"AUCGCAAUAAGGA\"),\n        (\n            \"ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT\",\n            \"GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT\",\n            \"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\",\n            \"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\",\n            \"GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC\",\n            \"CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT\",\n            \"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC\",\n            \"GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT\",\n            \"TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\",\n            \"TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA\",\n        ),\n    ]\n\n    for case in test_cases:\n        for superstring in shortest_superstrings(case):\n            print_report(superstring)\n\n    \n    \n    \n    \n    \n    \n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\n\nfunc factorial(n int) int {\n    fact := 1\n    for i := 2; i <= n; i++ {\n        fact *= i\n    }\n    return fact\n}\n\n\nfunc getPerms(input []string) [][]string {\n    perms := [][]string{input}\n    le := len(input)\n    a := make([]string, le)\n    copy(a, input)\n    n := le - 1\n    fact := factorial(n + 1)\n\n    for c := 1; c < fact; c++ {\n        i := n - 1\n        j := n\n        for i >= 0 && a[i] > a[i+1] {\n            i--\n        }\n        if i == -1 {\n            i = n\n        }\n        for a[j] < a[i] {\n            j--\n        }\n        a[i], a[j] = a[j], a[i]\n        j = n\n        i++\n        if i == n+1 {\n            i = 0\n        }\n        for i < j {\n            a[i], a[j] = a[j], a[i]\n            i++\n            j--\n        }\n        b := make([]string, le)\n        copy(b, a)\n        perms = append(perms, b)\n    }\n    return perms\n}\n\n\nfunc distinct(slist []string) []string {\n    distinctSet := make(map[string]int, len(slist))\n    i := 0\n    for _, s := range slist {\n        if _, ok := distinctSet[s]; !ok {\n            distinctSet[s] = i\n            i++\n        }\n    }\n    result := make([]string, len(distinctSet))\n    for s, i := range distinctSet {\n        result[i] = s\n    }\n    return result\n}\n\n\nfunc printCounts(seq string) {\n    bases := [][]rune{{'A', 0}, {'C', 0}, {'G', 0}, {'T', 0}}\n    for _, c := range seq {\n        for _, base := range bases {\n            if c == base[0] {\n                base[1]++\n            }\n        }\n    }\n    sum := 0\n    fmt.Println(\"\\nNucleotide counts for\", seq, \"\\b:\\n\")\n    for _, base := range bases {\n        fmt.Printf(\"%10c%12d\\n\", base[0], base[1])\n        sum += int(base[1])\n    }\n    le := len(seq)\n    fmt.Printf(\"%10s%12d\\n\", \"Other\", le-sum)\n    fmt.Printf(\"  ____________________\\n%14s%8d\\n\", \"Total length\", le)\n}\n\n\nfunc headTailOverlap(s1, s2 string) int {\n    for start := 0; ; start++ {\n        ix := strings.IndexByte(s1[start:], s2[0])\n        if ix == -1 {\n            return 0\n        } else {\n            start += ix\n        }\n        if strings.HasPrefix(s2, s1[start:]) {\n            return len(s1) - start\n        }\n    }\n}\n\n\nfunc deduplicate(slist []string) []string {\n    var filtered []string\n    arr := distinct(slist)\n    for i, s1 := range arr {\n        withinLarger := false\n        for j, s2 := range arr {\n            if j != i && strings.Contains(s2, s1) {\n                withinLarger = true\n                break\n            }\n        }\n        if !withinLarger {\n            filtered = append(filtered, s1)\n        }\n    }\n    return filtered\n}\n\n\nfunc shortestCommonSuperstring(slist []string) string {\n    ss := deduplicate(slist)\n    shortestSuper := strings.Join(ss, \"\")\n    for _, perm := range getPerms(ss) {\n        sup := perm[0]\n        for i := 0; i < len(ss)-1; i++ {\n            overlapPos := headTailOverlap(perm[i], perm[i+1])\n            sup += perm[i+1][overlapPos:]\n        }\n        if len(sup) < len(shortestSuper) {\n            shortestSuper = sup\n        }\n    }\n    return shortestSuper\n}\n\nfunc main() {\n    testSequences := [][]string{\n        {\"TA\", \"AAG\", \"TA\", \"GAA\", \"TA\"},\n        {\"CATTAGGG\", \"ATTAG\", \"GGG\", \"TA\"},\n        {\"AAGAUGGA\", \"GGAGCGCAUC\", \"AUCGCAAUAAGGA\"},\n        {\n            \"ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT\",\n            \"GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT\",\n            \"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\",\n            \"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\",\n            \"GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC\",\n            \"CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT\",\n            \"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC\",\n            \"GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT\",\n            \"TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\",\n            \"TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA\",\n        },\n    }\n\n    for _, test := range testSequences {\n        scs := shortestCommonSuperstring(test)\n        printCounts(scs)\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 210,
    "input": "Translate Java to Python:import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import numpy as np\nimport scipy as sp\nimport scipy.stats\n\ndef welch_ttest(x1, x2):\n    n1 = x1.size\n    n2 = x2.size\n    m1 = np.mean(x1)\n    m2 = np.mean(x2)\n    v1 = np.var(x1, ddof=1)\n    v2 = np.var(x2, ddof=1)\n    t = (m1 - m2) / np.sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2 * sp.stats.t.cdf(-abs(t), df)\n    return t, df, p\n\nwelch_ttest(np.array([3.0, 4.0, 1.0, 2.1]), np.array([490.2, 340.0, 433.9]))\n(-9.559497721932658, 2.0008523488562844, 0.01075156114978449)\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 211,
    "input": "Translate C++ to VB:#include <stack>\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "\n\n\n\n\n\nPrivate myStack()\nPrivate myStackHeight As Integer\n\n\nPublic Function Push(aValue)\n  \n  myStackHeight = myStackHeight + 1\n  ReDim Preserve myStack(myStackHeight)\n  myStack(myStackHeight) = aValue\nEnd Function\n\n\nPublic Function Pop()\n  \n  If myStackHeight > 0 Then\n    Pop = myStack(myStackHeight)\n    myStackHeight = myStackHeight - 1\n  Else\n    MsgBox \"Pop: stack is empty!\"\n  End If\nEnd Function\n\n\nPublic Function IsEmpty() As Boolean\n  IsEmpty = (myStackHeight = 0)\nEnd Function\n\n\nProperty Get Size() As Integer\n  Size = myStackHeight\nEnd Property\n",
    "input_language": "C++",
    "output_language": "VB"
  },
  {
    "id": 212,
    "input": "Translate C to Go:#include<stdlib.h>\n#include<locale.h>\n#include<wchar.h>\n#include<stdio.h>\n#include<time.h>\n\nchar rank[9];\n\nint pos[8];\n\nvoid swap(int i,int j){\n\tint temp = pos[i];\n\tpos[i] = pos[j];\n\tpos[j] = temp;\n}\n\nvoid generateFirstRank(){\n\t int kPos,qPos,bPos1,bPos2,rPos1,rPos2,nPos1,nPos2,i;\n\t \n\t for(i=0;i<8;i++){\n\t\t rank[i] = 'e';\n\t\t pos[i] = i;\n\t }\n\t\t \n\t do{\n\t\t kPos = rand()%8;\n\t\t rPos1 = rand()%8;\n\t\t rPos2 = rand()%8;\n\t }while((rPos1-kPos<=0 && rPos2-kPos<=0)||(rPos1-kPos>=0 && rPos2-kPos>=0)||(rPos1==rPos2 || kPos==rPos1 || kPos==rPos2));\n\n\t rank[pos[rPos1]] = 'R';\n\t rank[pos[kPos]] = 'K';\n\t rank[pos[rPos2]] = 'R';\n\t \n\t swap(rPos1,7);\n\t swap(rPos2,6);\n\t swap(kPos,5);\n\t \n\t do{\n\t\t bPos1 = rand()%5;\n\t\t bPos2 = rand()%5;\n\t }while(((pos[bPos1]-pos[bPos2])%2==0)||(bPos1==bPos2));\n\n\t rank[pos[bPos1]] = 'B';\n\t rank[pos[bPos2]] = 'B';\n\t \n\t swap(bPos1,4);\n\t swap(bPos2,3);\n\t \n\t do{\n\t\t qPos = rand()%3;\n\t\t nPos1 = rand()%3;\n\t }while(qPos==nPos1);\n\t \n\t rank[pos[qPos]] = 'Q';\n\t rank[pos[nPos1]] = 'N';\n\t \n\t for(i=0;i<8;i++)\n\t\t if(rank[i]=='e'){\n\t\t\t rank[i] = 'N';\n\t\t\t break;\n\t\t }\t\t\n}\n\nvoid printRank(){\n\tint i;\n\t\n\t#ifdef _WIN32\n\t\tprintf(\"%s\\n\",rank);\n\t#else\n\t{\n\t\tsetlocale(LC_ALL,\"\");\n\t\tprintf(\"\\n\");\n\t\tfor(i=0;i<8;i++){\n\t\t\tif(rank[i]=='K')\n\t\t\t\tprintf(\"%lc\",(wint_t)9812);\n\t\t\telse if(rank[i]=='Q')\n\t\t\t\tprintf(\"%lc\",(wint_t)9813);\n\t\t\telse if(rank[i]=='R')\n\t\t\t\tprintf(\"%lc\",(wint_t)9814);\n\t\t\telse if(rank[i]=='B')\n\t\t\t\tprintf(\"%lc\",(wint_t)9815);\n\t\t\tif(rank[i]=='N')\n\t\t\t\tprintf(\"%lc\",(wint_t)9816);\n\t\t}\n\t}\n\t#endif\n}\n\nint main()\n{\n\tint i;\n\t\n\tsrand((unsigned)time(NULL));\n\t\n\tfor(i=0;i<9;i++){\n\t\tgenerateFirstRank();\n\t\tprintRank();\n\t}\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n)\n\ntype symbols struct{ k, q, r, b, n rune }\n\nvar A = symbols{'K', 'Q', 'R', 'B', 'N'}\nvar W = symbols{'♔', '♕', '♖', '♗', '♘'}\nvar B = symbols{'♚', '♛', '♜', '♝', '♞'}\n\nvar krn = []string{\n    \"nnrkr\", \"nrnkr\", \"nrknr\", \"nrkrn\",\n    \"rnnkr\", \"rnknr\", \"rnkrn\",\n    \"rknnr\", \"rknrn\",\n    \"rkrnn\"}\n\nfunc (sym symbols) chess960(id int) string {\n    var pos [8]rune\n    q, r := id/4, id%4\n    pos[r*2+1] = sym.b\n    q, r = q/4, q%4\n    pos[r*2] = sym.b\n    q, r = q/6, q%6\n    for i := 0; ; i++ {\n        if pos[i] != 0 {\n            continue\n        }\n        if r == 0 {\n            pos[i] = sym.q\n            break\n        }\n        r--\n    }\n    i := 0\n    for _, f := range krn[q] {\n        for pos[i] != 0 {\n            i++\n        }\n        switch f {\n        case 'k':\n            pos[i] = sym.k\n        case 'r':\n            pos[i] = sym.r\n        case 'n':\n            pos[i] = sym.n\n        }\n    }\n    return string(pos[:])\n}\n\nfunc main() {\n    fmt.Println(\" ID  Start position\")\n    for _, id := range []int{0, 518, 959} {\n        fmt.Printf(\"%3d  %s\\n\", id, A.chess960(id))\n    }\n    fmt.Println(\"\\nRandom\")\n    for i := 0; i < 5; i++ {\n        fmt.Println(W.chess960(rand.Intn(960)))\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 213,
    "input": "Translate C++ to C#:#include <iostream>\n \nvoid recurse(unsigned int i)\n{\n  std::cout<<i<<\"\\n\";\n  recurse(i+1);\n}\n \nint main()\n{\n  recurse(0);\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 214,
    "input": "Translate C to Python:#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n\ntypedef double (* Ifctn)( double t);\n\ndouble Simpson3_8( Ifctn f, double a, double b, int N)\n{\n    int j;\n    double l1;\n    double h = (b-a)/N;\n    double h1 = h/3.0;\n    double sum = f(a) + f(b);\n\n    for (j=3*N-1; j>0; j--) {\n        l1 = (j%3)? 3.0 : 2.0;\n        sum += l1*f(a+h1*j) ;\n    }\n    return h*sum/8.0;\n}\n\n#define A 12\ndouble Gamma_Spouge( double z )\n{\n    int k;\n    static double cspace[A];\n    static double *coefs = NULL;\n    double accum;\n    double a = A;\n\n    if (!coefs) {\n        double k1_factrl = 1.0;\n        coefs = cspace;\n        coefs[0] = sqrt(2.0*M_PI);\n        for(k=1; k<A; k++) {\n            coefs[k] = exp(a-k) * pow(a-k,k-0.5) / k1_factrl;\n            k1_factrl *= -k;\n        }\n    }\n\n    accum = coefs[0];\n    for (k=1; k<A; k++) {\n        accum += coefs[k]/(z+k);\n    }\n    accum *= exp(-(z+a)) * pow(z+a, z+0.5);\n    return accum/z;\n}\n\ndouble aa1;\ndouble f0( double t)\n{\n    return  pow(t, aa1)*exp(-t); \n}\n\ndouble GammaIncomplete_Q( double a, double x)\n{\n    double y, h = 1.5e-2;  \n\n    \n    y = aa1 = a-1;\n    while((f0(y) * (x-y) > 2.0e-8) && (y < x))   y += .4;\n    if (y>x) y=x;\n\n    return 1.0 - Simpson3_8( &f0, 0, y, (int)(y/h))/Gamma_Spouge(a);\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "import math\nimport random\n\ndef GammaInc_Q( a, x):\n    a1 = a-1\n    a2 = a-2\n    def f0( t ):\n        return t**a1*math.exp(-t)\n\n    def df0(t):\n        return (a1-t)*t**a2*math.exp(-t)\n    \n    y = a1\n    while f0(y)*(x-y) >2.0e-8 and y < x: y += .3\n    if y > x: y = x\n\n    h = 3.0e-4\n    n = int(y/h)\n    h = y/n\n    hh = 0.5*h\n    gamax = h * sum( f0(t)+hh*df0(t) for t in ( h*j for j in xrange(n-1, -1, -1)))\n\n    return gamax/gamma_spounge(a)\n\nc = None\ndef gamma_spounge( z):\n    global c\n    a = 12\n\n    if c is None:\n       k1_factrl = 1.0\n       c = []\n       c.append(math.sqrt(2.0*math.pi))\n       for k in range(1,a):\n          c.append( math.exp(a-k) * (a-k)**(k-0.5) / k1_factrl )\n          k1_factrl *= -k\n    \n    accm = c[0]\n    for k in range(1,a):\n        accm += c[k] / (z+k)\n    accm *= math.exp( -(z+a)) * (z+a)**(z+0.5)\n    return accm/z;\n\ndef chi2UniformDistance( dataSet ):\n    expected = sum(dataSet)*1.0/len(dataSet)\n    cntrd = (d-expected for d in dataSet)\n    return sum(x*x for x in cntrd)/expected\n\ndef chi2Probability(dof, distance):\n    return 1.0 - GammaInc_Q( 0.5*dof, 0.5*distance)\n\ndef chi2IsUniform(dataSet, significance):\n    dof = len(dataSet)-1\n    dist = chi2UniformDistance(dataSet)\n    return chi2Probability( dof, dist ) > significance\n\ndset1 = [ 199809, 200665, 199607, 200270, 199649 ]\ndset2 = [ 522573, 244456, 139979,  71531,  21461 ]\n\nfor ds in (dset1, dset2):\n    print \"Data set:\", ds\n    dof = len(ds)-1\n    distance =chi2UniformDistance(ds)\n    print \"dof: %d distance: %.4f\" % (dof, distance),\n    prob = chi2Probability( dof, distance)\n    print \"probability: %.4f\"%prob,\n    print \"uniform? \", \"Yes\"if chi2IsUniform(ds,0.05) else \"No\"\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 215,
    "input": "Translate Go to VB:package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"strings\"\n)\n\nfunc factorial(n int64) *big.Int {\n    var z big.Int\n    return z.MulRange(1, n)\n}\n\nvar one = big.NewInt(1)\nvar three = big.NewInt(3)\nvar six = big.NewInt(6)\nvar ten = big.NewInt(10)\nvar seventy = big.NewInt(70)\n\nfunc almkvistGiullera(n int64, print bool) *big.Rat {\n    t1 := big.NewInt(32)\n    t1.Mul(factorial(6*n), t1)\n    t2 := big.NewInt(532*n*n + 126*n + 9)\n    t3 := new(big.Int)\n    t3.Exp(factorial(n), six, nil)\n    t3.Mul(t3, three)\n    ip := new(big.Int)\n    ip.Mul(t1, t2)\n    ip.Quo(ip, t3)\n    pw := 6*n + 3\n    t1.SetInt64(pw)\n    tm := new(big.Rat).SetFrac(ip, t1.Exp(ten, t1, nil))\n    if print {\n        fmt.Printf(\"%d  %44d  %3d  %-35s\\n\", n, ip, -pw, tm.FloatString(33))\n    }\n    return tm\n}\n\nfunc main() {\n    fmt.Println(\"N                               Integer Portion  Pow  Nth Term (33 dp)\")\n    fmt.Println(strings.Repeat(\"-\", 89))\n    for n := int64(0); n < 10; n++ {\n        almkvistGiullera(n, true)\n    }\n\n    sum := new(big.Rat)\n    prev := new(big.Rat)\n    pow70 := new(big.Int).Exp(ten, seventy, nil)\n    prec := new(big.Rat).SetFrac(one, pow70)\n    n := int64(0)\n    for {\n        term := almkvistGiullera(n, false)\n        sum.Add(sum, term)\n        z := new(big.Rat).Sub(sum, prev)\n        z.Abs(z)\n        if z.Cmp(prec) < 0 {\n            break\n        }\n        prev.Set(sum)\n        n++\n    }\n    sum.Inv(sum)\n    pi := new(big.Float).SetPrec(256).SetRat(sum)\n    pi.Sqrt(pi)\n    fmt.Println(\"\\nPi to 70 decimal places is:\")\n    fmt.Println(pi.Text('f', 70))\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Imports System, BI = System.Numerics.BigInteger, System.Console\n\nModule Module1\n\n    Function isqrt(ByVal x As BI) As BI\n        Dim t As BI, q As BI = 1, r As BI = 0\n        While q <= x : q <<= 2 : End While\n        While q > 1 : q >>= 2 : t = x - r - q : r >>= 1\n            If t >= 0 Then x = t : r += q\n        End While : Return r\n    End Function\n\n    Function dump(ByVal digs As Integer, ByVal Optional show As Boolean = False) As String\n        digs += 1\n        Dim z As Integer, gb As Integer = 1, dg As Integer = digs + gb\n        Dim te As BI, t1 As BI = 1, t2 As BI = 9, t3 As BI = 1, su As BI = 0, t As BI = BI.Pow(10, If(dg <= 60, 0, dg - 60)), d As BI = -1, fn As BI = 1\n        For n As BI = 0 To dg - 1\n            If n > 0 Then t3 = t3 * BI.Pow(n, 6)\n            te = t1 * t2 / t3 : z = dg - 1 - CInt(n) * 6\n            If z > 0 Then te = te * BI.Pow(10, z) Else te = te / BI.Pow(10, -z)\n            If show AndAlso n < 10 Then WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t)\n            su += te : If te < 10 Then\n                digs -= 1\n                If show Then WriteLine(vbLf & \"{0} iterations required for {1} digits \" & _\n                    \"after the decimal point.\" & vbLf, n, digs)\n                Exit For\n            End If\n            For j As BI = n * 6 + 1 To n * 6 + 6\n                t1 = t1 * j : Next\n            d += 2 : t2 += 126 + 532 * d\n        Next\n        Dim s As String = String.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) _\n            / su / 32 * 3 * BI.Pow(CType(10, BI), dg + 5)))\n        Return s(0) & \".\" & s.Substring(1, digs)\n    End Function\n\n    Sub Main(ByVal args As String())\n        WriteLine(dump(70, true))\n    End Sub\n\nEnd Module\n",
    "input_language": "Go",
    "output_language": "VB"
  },
  {
    "id": 216,
    "input": "Translate Java to Go:import java.util.*;\n\npublic class Numbrix {\n\n    final static String[] board = {\n        \"00,00,00,00,00,00,00,00,00\",\n        \"00,00,46,45,00,55,74,00,00\",\n        \"00,38,00,00,43,00,00,78,00\",\n        \"00,35,00,00,00,00,00,71,00\",\n        \"00,00,33,00,00,00,59,00,00\",\n        \"00,17,00,00,00,00,00,67,00\",\n        \"00,18,00,00,11,00,00,64,00\",\n        \"00,00,24,21,00,01,02,00,00\",\n        \"00,00,00,00,00,00,00,00,00\"};\n\n    final static int[][] moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    static int[][] grid;\n    static int[] clues;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 2;\n        int nCols = board[0].split(\",\").length + 2;\n        int startRow = 0, startCol = 0;\n\n        grid = new int[nRows][nCols];\n        totalToFill = (nRows - 2) * (nCols - 2);\n        List<Integer> lst = new ArrayList<>();\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n\n            if (r >= 1 && r < nRows - 1) {\n\n                String[] row = board[r - 1].split(\",\");\n\n                for (int c = 1; c < nCols - 1; c++) {\n                    int val = Integer.parseInt(row[c - 1]);\n                    if (val > 0)\n                        lst.add(val);\n                    if (val == 1) {\n                        startRow = r;\n                        startCol = c;\n                    }\n                    grid[r][c] = val;\n                }\n            }\n        }\n\n        clues = lst.stream().sorted().mapToInt(i -> i).toArray();\n\n        if (solve(startRow, startCol, 1, 0))\n            printResult();\n    }\n\n    static boolean solve(int r, int c, int count, int nextClue) {\n        if (count > totalToFill)\n            return true;\n\n        if (grid[r][c] != 0 && grid[r][c] != count)\n            return false;\n\n        if (grid[r][c] == 0 && nextClue < clues.length)\n            if (clues[nextClue] == count)\n                return false;\n\n        int back = grid[r][c];\n        if (back == count)\n            nextClue++;\n\n        grid[r][c] = count;\n        for (int[] move : moves)\n            if (solve(r + move[1], c + move[0], count + 1, nextClue))\n                return true;\n\n        grid[r][c] = back;\n        return false;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"strconv\"\n    \"strings\"\n)\n\nvar example1 = []string{\n    \"00,00,00,00,00,00,00,00,00\",\n    \"00,00,46,45,00,55,74,00,00\",\n    \"00,38,00,00,43,00,00,78,00\",\n    \"00,35,00,00,00,00,00,71,00\",\n    \"00,00,33,00,00,00,59,00,00\",\n    \"00,17,00,00,00,00,00,67,00\",\n    \"00,18,00,00,11,00,00,64,00\",\n    \"00,00,24,21,00,01,02,00,00\",\n    \"00,00,00,00,00,00,00,00,00\",\n}\n\nvar example2 = []string{\n    \"00,00,00,00,00,00,00,00,00\",\n    \"00,11,12,15,18,21,62,61,00\",\n    \"00,06,00,00,00,00,00,60,00\",\n    \"00,33,00,00,00,00,00,57,00\",\n    \"00,32,00,00,00,00,00,56,00\",\n    \"00,37,00,01,00,00,00,73,00\",\n    \"00,38,00,00,00,00,00,72,00\",\n    \"00,43,44,47,48,51,76,77,00\",\n    \"00,00,00,00,00,00,00,00,00\",\n}\n\nvar moves = [][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\n\nvar (\n    grid        [][]int\n    clues       []int\n    totalToFill = 0\n)\n\nfunc solve(r, c, count, nextClue int) bool {\n    if count > totalToFill {\n        return true\n    }\n\n    back := grid[r][c]\n\n    if back != 0 && back != count {\n        return false\n    }\n\n    if back == 0 && nextClue < len(clues) && clues[nextClue] == count {\n        return false\n    }\n\n    if back == count {\n        nextClue++\n    }\n\n    grid[r][c] = count\n    for _, move := range moves {\n        if solve(r+move[1], c+move[0], count+1, nextClue) {\n            return true\n        }\n    }\n    grid[r][c] = back\n    return false\n}\n\nfunc printResult(n int) {\n    fmt.Println(\"Solution for example\", n, \"\\b:\")\n    for _, row := range grid {\n        for _, i := range row {\n            if i == -1 {\n                continue\n            }\n            fmt.Printf(\"%2d \", i)\n        }\n        fmt.Println()\n    }\n}\n\nfunc main() {\n    for n, board := range [2][]string{example1, example2} {\n        nRows := len(board) + 2\n        nCols := len(strings.Split(board[0], \",\")) + 2\n        startRow, startCol := 0, 0\n        grid = make([][]int, nRows)\n        totalToFill = (nRows - 2) * (nCols - 2)\n        var lst []int\n\n        for r := 0; r < nRows; r++ {\n            grid[r] = make([]int, nCols)\n            for c := 0; c < nCols; c++ {\n                grid[r][c] = -1\n            }\n            if r >= 1 && r < nRows-1 {\n                row := strings.Split(board[r-1], \",\")\n                for c := 1; c < nCols-1; c++ {\n                    val, _ := strconv.Atoi(row[c-1])\n                    if val > 0 {\n                        lst = append(lst, val)\n                    }\n                    if val == 1 {\n                        startRow, startCol = r, c\n                    }\n                    grid[r][c] = val\n                }\n            }\n        }\n\n        sort.Ints(lst)\n        clues = lst\n        if solve(startRow, startCol, 1, 0) {\n            printResult(n + 1)\n        }\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 217,
    "input": "Translate C to Python:#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <stdbool.h>\n\ntypedef double Fp;\ntypedef struct { Fp x, y, r; } Circle;\n\nCircle circles[] = {\n    { 1.6417233788,  1.6121789534, 0.0848270516},\n    {-1.4944608174,  1.2077959613, 1.1039549836},\n    { 0.6110294452, -0.6907087527, 0.9089162485},\n    { 0.3844862411,  0.2923344616, 0.2375743054},\n    {-0.2495892950, -0.3832854473, 1.0845181219},\n    { 1.7813504266,  1.6178237031, 0.8162655711},\n    {-0.1985249206, -0.8343333301, 0.0538864941},\n    {-1.7011985145, -0.1263820964, 0.4776976918},\n    {-0.4319462812,  1.4104420482, 0.7886291537},\n    { 0.2178372997, -0.9499557344, 0.0357871187},\n    {-0.6294854565, -1.3078893852, 0.7653357688},\n    { 1.7952608455,  0.6281269104, 0.2727652452},\n    { 1.4168575317,  1.0683357171, 1.1016025378},\n    { 1.4637371396,  0.9463877418, 1.1846214562},\n    {-0.5263668798,  1.7315156631, 1.4428514068},\n    {-1.2197352481,  0.9144146579, 1.0727263474},\n    {-0.1389358881,  0.1092805780, 0.7350208828},\n    { 1.5293954595,  0.0030278255, 1.2472867347},\n    {-0.5258728625,  1.3782633069, 1.3495508831},\n    {-0.1403562064,  0.2437382535, 1.3804956588},\n    { 0.8055826339, -0.0482092025, 0.3327165165},\n    {-0.6311979224,  0.7184578971, 0.2491045282},\n    { 1.4685857879, -0.8347049536, 1.3670667538},\n    {-0.6855727502,  1.6465021616, 1.0593087096},\n    { 0.0152957411,  0.0638919221, 0.9771215985}};\n\nconst size_t n_circles = sizeof(circles) / sizeof(Circle);\n\nstatic inline Fp min(const Fp a, const Fp b) { return a <= b ? a : b; }\n\nstatic inline Fp max(const Fp a, const Fp b) { return a >= b ? a : b; }\n\nstatic inline Fp sq(const Fp a) { return a * a; }\n\n\nstatic inline double uniform(const double a, const double b) {\n    const double r01 = rand() / (double)RAND_MAX;\n    return a + (b - a) * r01;\n}\n\nstatic inline bool is_inside_circles(const Fp x, const Fp y) {\n    for (size_t i = 0; i < n_circles; i++)\n        if (sq(x - circles[i].x) + sq(y - circles[i].y) < circles[i].r)\n            return true;\n    return false;\n}\n\nint main() {\n    \n    Fp x_min = INFINITY, x_max = -INFINITY;\n    Fp y_min = x_min, y_max = x_max;\n\n    \n    for (size_t i = 0; i < n_circles; i++) {\n        Circle *c = &circles[i];\n        x_min = min(x_min, c->x - c->r);\n        x_max = max(x_max, c->x + c->r);\n        y_min = min(y_min, c->y - c->r);\n        y_max = max(y_max, c->y + c->r);\n\n        c->r *= c->r; \n    }\n\n    const Fp bbox_area = (x_max - x_min) * (y_max - y_min);\n\n    \n    srand(time(0));\n    size_t to_try = 1U << 16;\n    size_t n_tries = 0;\n    size_t n_hits = 0;\n\n    while (true) {\n        n_hits += is_inside_circles(uniform(x_min, x_max),\n                                    uniform(y_min, y_max));\n        n_tries++;\n\n        if (n_tries == to_try) {\n            const Fp area = bbox_area * n_hits / n_tries;\n            const Fp r = (Fp)n_hits / n_tries;\n            const Fp s = area * sqrt(r * (1 - r) / n_tries);\n            printf(\"%.4f +/- %.4f (%zd samples)\\n\", area, s, n_tries);\n            if (s * 3 <= 1e-3) \n                break;\n            to_try *= 2;\n        }\n    }\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from collections import namedtuple\n\nCircle = namedtuple(\"Circle\", \"x y r\")\n\ncircles = [\n    Circle( 1.6417233788,  1.6121789534, 0.0848270516),\n    Circle(-1.4944608174,  1.2077959613, 1.1039549836),\n    Circle( 0.6110294452, -0.6907087527, 0.9089162485),\n    Circle( 0.3844862411,  0.2923344616, 0.2375743054),\n    Circle(-0.2495892950, -0.3832854473, 1.0845181219),\n    Circle( 1.7813504266,  1.6178237031, 0.8162655711),\n    Circle(-0.1985249206, -0.8343333301, 0.0538864941),\n    Circle(-1.7011985145, -0.1263820964, 0.4776976918),\n    Circle(-0.4319462812,  1.4104420482, 0.7886291537),\n    Circle( 0.2178372997, -0.9499557344, 0.0357871187),\n    Circle(-0.6294854565, -1.3078893852, 0.7653357688),\n    Circle( 1.7952608455,  0.6281269104, 0.2727652452),\n    Circle( 1.4168575317,  1.0683357171, 1.1016025378),\n    Circle( 1.4637371396,  0.9463877418, 1.1846214562),\n    Circle(-0.5263668798,  1.7315156631, 1.4428514068),\n    Circle(-1.2197352481,  0.9144146579, 1.0727263474),\n    Circle(-0.1389358881,  0.1092805780, 0.7350208828),\n    Circle( 1.5293954595,  0.0030278255, 1.2472867347),\n    Circle(-0.5258728625,  1.3782633069, 1.3495508831),\n    Circle(-0.1403562064,  0.2437382535, 1.3804956588),\n    Circle( 0.8055826339, -0.0482092025, 0.3327165165),\n    Circle(-0.6311979224,  0.7184578971, 0.2491045282),\n    Circle( 1.4685857879, -0.8347049536, 1.3670667538),\n    Circle(-0.6855727502,  1.6465021616, 1.0593087096),\n    Circle( 0.0152957411,  0.0638919221, 0.9771215985)]\n\ndef main():\n    \n    x_min = min(c.x - c.r for c in circles)\n    x_max = max(c.x + c.r for c in circles)\n    y_min = min(c.y - c.r for c in circles)\n    y_max = max(c.y + c.r for c in circles)\n\n    box_side = 500\n\n    dx = (x_max - x_min) / box_side\n    dy = (y_max - y_min) / box_side\n\n    count = 0\n\n    for r in xrange(box_side):\n        y = y_min + r * dy\n        for c in xrange(box_side):\n            x = x_min + c * dx\n            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)\n                   for circle in circles):\n                count += 1\n\n    print \"Approximated area:\", count * dx * dy\n\nmain()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 218,
    "input": "Translate C to C++:#include <glib.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nguchar* sha256_merkle_tree(FILE* in, size_t block_size) {\n    gchar* buffer = g_malloc(block_size);\n    GPtrArray* hashes = g_ptr_array_new_with_free_func(g_free);\n    gssize digest_length = g_checksum_type_get_length(G_CHECKSUM_SHA256);\n    GChecksum* checksum = g_checksum_new(G_CHECKSUM_SHA256);\n    size_t bytes;\n    while ((bytes = fread(buffer, 1, block_size, in)) > 0) {\n        g_checksum_reset(checksum);\n        g_checksum_update(checksum, (guchar*)buffer, bytes);\n        gsize len = digest_length;\n        guchar* digest = g_malloc(len);\n        g_checksum_get_digest(checksum, digest, &len);\n        g_ptr_array_add(hashes, digest);\n    }\n    g_free(buffer);\n    guint hashes_length = hashes->len;\n    if (hashes_length == 0) {\n        g_ptr_array_free(hashes, TRUE);\n        g_checksum_free(checksum);\n        return NULL;\n    }\n    while (hashes_length > 1) {\n        guint j = 0;\n        for (guint i = 0; i < hashes_length; i += 2, ++j) {\n            guchar* digest1 = g_ptr_array_index(hashes, i);\n            guchar* digest_out = g_ptr_array_index(hashes, j);\n            if (i + 1 < hashes_length) {\n                guchar* digest2 = g_ptr_array_index(hashes, i + 1);\n                g_checksum_reset(checksum);\n                g_checksum_update(checksum, digest1, digest_length);\n                g_checksum_update(checksum, digest2, digest_length);\n                gsize len = digest_length;\n                g_checksum_get_digest(checksum, digest_out, &len);\n            } else {\n                memcpy(digest_out, digest1, digest_length);\n            }\n        }\n        hashes_length = j;\n    }\n    guchar* result = g_ptr_array_steal_index(hashes, 0);\n    g_ptr_array_free(hashes, TRUE);\n    g_checksum_free(checksum);\n    return result;\n}\n\nint main(int argc, char** argv) {\n    if (argc != 2) {\n        fprintf(stderr, \"usage: %s filename\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n    FILE* in = fopen(argv[1], \"rb\");\n    if (in) {\n        guchar* digest = sha256_merkle_tree(in, 1024);\n        fclose(in);\n        if (digest) {\n            gssize length = g_checksum_type_get_length(G_CHECKSUM_SHA256);\n            for (gssize i = 0; i < length; ++i)\n                printf(\"%02x\", digest[i]);\n            printf(\"\\n\");\n            g_free(digest);\n        }\n    } else {\n        perror(argv[1]);\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <openssl/sha.h>\n\nclass sha256_exception : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"SHA-256 error\";\n    }\n};\n\nclass sha256 {\npublic:\n    sha256() { reset(); }\n    sha256(const sha256&) = delete;\n    sha256& operator=(const sha256&) = delete;\n    void reset() {\n        if (SHA256_Init(&context_) == 0)\n            throw sha256_exception();\n    }\n    void update(const void* data, size_t length) {\n        if (SHA256_Update(&context_, data, length) == 0)\n            throw sha256_exception();\n    }\n    std::vector<unsigned char> digest() {\n        std::vector<unsigned char> digest(SHA256_DIGEST_LENGTH);\n        if (SHA256_Final(digest.data(), &context_) == 0)\n            throw sha256_exception();\n        return digest;\n    }\nprivate:\n    SHA256_CTX context_;\n};\n\nstd::string digest_to_string(const std::vector<unsigned char>& digest) {\n    std::ostringstream out;\n    out << std::hex << std::setfill('0');\n    for (size_t i = 0; i < digest.size(); ++i)\n        out << std::setw(2) << static_cast<int>(digest[i]);\n    return out.str();\n}\n\nstd::vector<unsigned char> sha256_merkle_tree(std::istream& in, size_t block_size) {\n    std::vector<std::vector<unsigned char>> hashes;\n    std::vector<char> buffer(block_size);\n    sha256 md;\n    while (in) {\n        in.read(buffer.data(), block_size);\n        size_t bytes = in.gcount();\n        if (bytes == 0)\n            break;\n        md.reset();\n        md.update(buffer.data(), bytes);\n        hashes.push_back(md.digest());\n    }\n    if (hashes.empty())\n        return {};\n    size_t length = hashes.size();\n    while (length > 1) {\n        size_t j = 0;\n        for (size_t i = 0; i < length; i += 2, ++j) {\n            auto& digest1 = hashes[i];\n            auto& digest_out = hashes[j];\n            if (i + 1 < length) {\n                auto& digest2 = hashes[i + 1];\n                md.reset();\n                md.update(digest1.data(), digest1.size());\n                md.update(digest2.data(), digest2.size());\n                digest_out = md.digest();\n            } else {\n                digest_out = digest1;\n            }\n        }\n        length = j;\n    }\n    return hashes[0];\n}\n\nint main(int argc, char** argv) {\n    if (argc != 2) {\n        std::cerr << \"usage: \" << argv[0] << \" filename\\n\";\n        return EXIT_FAILURE;\n    }\n    std::ifstream in(argv[1], std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file \" << argv[1] << \".\\n\";\n        return EXIT_FAILURE;\n    }\n    try {\n        std::cout << digest_to_string(sha256_merkle_tree(in, 1024)) << '\\n';\n    } catch (const std::exception& ex) {\n        std::cerr << ex.what() << \"\\n\";\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 219,
    "input": "Translate Java to C#:public static int[] sort(int[] old) {\n    \n    for (int shift = Integer.SIZE - 1; shift > -1; shift--) {\n        \n        int[] tmp = new int[old.length];\n        \n        int j = 0;\n\n        \n        for (int i = 0; i < old.length; i++) {\n            \n            boolean move = old[i] << shift >= 0;\n\n            \n            if (shift == 0 ? !move : move) {\n                tmp[j] = old[i];\n                j++;\n            } else {\n                \n                old[i - j] = old[i];\n            }\n        }\n\n        \n        for (int i = j; i < tmp.length; i++) {\n            tmp[i] = old[i - j];\n        }\n\n        \n        old = tmp;\n    }\n\n    return old;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\n\nnamespace RadixSort\n{\n    class Program\n    {\n        static void Sort(int[] old)\n        {\n            int i, j;\n            int[] tmp = new int[old.Length];\n            for (int shift = 31; shift > -1; --shift)\n            {\n                j = 0;\n                for (i = 0; i < old.Length; ++i)\n                {\n                    bool move = (old[i] << shift) >= 0;\n                    if (shift == 0 ? !move : move)  \n                        old[i-j] = old[i];\n                    else                            \n                        tmp[j++] = old[i];\n                }\n                Array.Copy(tmp, 0, old, old.Length-j, j);\n            }\n        }\n        static void Main(string[] args)\n        {\n            int[] old = new int[] { 2, 5, 1, -3, 4 };\n            Console.WriteLine(string.Join(\", \", old));\n            Sort(old);\n            Console.WriteLine(string.Join(\", \", old));\n            Console.Read();\n        }\n    }\n}\n",
    "input_language": "Java",
    "output_language": "C#"
  },
  {
    "id": 220,
    "input": "Translate C to C++:#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\nenum { MAX_ROWS=14, MAX_NAMES=20, NAME_SZ=80 };\n\nchar *Lines[MAX_ROWS] = {\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                      ID                       |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    QDCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    ANCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    NSCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\",\n   \"  |                    ARCOUNT                    |\",\n   \"  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\n};\ntypedef struct {\n   unsigned bit3s;\n   unsigned mask;\n   unsigned data;\n   char A[NAME_SZ+2];\n}NAME_T;\nNAME_T names[MAX_NAMES];\nunsigned idx_name;\nenum{ID,BITS,QDCOUNT,ANCOUNT,NSCOUNT,ARCOUNT,MAX_HDR};\nunsigned header[MAX_HDR]; \nunsigned idx_hdr;\n\nint  bit_hdr(char *pLine);\nint  bit_names(char *pLine);\nvoid dump_names(void);\nvoid make_test_hdr(void);\n\nint main(void){\n   char *p1;   int rv;\n   printf(\"Extract meta-data from bit-encoded text form\\n\");\n   make_test_hdr();\n   idx_name = 0;\n   for( int i=0; i<MAX_ROWS;i++ ){\n      p1 = Lines[i];\n      if( p1==NULL ) break;\n      if( rv = bit_hdr(Lines[i]), rv>0) continue;\n      if( rv = bit_names(Lines[i]),rv>0) continue;\n      \n   }\n   dump_names();\n}\n\nint  bit_hdr(char *pLine){ \n   char *p1 = strchr(pLine,'+');\n   if( p1==NULL ) return 0;\n   int numbits=0;\n   for( int i=0; i<strlen(p1)-1; i+=3 ){\n      if( p1[i] != '+' || p1[i+1] != '-' || p1[i+2] != '-' ) return 0;\n      numbits++;\n   }\n   return numbits;\n}\n\nint  bit_names(char *pLine){ \n   char *p1,*p2 = pLine, tmp[80];\n   unsigned sz=0, maskbitcount = 15;\n   while(1){\n      p1 = strchr(p2,'|');  if( p1==NULL ) break;\n      p1++;\n      p2 = strchr(p1,'|');  if( p2==NULL ) break;\n      sz = p2-p1;\n      tmp[sz] = 0;  \n      int k=0;\n      for(int j=0; j<sz;j++){  \n\t if( p1[j] > ' ') tmp[k++] = p1[j];\n      }\n      tmp[k]= 0; sz++;\n      NAME_T *pn = &names[idx_name++];\n      strcpy(&pn->A[0], &tmp[0]);\n      pn->bit3s = sz/3;\n      if( pn->bit3s < 16 ){\n\t for( int i=0; i<pn->bit3s; i++){\n\t    pn->mask |= 1 << maskbitcount--;\n\t }\n\t pn->data = header[idx_hdr] & pn->mask;\n\t unsigned m2 = pn->mask;\n\t while( (m2 & 1)==0 ){\n\t    m2>>=1; \n\t    pn->data >>= 1;\n\t }\n\t if( pn->mask == 0xf ) idx_hdr++;\n\n      }\n      else{\n\t pn->data = header[idx_hdr++];\n      }\n   }\n   return sz;\n}\n\nvoid dump_names(void){ \n   NAME_T *pn;\n   printf(\"-name-bits-mask-data-\\n\");\n   for( int i=0; i<MAX_NAMES; i++ ){\n      pn = &names[i];\n      if( pn->bit3s < 1 ) break;\n      printf(\"%10s %2d X%04x = %u\\n\",pn->A, pn->bit3s, pn->mask, pn->data);\n   }\n   puts(\"bye..\");\n}\n\nvoid make_test_hdr(void){\n   header[ID] = 1024;\n   header[QDCOUNT] = 12;\n   header[ANCOUNT] = 34;\n   header[NSCOUNT] = 56;\n   header[ARCOUNT] = 78;\n   \n   \n   \n   \n   header[BITS] = 0xB50A;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <array>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\nstruct FieldDetails {string_view Name; int NumBits;};\n\n\n\ntemplate <const char *T> consteval auto ParseDiagram()\n{  \n    \n    constexpr string_view rawArt(T);\n    constexpr auto firstBar = rawArt.find(\"|\");\n    constexpr auto lastBar = rawArt.find_last_of(\"|\");\n    constexpr auto art = rawArt.substr(firstBar, lastBar - firstBar);\n    static_assert(firstBar < lastBar, \"ASCII Table has no fields\");\n    \n    \n    constexpr auto numFields = \n        count(rawArt.begin(), rawArt.end(), '|') -\n        count(rawArt.begin(), rawArt.end(), '\\n') / 2;    \n    array<FieldDetails, numFields> fields;\n    \n    \n    bool isValidDiagram = true;\n    int startDiagramIndex = 0;\n    int totalBits = 0;\n    for(int i = 0; i < numFields; )\n    {\n        auto beginningBar = art.find(\"|\", startDiagramIndex);\n        auto endingBar = art.find(\"|\", beginningBar + 1);\n        auto field = art.substr(beginningBar + 1, endingBar - beginningBar - 1);\n        if(field.find(\"-\") == field.npos) \n        {\n            int numBits = (field.size() + 1) / 3;\n            auto nameStart = field.find_first_not_of(\" \");\n            auto nameEnd = field.find_last_not_of(\" \");\n            if (nameStart > nameEnd || nameStart == string_view::npos) \n            {\n                \n                isValidDiagram = false;\n                field = \"\"sv;\n            }\n            else\n            {\n                field = field.substr(nameStart, 1 + nameEnd - nameStart);\n            }\n            fields[i++] = FieldDetails {field, numBits};\n            totalBits += numBits;\n        }\n        startDiagramIndex = endingBar;\n    }\n    \n    int numRawBytes = isValidDiagram ? (totalBits - 1) / 8 + 1 : 0;\n    return make_pair(fields, numRawBytes);\n}\n\n\ntemplate <const char *T> auto Encode(auto inputValues)\n{\n    constexpr auto parsedDiagram = ParseDiagram<T>();\n    static_assert(parsedDiagram.second > 0, \"Invalid ASCII talble\");\n    array<unsigned char, parsedDiagram.second> data;\n\n    int startBit = 0;\n    int i = 0;\n    for(auto value : inputValues)\n    {\n        const auto &field = parsedDiagram.first[i++];\n        int remainingValueBits = field.NumBits;\n        while(remainingValueBits > 0)\n        {\n            \n            auto [fieldStartByte, fieldStartBit] = div(startBit, 8);\n            int unusedBits = 8 - fieldStartBit;\n            int numBitsToEncode = min({unusedBits, 8, field.NumBits});\n            int divisor = 1 << (remainingValueBits - numBitsToEncode);\n            unsigned char bitsToEncode = value / divisor;\n            data[fieldStartByte] <<= numBitsToEncode;\n            data[fieldStartByte] |= bitsToEncode;\n            value %= divisor;\n            startBit += numBitsToEncode;\n            remainingValueBits -= numBitsToEncode;\n        }\n    }\n    \n    return data;\n}\n\n\ntemplate <const char *T> void Decode(auto data)\n{\n    cout << \"Name      Bit Pattern\\n\";\n    cout << \"=======   ================\\n\";\n    constexpr auto parsedDiagram = ParseDiagram<T>();\n    static_assert(parsedDiagram.second > 0, \"Invalid ASCII talble\");\n\n    int startBit = 0;\n    for(const auto& field : parsedDiagram.first)\n    {\n        \n        auto [fieldStartByte, fieldStartBit] = div(startBit, 8);\n        unsigned char firstByte = data[fieldStartByte];\n        firstByte <<= fieldStartBit;\n        firstByte >>= fieldStartBit;\n        int64_t value = firstByte;\n        auto endBit = startBit + field.NumBits;\n        auto [fieldEndByte, fieldEndBit] = div(endBit, 8);\n        fieldEndByte = min(fieldEndByte, (int)(ssize(data) - 1));\n        for(int index = fieldStartByte + 1; index <= fieldEndByte; index++)\n        {\n            value <<= 8;\n            value += data[index];\n        }\n        value >>= fieldEndBit;\n        startBit = endBit;\n        \n        cout << field.Name << \n            string_view(\"        \", (7 - field.Name.size())) << \"   \" << \n            string_view(bitset<64>(value).to_string()).substr(64 - field.NumBits, 64) <<  \"\\n\";\n    }\n            \n}\n\nint main(void) \n{\n    static constexpr char art[] = R\"(\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+)\";\n    \n    \n    auto rawData = Encode<art> (initializer_list<int64_t> {\n        30791,\n        0, 15, 0, 1, 1, 1, 3, 15,\n        21654,\n        57646,\n        7153,\n        27044\n    });\n    \n    cout << \"Raw encoded data in hex:\\n\";\n    for (auto v : rawData) printf(\"%.2X\", v);\n    cout << \"\\n\\n\";\n    \n    cout << \"Decoded raw data:\\n\";\n    Decode<art>(rawData);\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 221,
    "input": "Translate Java to Go:import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CheckMachinFormula {\n    \n    private static String FILE_NAME = \"MachinFormula.txt\";\n    \n    public static void main(String[] args) {\n        try {\n            runPrivate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runPrivate() throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(FILE_NAME)));) {        \n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"=\");\n                System.out.println(tanLeft(split[0].trim()) + \" = \" + split[1].trim().replaceAll(\"\\\\s+\", \" \") + \" = \" + tanRight(split[1].trim()));\n            }\n        }\n    }\n    \n    private static String tanLeft(String formula) {\n        if ( formula.compareTo(\"pi/4\") == 0 ) {\n            return \"1\";\n        }\n        throw new RuntimeException(\"ERROR 104:  Unknown left side: \" + formula);\n    }\n    \n    private static final Pattern ARCTAN_PATTERN = Pattern.compile(\"(-{0,1}\\\\d+)\\\\*arctan\\\\((\\\\d+)/(\\\\d+)\\\\)\");\n    \n    private static Fraction tanRight(String formula) {\n        Matcher matcher = ARCTAN_PATTERN.matcher(formula);\n        List<Term> terms = new ArrayList<>();\n        while ( matcher.find() ) {\n            terms.add(new Term(Integer.parseInt(matcher.group(1)), new Fraction(matcher.group(2), matcher.group(3))));\n        }\n        return evaluateArctan(terms);\n    }\n    \n    private static Fraction evaluateArctan(List<Term> terms) {\n        if ( terms.size() == 1 ) {\n            Term term = terms.get(0);\n            return evaluateArctan(term.coefficient, term.fraction);\n        }\n        int size = terms.size();\n        List<Term> left = terms.subList(0, (size+1) / 2);\n        List<Term> right = terms.subList((size+1) / 2, size);\n        return arctanFormula(evaluateArctan(left), evaluateArctan(right));\n    }\n    \n    private static Fraction evaluateArctan(int coefficient, Fraction fraction) {\n        \n        if ( coefficient == 1 ) {\n            return fraction;\n        }\n        else if ( coefficient < 0 ) {\n            return evaluateArctan(-coefficient, fraction).negate();\n        }\n        if ( coefficient % 2 == 0 ) {\n            Fraction f = evaluateArctan(coefficient/2, fraction);\n            return arctanFormula(f, f);\n        }\n        Fraction a = evaluateArctan(coefficient/2, fraction);\n        Fraction b = evaluateArctan(coefficient - (coefficient/2), fraction);\n        return arctanFormula(a, b);\n    }\n    \n    private static Fraction arctanFormula(Fraction f1, Fraction f2) {\n        return f1.add(f2).divide(Fraction.ONE.subtract(f1.multiply(f2)));\n    }\n    \n    private static class Fraction {\n        \n        public static final Fraction ONE = new Fraction(\"1\", \"1\");\n        \n        private BigInteger numerator;\n        private BigInteger denominator;\n        \n        public Fraction(String num, String den) {\n            numerator = new BigInteger(num);\n            denominator = new BigInteger(den);\n        }\n\n        public Fraction(BigInteger num, BigInteger den) {\n            numerator = num;\n            denominator = den;\n        }\n\n        public Fraction negate() {\n            return new Fraction(numerator.negate(), denominator);\n        }\n        \n        public Fraction add(Fraction f) {\n            BigInteger gcd = denominator.gcd(f.denominator);\n            BigInteger first = numerator.multiply(f.denominator.divide(gcd));\n            BigInteger second = f.numerator.multiply(denominator.divide(gcd));\n            return new Fraction(first.add(second), denominator.multiply(f.denominator).divide(gcd));\n        }\n        \n        public Fraction subtract(Fraction f) {\n            return add(f.negate());\n        }\n        \n        public Fraction multiply(Fraction f) {\n            BigInteger num = numerator.multiply(f.numerator);\n            BigInteger den = denominator.multiply(f.denominator);\n            BigInteger gcd = num.gcd(den);\n            return new Fraction(num.divide(gcd), den.divide(gcd));\n        }\n\n        public Fraction divide(Fraction f) {\n            return multiply(new Fraction(f.denominator, f.numerator));\n        }\n        \n        @Override\n        public String toString() {\n            if ( denominator.compareTo(BigInteger.ONE) == 0 ) {\n                return numerator.toString();\n            }\n            return numerator + \" / \" + denominator;\n        }\n    }\n    \n    private static class Term {\n        \n        private int coefficient;\n        private Fraction fraction;\n        \n        public Term(int c, Fraction f) {\n            coefficient = c;\n            fraction = f;\n        }\n    }\n    \n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\ntype mTerm struct {\n    a, n, d int64\n}\n\nvar testCases = [][]mTerm{\n    {{1, 1, 2}, {1, 1, 3}},\n    {{2, 1, 3}, {1, 1, 7}},\n    {{4, 1, 5}, {-1, 1, 239}},\n    {{5, 1, 7}, {2, 3, 79}},\n    {{1, 1, 2}, {1, 1, 5}, {1, 1, 8}},\n    {{4, 1, 5}, {-1, 1, 70}, {1, 1, 99}},\n    {{5, 1, 7}, {4, 1, 53}, {2, 1, 4443}},\n    {{6, 1, 8}, {2, 1, 57}, {1, 1, 239}},\n    {{8, 1, 10}, {-1, 1, 239}, {-4, 1, 515}},\n    {{12, 1, 18}, {8, 1, 57}, {-5, 1, 239}},\n    {{16, 1, 21}, {3, 1, 239}, {4, 3, 1042}},\n    {{22, 1, 28}, {2, 1, 443}, {-5, 1, 1393}, {-10, 1, 11018}},\n    {{22, 1, 38}, {17, 7, 601}, {10, 7, 8149}},\n    {{44, 1, 57}, {7, 1, 239}, {-12, 1, 682}, {24, 1, 12943}},\n    {{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12943}},\n    {{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12944}},\n}\n\nfunc main() {\n    for _, m := range testCases {\n        fmt.Printf(\"tan %v = %v\\n\", m, tans(m))\n    }\n}\n\nvar one = big.NewRat(1, 1)\n\nfunc tans(m []mTerm) *big.Rat {\n    if len(m) == 1 {\n        return tanEval(m[0].a, big.NewRat(m[0].n, m[0].d))\n    }\n    half := len(m) / 2\n    a := tans(m[:half])\n    b := tans(m[half:])\n    r := new(big.Rat)\n    return r.Quo(new(big.Rat).Add(a, b), r.Sub(one, r.Mul(a, b)))\n}\n\nfunc tanEval(coef int64, f *big.Rat) *big.Rat {\n    if coef == 1 {\n        return f\n    }\n    if coef < 0 {\n        r := tanEval(-coef, f)\n        return r.Neg(r)\n    }\n    ca := coef / 2\n    cb := coef - ca\n    a := tanEval(ca, f)\n    b := tanEval(cb, f)\n    r := new(big.Rat)\n    return r.Quo(new(big.Rat).Add(a, b), r.Sub(one, r.Mul(a, b)))\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 222,
    "input": "Translate PHP to Python:<?php\n\n$conf = file_get_contents('parse-conf-file.txt');\n\n$conf = preg_replace('/^([a-z]+)/mi', '$1 =', $conf);\n\n\n\n\n\n$conf = preg_replace_callback(\n    '/^([a-z]+)\\s*=((?=.*\\,.*).*)$/mi',\n    function ($matches) {\n        $r = '';\n        foreach (explode(',', $matches[2]) AS $val) {\n            $r .= $matches[1] . '[] = ' . trim($val) . PHP_EOL;\n        }\n        return $r;\n    },\n    $conf\n);\n\n$conf = preg_replace('/^([a-z]+)\\s*=$/mi', '$1 = true', $conf);\n\n$ini = parse_ini_string($conf);\n\necho 'Full name       = ', $ini['FULLNAME'], PHP_EOL;\necho 'Favourite fruit = ', $ini['FAVOURITEFRUIT'], PHP_EOL;\necho 'Need spelling   = ', (empty($ini['NEEDSPEELING']) ? 'false' : 'true'), PHP_EOL;\necho 'Seeds removed   = ', (empty($ini['SEEDSREMOVED']) ? 'false' : 'true'), PHP_EOL;\necho 'Other family    = ', print_r($ini['OTHERFAMILY'], true), PHP_EOL;\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def readconf(fn):\n    ret = {}\n    with file(fn) as fp:\n        for line in fp:\n            \n            line = line.strip()\n            if not line or line.startswith('\n            \n            boolval = True\n            \n            if line.startswith(';'):\n                \n                line = line.lstrip(';')\n                \n                if len(line.split()) != 1: continue\n                boolval = False\n            \n            bits = line.split(None, 1)\n            if len(bits) == 1:\n                \n                k = bits[0]\n                v = boolval\n            else:\n                \n                k, v = bits\n            ret[k.lower()] = v\n    return ret\n\n\nif __name__ == '__main__':\n    import sys\n    conf = readconf(sys.argv[1])\n    for k, v in sorted(conf.items()):\n        print k, '=', v\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 223,
    "input": "Translate Java to Go:import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListRootedTrees {\n    private static final List<Long> TREE_LIST = new ArrayList<>();\n\n    private static final List<Integer> OFFSET = new ArrayList<>();\n\n    static {\n        for (int i = 0; i < 32; i++) {\n            if (i == 1) {\n                OFFSET.add(1);\n            } else {\n                OFFSET.add(0);\n            }\n        }\n    }\n\n    private static void append(long t) {\n        TREE_LIST.add(1 | (t << 1));\n    }\n\n    private static void show(long t, int l) {\n        while (l-- > 0) {\n            if (t % 2 == 1) {\n                System.out.print('(');\n            } else {\n                System.out.print(')');\n            }\n            t = t >> 1;\n        }\n    }\n\n    private static void listTrees(int n) {\n        for (int i = OFFSET.get(n); i < OFFSET.get(n + 1); i++) {\n            show(TREE_LIST.get(i), n * 2);\n            System.out.println();\n        }\n    }\n\n    private static void assemble(int n, long t, int sl, int pos, int rem) {\n        if (rem == 0) {\n            append(t);\n            return;\n        }\n\n        var pp = pos;\n        var ss = sl;\n\n        if (sl > rem) {\n            ss = rem;\n            pp = OFFSET.get(ss);\n        } else if (pp >= OFFSET.get(ss + 1)) {\n            ss--;\n            if (ss == 0) {\n                return;\n            }\n            pp = OFFSET.get(ss);\n        }\n\n        assemble(n, t << (2 * ss) | TREE_LIST.get(pp), ss, pp, rem - ss);\n        assemble(n, t, ss, pp + 1, rem);\n    }\n\n    private static void makeTrees(int n) {\n        if (OFFSET.get(n + 1) != 0) {\n            return;\n        }\n        if (n > 0) {\n            makeTrees(n - 1);\n        }\n        assemble(n, 0, n - 1, OFFSET.get(n - 1), n - 1);\n        OFFSET.set(n + 1, TREE_LIST.size());\n    }\n\n    private static void test(int n) {\n        if (n < 1 || n > 12) {\n            throw new IllegalArgumentException(\"Argument must be between 1 and 12\");\n        }\n\n        append(0);\n\n        makeTrees(n);\n        System.out.printf(\"Number of %d-trees: %d\\n\", n, OFFSET.get(n + 1) - OFFSET.get(n));\n        listTrees(n);\n    }\n\n    public static void main(String[] args) {\n        test(5);\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strconv\"\n)\n\ntype tree uint64\n\nvar (\n    list   []tree\n    offset = [32]uint{1: 1}\n)\n\nfunc add(t tree) {\n    list = append(list, 1|t<<1)\n}\n\nfunc show(t tree, l uint) {\n    for ; l > 0; t >>= 1 {\n        l--\n        var paren byte\n        if (t & 1) != 0 {\n            paren = '('\n        } else {\n            paren = ')'\n        }\n        fmt.Printf(\"%c\", paren)\n    }\n}\n\nfunc listTrees(n uint) {\n    for i := offset[n]; i < offset[n+1]; i++ {\n        show(list[i], n*2)\n        fmt.Println()\n    }\n}\n\n\n\nfunc assemble(n uint, t tree, sl, pos, rem uint) {\n    if rem == 0 {\n        add(t)\n        return\n    }\n\n    if sl > rem { \n        sl = rem\n        pos = offset[sl]\n    } else if pos >= offset[sl+1] {\n        \n        sl--\n        if sl == 0 {\n            return\n        }\n        pos = offset[sl]\n    }\n\n    assemble(n, t<<(2*sl)|list[pos], sl, pos, rem-sl)\n    assemble(n, t, sl, pos+1, rem)\n}\n\nfunc mktrees(n uint) {\n    if offset[n+1] > 0 {\n        return\n    }\n    if n > 0 {\n        mktrees(n - 1)\n    }\n\n    assemble(n, 0, n-1, offset[n-1], n-1)\n    offset[n+1] = uint(len(list))\n}\n\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatal(\"There must be exactly 1 command line argument\")\n    }\n    n, err := strconv.Atoi(os.Args[1])\n    if err != nil {\n        log.Fatal(\"Argument is not a valid number\")\n    }\n    if n <= 0 || n > 19 { \n        n = 5\n    }\n    \n    add(0)\n\n    mktrees(uint(n))\n    fmt.Fprintf(os.Stderr, \"Number of %d-trees: %d\\n\", n, offset[n+1]-offset[n])\n    listTrees(uint(n))\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 224,
    "input": "Translate C to Go:#include <stdio.h>\n\nint main() {\n    int i, gprev = 0;\n    int s[7] = {1, 2, 2, 3, 4, 4, 5};\n\n    \n    for (i = 0; i < 7; ++i) {\n\n        int curr = s[i];\n        int prev = 0;\n\n        if (i > 0 && curr == prev) printf(\"%d\\n\", i);\n        prev = curr;\n    }\n\n    \n    for (i = 0; i < 7; ++i) {\n        int curr = s[i];\n        if (i > 0 && curr == gprev) printf(\"%d\\n\", i);\n        gprev = curr;\n    }\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    s := []int{1, 2, 2, 3, 4, 4, 5}\n\n    \n    \n    for i := 0; i < len(s); i++ {\n        curr := s[i]\n        var prev int\n        if i > 0 && curr == prev {\n            fmt.Println(i)\n        }\n        prev = curr\n    }\n\n    \n    \n    var prev int\n    for i := 0; i < len(s); i++ {\n        curr := s[i]\n        if i > 0 && curr == prev {\n            fmt.Println(i)\n        }\n        prev = curr\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 225,
    "input": "Translate Python to Go:def reverse(n, base):\n    r = 0\n    while n > 0:\n        r = r*base + n%base\n        n = n//base\n    return r\n    \ndef palindrome(n, base):\n    return n == reverse(n, base)\n    \ncnt = 0\nfor i in range(25000):\n    if all(palindrome(i, base) for base in (2,4,16)):\n        cnt += 1\n        print(\"{:5}\".format(i), end=\" \\n\"[cnt % 12 == 0])\n\nprint()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n    \"strconv\"\n)\n\nfunc reverse(s string) string {\n    chars := []rune(s)\n    for i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {\n        chars[i], chars[j] = chars[j], chars[i]\n    }\n    return string(chars)\n}\n\nfunc main() {\n    fmt.Println(\"Numbers under 25,000 in base 10 which are palindromic in bases 2, 4 and 16:\")\n    var numbers []int\n    for i := int64(0); i < 25000; i++ {\n        b2 := strconv.FormatInt(i, 2)\n        if b2 == reverse(b2) {\n            b4 := strconv.FormatInt(i, 4)\n            if b4 == reverse(b4) {\n                b16 := strconv.FormatInt(i, 16)\n                if b16 == reverse(b16) {\n                    numbers = append(numbers, int(i))\n                }\n            }\n        }\n    }\n    for i, n := range numbers {\n        fmt.Printf(\"%6s \", rcu.Commatize(n))\n        if (i+1)%10 == 0 {\n            fmt.Println()\n        }\n    }\n    fmt.Println(\"\\n\\nFound\", len(numbers), \"such numbers.\")\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 226,
    "input": "Translate Python to C#:def calcPi():\n    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n    while True:\n        if 4*q+r-t < n*t:\n            yield n\n            nr = 10*(r-n*t)\n            n  = ((10*(3*q+r))//t)-10*n\n            q  *= 10\n            r  = nr\n        else:\n            nr = (2*q+r)*l\n            nn = (q*(7*k)+2+(r*l))//(t*l)\n            q  *= k\n            t  *= l\n            l  += 2\n            k += 1\n            n  = nn\n            r  = nr\n\nimport sys\npi_digits = calcPi()\ni = 0\nfor d in pi_digits:\n    sys.stdout.write(str(d))\n    i += 1\n    if i == 40: print(\"\"); i = 0\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Numerics;\n\nnamespace PiCalc {\n    internal class Program {\n        private readonly BigInteger FOUR = new BigInteger(4);\n        private readonly BigInteger SEVEN = new BigInteger(7);\n        private readonly BigInteger TEN = new BigInteger(10);\n        private readonly BigInteger THREE = new BigInteger(3);\n        private readonly BigInteger TWO = new BigInteger(2);\n\n        private BigInteger k = BigInteger.One;\n        private BigInteger l = new BigInteger(3);\n        private BigInteger n = new BigInteger(3);\n        private BigInteger q = BigInteger.One;\n        private BigInteger r = BigInteger.Zero;\n        private BigInteger t = BigInteger.One;\n\n        public void CalcPiDigits() {\n            BigInteger nn, nr;\n            bool first = true;\n            while (true) {\n                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {\n                    Console.Write(n);\n                    if (first) {\n                        Console.Write(\".\");\n                        first = false;\n                    }\n                    nr = TEN*(r - (n*t));\n                    n = TEN*(THREE*q + r)/t - (TEN*n);\n                    q *= TEN;\n                    r = nr;\n                } else {\n                    nr = (TWO*q + r)*l;\n                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);\n                    q *= k;\n                    t *= l;\n                    l += TWO;\n                    k += BigInteger.One;\n                    n = nn;\n                    r = nr;\n                }\n            }\n        }\n\n        private static void Main(string[] args) {\n            new Program().CalcPiDigits();\n        }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 227,
    "input": "Translate Java to Python:import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 228,
    "input": "Translate C to Java:#include <stdio.h>\n\nint main()\n{\n\tunsigned int i = 0;\n\twhile (++i) printf(\"%u\\n\", i);\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 229,
    "input": "Translate C to Python:#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define COUNTOF(a) (sizeof(a)/sizeof(a[0]))\n\nvoid fatal(const char* message) {\n    fprintf(stderr, \"%s\\n\", message);\n    exit(1);\n}\n\nvoid* xmalloc(size_t n) {\n    void* ptr = malloc(n);\n    if (ptr == NULL)\n        fatal(\"Out of memory\");\n    return ptr;\n}\n\nint icompare(const void* p1, const void* p2) {\n    const int* ip1 = p1;\n    const int* ip2 = p2;\n    return (*ip1 < *ip2) ? -1 : ((*ip1 > *ip2) ? 1 : 0);\n}\n\nsize_t unique(int* array, size_t len) {\n    size_t out_index = 0;\n    int prev;\n    for (size_t i = 0; i < len; ++i) {\n        if (i == 0 || prev != array[i])\n            array[out_index++] = array[i];\n        prev = array[i];\n    }\n    return out_index;\n}\n\nint* common_sorted_list(const int** arrays, const size_t* lengths, size_t count, size_t* size) {\n    size_t len = 0;\n    for (size_t i = 0; i < count; ++i)\n        len += lengths[i];\n    int* array = xmalloc(len * sizeof(int));\n    for (size_t i = 0, offset = 0; i < count; ++i) {\n        memcpy(array + offset, arrays[i], lengths[i] * sizeof(int));\n        offset += lengths[i];\n    }\n    qsort(array, len, sizeof(int), icompare);\n    *size = unique(array, len);\n    return array;\n}\n\nvoid print(const int* array, size_t len) {\n    printf(\"[\");\n    for (size_t i = 0; i < len; ++i) {\n        if (i > 0)\n            printf(\", \");\n        printf(\"%d\", array[i]);\n    }\n    printf(\"]\\n\");\n}\n\nint main() {\n    const int a[] = {5, 1, 3, 8, 9, 4, 8, 7};\n    const int b[] = {3, 5, 9, 8, 4};\n    const int c[] = {1, 3, 7, 9};\n    size_t len = 0;\n    const int* arrays[] = {a, b, c};\n    size_t lengths[] = {COUNTOF(a), COUNTOF(b), COUNTOF(c)};\n    int* sorted = common_sorted_list(arrays, lengths, COUNTOF(arrays), &len);\n    print(sorted, len);\n    free(sorted);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\nfrom itertools import chain\n\n\n\n\ndef main():\n    \n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n\n\n\n\ndef concat(xs):\n    \n    return list(chain(*xs))\n\n\n\ndef nub(xs):\n    \n    return list(dict.fromkeys(xs))\n\n\n\nif __name__ == '__main__':\n    main()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 230,
    "input": "Translate C to Go:\n\n\n\n\n\nINT PUTCHAR(INT);\n\nINT WIDTH = 80, YEAR = 1969;\nINT COLS, LEAD, GAP;\n \nCONST CHAR *WDAYS[] = { \"SU\", \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\" };\nSTRUCT MONTHS {\n    CONST CHAR *NAME;\n    INT DAYS, START_WDAY, AT;\n} MONTHS[12] = {\n    { \"JANUARY\",    31, 0, 0 },\n    { \"FEBRUARY\",    28, 0, 0 },\n    { \"MARCH\",    31, 0, 0 },\n    { \"APRIL\",    30, 0, 0 },\n    { \"MAY\",    31, 0, 0 },\n    { \"JUNE\",    30, 0, 0 },\n    { \"JULY\",    31, 0, 0 },\n    { \"AUGUST\",    31, 0, 0 },\n    { \"SEPTEMBER\",    30, 0, 0 },\n    { \"OCTOBER\",    31, 0, 0 },\n    { \"NOVEMBER\",    30, 0, 0 },\n    { \"DECEMBER\",    31, 0, 0 }\n};\n \nVOID SPACE(INT N) { WHILE (N-- > 0) PUTCHAR(' '); }\nVOID PRINT(CONST CHAR * S){ WHILE (*S != '\\0') { PUTCHAR(*S++); } }\nINT  STRLEN(CONST CHAR * S)\n{\n   INT L = 0;\n   WHILE (*S++ != '\\0') { L ++; };\nRETURN L;\n}\nINT ATOI(CONST CHAR * S)\n{\n    INT I = 0;\n    INT SIGN = 1;\n    CHAR C;\n    WHILE ((C = *S++) != '\\0') {\n        IF (C == '-')\n            SIGN *= -1;\n        ELSE {\n            I *= 10;\n            I += (C - '0');\n        }\n    }\nRETURN I * SIGN;\n}\n\nVOID INIT_MONTHS(VOID)\n{\n    INT I;\n \n    IF ((!(YEAR % 4) && (YEAR % 100)) || !(YEAR % 400))\n        MONTHS[1].DAYS = 29;\n \n    YEAR--;\n    MONTHS[0].START_WDAY\n        = (YEAR * 365 + YEAR/4 - YEAR/100 + YEAR/400 + 1) % 7;\n \n    FOR (I = 1; I < 12; I++)\n        MONTHS[I].START_WDAY =\n            (MONTHS[I-1].START_WDAY + MONTHS[I-1].DAYS) % 7;\n \n    COLS = (WIDTH + 2) / 22;\n    WHILE (12 % COLS) COLS--;\n    GAP = COLS - 1 ? (WIDTH - 20 * COLS) / (COLS - 1) : 0;\n    IF (GAP > 4) GAP = 4;\n    LEAD = (WIDTH - (20 + GAP) * COLS + GAP + 1) / 2;\n        YEAR++;\n}\n \nVOID PRINT_ROW(INT ROW)\n{\n    INT C, I, FROM = ROW * COLS, TO = FROM + COLS;\n    SPACE(LEAD);\n    FOR (C = FROM; C < TO; C++) {\n        I = STRLEN(MONTHS[C].NAME);\n        SPACE((20 - I)/2);\n        PRINT(MONTHS[C].NAME);\n        SPACE(20 - I - (20 - I)/2 + ((C == TO - 1) ? 0 : GAP));\n    }\n    PUTCHAR('\\012');\n \n    SPACE(LEAD);\n    FOR (C = FROM; C < TO; C++) {\n        FOR (I = 0; I < 7; I++) {\n            PRINT(WDAYS[I]);\n            PRINT(I == 6 ? \"\" : \" \");\n        }\n        IF (C < TO - 1) SPACE(GAP);\n        ELSE PUTCHAR('\\012');\n    }\n \n    WHILE (1) {\n        FOR (C = FROM; C < TO; C++)\n            IF (MONTHS[C].AT < MONTHS[C].DAYS) BREAK;\n        IF (C == TO) BREAK;\n \n        SPACE(LEAD);\n        FOR (C = FROM; C < TO; C++) {\n            FOR (I = 0; I < MONTHS[C].START_WDAY; I++) SPACE(3);\n            WHILE(I++ < 7 && MONTHS[C].AT < MONTHS[C].DAYS) {\n                INT MM = ++MONTHS[C].AT;\n                PUTCHAR((MM < 10) ? ' ' : '0' + (MM /10));\n                PUTCHAR('0' + (MM %10));\n                IF (I < 7 || C < TO - 1) PUTCHAR(' ');\n            }\n            WHILE (I++ <= 7 && C < TO - 1) SPACE(3);\n            IF (C < TO - 1) SPACE(GAP - 1);\n            MONTHS[C].START_WDAY = 0;\n        }\n        PUTCHAR('\\012');\n    }\n    PUTCHAR('\\012');\n}\n \nVOID PRINT_YEAR(VOID)\n{\n    INT Y = YEAR;\n    INT ROW;\n    CHAR BUF[32];\n    CHAR * B = &(BUF[31]);\n    *B-- = '\\0';\n    DO {\n        *B-- = '0' + (Y % 10);\n        Y /= 10;\n    } WHILE (Y > 0);\n    B++;\n    SPACE((WIDTH - STRLEN(B)) / 2);\n    PRINT(B);PUTCHAR('\\012');PUTCHAR('\\012');\n    FOR (ROW = 0; ROW * COLS < 12; ROW++)\n        PRINT_ROW(ROW);\n}\n \nINT MAIN(INT C, CHAR **V)\n{\n    INT I, YEAR_SET = 0, RESULT = 0;\n    FOR (I = 1; I < C && RESULT == 0; I++) {\n        IF (V[I][0] == '-' && V[I][1] == 'W' && V[I][2] == '\\0') {\n            IF (++I == C || (WIDTH = ATOI(V[I])) < 20)\n                RESULT = 1;\n        } ELSE IF (!YEAR_SET) {\n            YEAR = ATOI(V[I]);\n            IF (YEAR <= 0)\n                YEAR = 1969;\n            YEAR_SET = 1;\n        } ELSE\n            RESULT = 1;\n    }\n \n    IF (RESULT == 0) {\n        INIT_MONTHS();\n        PRINT_YEAR();\n    } ELSE {\n        PRINT(\"BAD ARGS\\012USAGE: \");\n        PRINT(V[0]);\n        PRINT(\" YEAR [-W WIDTH (>= 20)]\\012\");\n    }\nRETURN RESULT;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "PACKAGE MAIN\n \nIMPORT (\n    \"FMT\"\n    \"TIME\"\n)\n \nCONST PAGEWIDTH = 80\n \nFUNC MAIN() {\n    PRINTCAL(1969)\n}\n \nFUNC PRINTCAL(YEAR INT) {\n    THISDATE := TIME.DATE(YEAR, 1, 1, 1, 1, 1, 1, TIME.UTC)\n    VAR (\n        DAYARR                  [12][7][6]INT \n        MONTH, LASTMONTH        TIME.MONTH\n        WEEKINMONTH, DAYINMONTH INT\n    )\n    FOR THISDATE.YEAR() == YEAR {\n        IF MONTH = THISDATE.MONTH(); MONTH != LASTMONTH {\n            WEEKINMONTH = 0\n            DAYINMONTH = 1\n        }\n        WEEKDAY := THISDATE.WEEKDAY()\n        IF WEEKDAY == 0 && DAYINMONTH > 1 {\n            WEEKINMONTH++\n        }\n        DAYARR[INT(MONTH)-1][WEEKDAY][WEEKINMONTH] = THISDATE.DAY()\n        LASTMONTH = MONTH\n        DAYINMONTH++\n        THISDATE = THISDATE.ADD(TIME.HOUR * 24)\n    }\n    CENTRE := FMT.SPRINTF(\"%D\", PAGEWIDTH/2)\n    FMT.PRINTF(\"%\"+CENTRE+\"S\\N\\N\", \"[SNOOPY]\")\n    CENTRE = FMT.SPRINTF(\"%D\", PAGEWIDTH/2-2)\n    FMT.PRINTF(\"%\"+CENTRE+\"D\\N\\N\", YEAR)\n    MONTHS := [12]STRING{\n        \" JANUARY \", \" FEBRUARY\", \"  MARCH  \", \"  APRIL  \",\n        \"   MAY   \", \"   JUNE  \", \"   JULY  \", \"  AUGUST \",\n        \"SEPTEMBER\", \" OCTOBER \", \" NOVEMBER\", \" DECEMBER\"}\n    DAYS := [7]STRING{\"SU\", \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\"}\n    FOR QTR := 0; QTR < 4; QTR++ {\n        FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ { \n            FMT.PRINTF(\"      %S           \", MONTHS[QTR*3+MONTHINQTR])\n        }\n        FMT.PRINTLN()\n        FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ { \n            FOR DAY := 0; DAY < 7; DAY++ {\n                FMT.PRINTF(\" %S\", DAYS[DAY])\n            }\n            FMT.PRINTF(\"     \")\n        }\n        FMT.PRINTLN()\n        FOR WEEKINMONTH = 0; WEEKINMONTH < 6; WEEKINMONTH++ {\n            FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ {\n                FOR DAY := 0; DAY < 7; DAY++ {\n                    IF DAYARR[QTR*3+MONTHINQTR][DAY][WEEKINMONTH] == 0 {\n                        FMT.PRINTF(\"   \")\n                    } ELSE {\n                        FMT.PRINTF(\"%3D\", DAYARR[QTR*3+MONTHINQTR][DAY][WEEKINMONTH])\n                    }\n                }\n                FMT.PRINTF(\"     \")\n            }\n            FMT.PRINTLN()\n        }\n        FMT.PRINTLN()\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 231,
    "input": "Translate C++ to C#:#include <iostream>\n#include <sstream>\n#include <iomanip>\nusing namespace std;\n\nclass magicSqr\n{\npublic: \n    magicSqr( int d ) {\n        while( d % 4 > 0 ) { d++; }\n        sz = d;\n        sqr = new int[sz * sz];\n        fillSqr();\n    }\n    ~magicSqr() { delete [] sqr; }\n\n    void display() const {\n        cout << \"Doubly Even Magic Square: \" << sz << \" x \" << sz << \"\\n\";\n        cout << \"It's Magic Sum is: \" << magicNumber() << \"\\n\\n\";\n        ostringstream cvr; cvr << sz * sz;\n        int l = cvr.str().size();\n \n        for( int y = 0; y < sz; y++ ) {\n            int yy = y * sz;\n            for( int x = 0; x < sz; x++ ) {\n                cout << setw( l + 2 ) << sqr[yy + x];\n            }\n            cout << \"\\n\";\n        }\n        cout << \"\\n\\n\";\n    }\nprivate:\n    void fillSqr() {\n        static const bool tempAll[4][4] = {{ 1, 0, 0, 1 }, { 0, 1, 1, 0 }, { 0, 1, 1, 0 }, { 1, 0, 0, 1 } };\n        int i = 0;\n        for( int curRow = 0; curRow < sz; curRow++ ) {\n            for( int curCol = 0; curCol < sz; curCol++ ) {\n                sqr[curCol + sz * curRow] = tempAll[curRow % 4][curCol % 4] ? i + 1 : sz * sz - i;\n                i++;\n            }\n        }\n    }\n    int magicNumber() const { return sz * ( ( sz * sz ) + 1 ) / 2; }\n \n    int* sqr;\n    int sz;\n};\n \nint main( int argc, char* argv[] ) {\n    magicSqr s( 8 );\n    s.display();\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\n\nnamespace MagicSquareDoublyEven\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = 8;\n            var result = MagicSquareDoublyEven(n);\n            for (int i = 0; i < result.GetLength(0); i++)\n            {\n                for (int j = 0; j < result.GetLength(1); j++)\n                    Console.Write(\"{0,2} \", result[i, j]);\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMagic constant: {0} \", (n * n + 1) * n / 2);\n            Console.ReadLine();\n        }\n\n        private static int[,] MagicSquareDoublyEven(int n)\n        {\n            if (n < 4 || n % 4 != 0)\n                throw new ArgumentException(\"base must be a positive \"\n                        + \"multiple of 4\");\n\n            \n            int bits = 0b1001_0110_0110_1001;\n            int size = n * n;\n            int mult = n / 4;  \n\n            int[,] result = new int[n, n];\n\n            for (int r = 0, i = 0; r < n; r++)\n            {\n                for (int c = 0; c < n; c++, i++)\n                {\n                    int bitPos = c / mult + (r / mult) * 4;\n                    result[r, c] = (bits & (1 << bitPos)) != 0 ? i + 1 : size - i;\n                }\n            }\n            return result;\n        }\n    }\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 232,
    "input": "Translate C++ to Go:#include <cstdio>\n#include <cstdlib>\n\nclass Point {\nprotected:\n    int x, y;\n\npublic:\n    Point(int x0 = 0, int y0 = 0) : x(x0), y(y0) {}\n    Point(const Point &p) : x(p.x), y(p.y) {}\n    virtual ~Point() {}\n    const Point& operator=(const Point &p) {\n        if (this != &p) {\n            x = p.x;\n            y = p.y;\n        }\n        return *this;\n    }\n    int getX() { return x; }\n    int getY() { return y; }\n    void setX(int x0) { x = x0; }\n    void setY(int y0) { y = y0; }\n    virtual void print() { printf(\"Point\\n\"); }\n};\n\nclass Circle: public Point {\nprivate:\n    int r;\n\npublic:\n    Circle(Point p, int r0 = 0) : Point(p), r(r0) {}\n    Circle(int x0 = 0, int y0 = 0, int r0 = 0) : Point(x0, y0), r(r0) {}\n    virtual ~Circle() {}\n    const Circle& operator=(const Circle &c) {\n        if (this != &c) {\n            x = c.x;\n            y = c.y;\n            r = c.r;\n        }\n        return *this;\n    }\n    int getR() { return r; }\n    void setR(int r0) { r = r0; }\n    virtual void print() { printf(\"Circle\\n\"); }\n};\n\nint main() {\n    Point *p = new Point();\n    Point *c = new Circle();\n    p->print();\n    c->print();\n    delete p;\n    delete c;\n\n    return EXIT_SUCCESS;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\ntype point struct {\n    x, y float64\n}\n\ntype circle struct {\n    x, y, r float64\n}\n\ntype printer interface {\n    print()\n}\n\nfunc (p *point) print() {\n    fmt.Println(p.x, p.y)\n}\n\nfunc (c *circle) print() {\n    fmt.Println(c.x, c.y, c.r)\n}\n\nfunc main() {\n    var i printer            \n    i = newPoint(3, 4)       \n    i.print()                \n    i = newCircle(5, 12, 13) \n    i.print()                \n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (p *point) getX() float64  { return p.x }\nfunc (p *point) getY() float64  { return p.y }\nfunc (p *point) setX(v float64) { p.x = v }\nfunc (p *point) setY(v float64) { p.y = v }\n\nfunc (c *circle) getX() float64  { return c.x }\nfunc (c *circle) getY() float64  { return c.y }\nfunc (c *circle) getR() float64  { return c.r }\nfunc (c *circle) setX(v float64) { c.x = v }\nfunc (c *circle) setY(v float64) { c.y = v }\nfunc (c *circle) setR(v float64) { c.r = v }\n\n\n\nfunc (p *point) clone() *point   { r := *p; return &r }\nfunc (c *circle) clone() *circle { r := *c; return &r }\n\n\nfunc (p *point) set(q *point)   { *p = *q }\nfunc (c *circle) set(d *circle) { *c = *d }\n\n\n\n\n\n\n\n\n\n\nfunc newPoint(x, y float64) *point {\n    return &point{x, y}\n}\nfunc newCircle(x, y, r float64) *circle {\n    return &circle{x, y, r}\n}\n\n\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 233,
    "input": "Translate C to Java:#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <expat.h>\n#include <pcre.h>\n\n#ifdef XML_LARGE_SIZE\n#  define XML_FMT_INT_MOD \"ll\"\n#else\n#  define XML_FMT_INT_MOD \"l\"\n#endif\n\n#ifdef XML_UNICODE_WCHAR_T\n#  define XML_FMT_STR \"ls\"\n#else\n#  define XML_FMT_STR \"s\"\n#endif\n\nvoid reset_char_data_buffer();\nvoid process_char_data_buffer();\n\nstatic bool last_tag_is_title;\nstatic bool last_tag_is_text;\n\nstatic pcre *reCompiled;\nstatic pcre_extra *pcreExtra;\n\n\nvoid start_element(void *data, const char *element, const char **attribute) {\n    process_char_data_buffer();\n    reset_char_data_buffer();\n\n    if (strcmp(\"title\", element) == 0) {\n        last_tag_is_title = true;\n    }\n    if (strcmp(\"text\", element) == 0) {\n        last_tag_is_text = true;\n    }\n}\n\nvoid end_element(void *data, const char *el) {\n    process_char_data_buffer();\n    reset_char_data_buffer();\n}\n\n\n#define TITLE_BUF_SIZE (1024 * 8)\n\nstatic char char_data_buffer[1024 * 64 * 8];\nstatic char title_buffer[TITLE_BUF_SIZE];\nstatic size_t offs;\nstatic bool overflow;\n\n\nvoid reset_char_data_buffer(void) {\n    offs = 0;\n    overflow = false;\n}\n\n\nvoid char_data(void *userData, const XML_Char *s, int len) {\n    if (!overflow) {\n        if (len + offs >= sizeof(char_data_buffer)) {\n            overflow = true;\n            fprintf(stderr, \"Warning: buffer overflow\\n\");\n            fflush(stderr);\n        } else {\n            memcpy(char_data_buffer + offs, s, len);\n            offs += len;\n        }\n    }\n}\n\nvoid try_match();\n\n\nvoid process_char_data_buffer(void) {\n    if (offs > 0) {\n        char_data_buffer[offs] = '\\0';\n\n        if (last_tag_is_title) {\n            unsigned int n = (offs+1 > TITLE_BUF_SIZE) ? TITLE_BUF_SIZE : (offs+1);\n            memcpy(title_buffer, char_data_buffer, n);\n            last_tag_is_title = false;\n        }\n        if (last_tag_is_text) {\n            try_match();\n            last_tag_is_text = false;\n        }\n    }\n}\n\nvoid try_match()\n{\n    int subStrVec[80];\n    int subStrVecLen;\n    int pcreExecRet;\n    subStrVecLen = sizeof(subStrVec) / sizeof(int);\n\n    pcreExecRet = pcre_exec(\n            reCompiled, pcreExtra,\n            char_data_buffer, strlen(char_data_buffer),\n            0, 0,\n            subStrVec, subStrVecLen);\n\n    if (pcreExecRet < 0) {\n        switch (pcreExecRet) {\n            case PCRE_ERROR_NOMATCH      : break;\n            case PCRE_ERROR_NULL         : fprintf(stderr, \"Something was null\\n\");                      break;\n            case PCRE_ERROR_BADOPTION    : fprintf(stderr, \"A bad option was passed\\n\");                 break;\n            case PCRE_ERROR_BADMAGIC     : fprintf(stderr, \"Magic number bad (compiled re corrupt?)\\n\"); break;\n            case PCRE_ERROR_UNKNOWN_NODE : fprintf(stderr, \"Something kooky in the compiled re\\n\");      break;\n            case PCRE_ERROR_NOMEMORY     : fprintf(stderr, \"Ran out of memory\\n\");                       break;\n            default                      : fprintf(stderr, \"Unknown error\\n\");                           break;\n        }\n    } else {\n        puts(title_buffer);  \n    }\n}\n\n\n#define BUF_SIZE 1024\n\nint main(int argc, char *argv[])\n{\n    char buffer[BUF_SIZE];\n    int n;\n\n    const char *pcreErrorStr;\n    int pcreErrorOffset;\n    char *aStrRegex;\n    char **aLineToMatch;\n\n    \n\n    aStrRegex = \"(.*)(==French==)(.*)\";  \n\n    reCompiled = pcre_compile(aStrRegex, PCRE_DOTALL | PCRE_UTF8, &pcreErrorStr, &pcreErrorOffset, NULL);\n    if (reCompiled == NULL) {\n        fprintf(stderr, \"ERROR: Could not compile regex '%s': %s\\n\", aStrRegex, pcreErrorStr);\n        exit(1);\n    }\n\n    pcreExtra = pcre_study(reCompiled, 0, &pcreErrorStr);\n    if (pcreErrorStr != NULL) {\n        fprintf(stderr, \"ERROR: Could not study regex '%s': %s\\n\", aStrRegex, pcreErrorStr);\n        exit(1);\n    }\n\n    \n\n    XML_Parser parser = XML_ParserCreate(NULL);\n\n    XML_SetElementHandler(parser, start_element, end_element);\n    XML_SetCharacterDataHandler(parser, char_data);\n\n    reset_char_data_buffer();\n\n    while (1) {\n        int done;\n        int len;\n\n        len = (int)fread(buffer, 1, BUF_SIZE, stdin);\n        if (ferror(stdin)) {\n            fprintf(stderr, \"Read error\\n\");\n            exit(1);\n        }\n        done = feof(stdin);\n\n        if (XML_Parse(parser, buffer, len, done) == XML_STATUS_ERROR) {\n            fprintf(stderr,\n                \"Parse error at line %\" XML_FMT_INT_MOD \"u:\\n%\" XML_FMT_STR \"\\n\",\n                XML_GetCurrentLineNumber(parser),\n                XML_ErrorString(XML_GetErrorCode(parser)));\n            exit(1);\n        }\n\n        if (done) break;\n    }\n\n    XML_ParserFree(parser);\n\n    pcre_free(reCompiled);\n\n    if (pcreExtra != NULL) {\n#ifdef PCRE_CONFIG_JIT\n        pcre_free_study(pcreExtra);\n#else\n        pcre_free(pcreExtra);\n#endif\n    }\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import org.xml.sax.*;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\nclass MyHandler extends DefaultHandler {\n    private static final String TITLE = \"title\";\n    private static final String TEXT = \"text\";\n\n    private String lastTag = \"\";\n    private String title = \"\";\n\n    @Override\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        String regex = \".*==French==.*\";\n        Pattern pat = Pattern.compile(regex, Pattern.DOTALL);\n\n        switch (lastTag) {\n            case TITLE:\n                title = new String(ch, start, length);\n                break;\n            case TEXT:\n                String text = new String(ch, start, length);\n                Matcher mat = pat.matcher(text);\n                if (mat.matches()) {\n                    System.out.println(title);\n                }\n                break;\n        }\n    }\n\n    @Override\n    public void startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException {\n        lastTag = qName;\n    }\n\n    @Override\n    public void endElement(String uri, String localName, String qName) throws SAXException {\n        lastTag = \"\";\n    }\n}\n\npublic class WiktoWords {\n    public static void main(java.lang.String[] args) {\n        try {\n            SAXParserFactory spFactory = SAXParserFactory.newInstance();\n            SAXParser saxParser = spFactory.newSAXParser();\n            MyHandler handler = new MyHandler();\n            saxParser.parse(new InputSource(System.in), handler);\n        } catch(Exception e) {\n            System.exit(1);\n        }\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 234,
    "input": "Translate C to Go:#include<stdio.h>\n#include<stdlib.h>\n\nint isprime( int p ) {\n    int i;\n    if(p==2) return 1;\n    if(!(p%2)) return 0;\n    for(i=3; i*i<=p; i+=2) {\n       if(!(p%i)) return 0;\n    }\n    return 1;\n}\n\nint main( void ) {\n   int s=0, p, i=1;\n   for(p=2;p<=999;p++) {\n       if(isprime(p)) {\n           if(i%2) {\n               s+=p;\n               if(isprime(s)) printf( \"%d       %d       %d\\n\", i, p, s );\n           }\n           i+=1;\n       }\n   }\n   return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nfunc main() {\n    primes := rcu.Primes(999)\n    sum := 0\n    fmt.Println(\" i   p[i]  Σp[i]\")\n    fmt.Println(\"----------------\")\n    for i := 0; i < len(primes); i += 2 {\n        sum += primes[i]\n        if rcu.IsPrime(sum) {\n            fmt.Printf(\"%3d  %3d  %6s\\n\", i+1, primes[i], rcu.Commatize(sum))\n        }\n    }\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 235,
    "input": "Translate C# to Go:using System;\nusing System.IO;\nusing System.Security.Cryptography;\n\nnamespace DES {\n    class Program {\n        \n        static string ByteArrayToString(byte[] ba) {\n            return BitConverter.ToString(ba).Replace(\"-\", \"\");\n        }\n\n        \n        \n        static byte[] Encrypt(byte[] messageBytes, byte[] passwordBytes) {\n            byte[] iv = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n            \n            DESCryptoServiceProvider provider = new DESCryptoServiceProvider();\n            ICryptoTransform transform = provider.CreateEncryptor(passwordBytes, iv);\n            CryptoStreamMode mode = CryptoStreamMode.Write;\n\n            \n            MemoryStream memStream = new MemoryStream();\n            CryptoStream cryptoStream = new CryptoStream(memStream, transform, mode);\n            cryptoStream.Write(messageBytes, 0, messageBytes.Length);\n            cryptoStream.FlushFinalBlock();\n\n            \n            byte[] encryptedMessageBytes = new byte[memStream.Length];\n            memStream.Position = 0;\n            memStream.Read(encryptedMessageBytes, 0, encryptedMessageBytes.Length);\n\n            return encryptedMessageBytes;\n        }\n\n        \n        \n        static byte[] Decrypt(byte[] encryptedMessageBytes, byte[] passwordBytes) {\n            byte[] iv = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n            \n            DESCryptoServiceProvider provider = new DESCryptoServiceProvider();\n            ICryptoTransform transform = provider.CreateDecryptor(passwordBytes, iv);\n            CryptoStreamMode mode = CryptoStreamMode.Write;\n\n            \n            MemoryStream memStream = new MemoryStream();\n            CryptoStream cryptoStream = new CryptoStream(memStream, transform, mode);\n            cryptoStream.Write(encryptedMessageBytes, 0, encryptedMessageBytes.Length);\n            cryptoStream.FlushFinalBlock();\n\n            \n            byte[] decryptedMessageBytes = new byte[memStream.Length];\n            memStream.Position = 0;\n            memStream.Read(decryptedMessageBytes, 0, decryptedMessageBytes.Length);\n\n            return decryptedMessageBytes;\n        }\n\n        static void Main(string[] args) {\n            byte[] keyBytes = new byte[] { 0x0e, 0x32, 0x92, 0x32, 0xea, 0x6d, 0x0d, 0x73 };\n            byte[] plainBytes = new byte[] { 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87 };\n\n            byte[] encStr = Encrypt(plainBytes, keyBytes);\n            Console.WriteLine(\"Encoded: {0}\", ByteArrayToString(encStr));\n\n            byte[] decBytes = Decrypt(encStr, keyBytes);\n            Console.WriteLine(\"Decoded: {0}\", ByteArrayToString(decBytes));\n        }\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"crypto/des\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"log\"\n)\n\nfunc main() {\n    key, err := hex.DecodeString(\"0e329232ea6d0d73\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    c, err := des.NewCipher(key)\n    if err != nil {\n        log.Fatal(err)\n    }\n    src, err := hex.DecodeString(\"8787878787878787\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    dst := make([]byte, des.BlockSize)\n    c.Encrypt(dst, src)\n    fmt.Printf(\"%x\\n\", dst)\n}\n",
    "input_language": "C#",
    "output_language": "Go"
  },
  {
    "id": 236,
    "input": "Translate C to Go:#include <gmp.h>\n#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n\tmpz_t a;\n\tmpz_init_set_ui(a, 5);\n\tmpz_pow_ui(a, a, 1 << 18); \n\n\tint len = mpz_sizeinbase(a, 10);\n\tprintf(\"GMP says size is: %d\\n\", len);\n\n\t\n\tchar *s = mpz_get_str(0, 10, a);\n\tprintf(\"size really is %d\\n\", len = strlen(s));\n\tprintf(\"Digits: %.20s...%s\\n\", s, s + len - 20);\n\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\tx := big.NewInt(2)\n\tx = x.Exp(big.NewInt(3), x, nil)\n\tx = x.Exp(big.NewInt(4), x, nil)\n\tx = x.Exp(big.NewInt(5), x, nil)\n\tstr := x.String()\n\tfmt.Printf(\"5^(4^(3^2)) has %d digits: %s ... %s\\n\",\n\t\tlen(str),\n\t\tstr[:20],\n\t\tstr[len(str)-20:],\n\t)\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 237,
    "input": "Translate Python to Go:from itertools import izip\n\ndef gen_row(w, s):\n    \n    def gen_seg(o, sp):\n        if not o:\n            return [[2] * sp]\n        return [[2] * x + o[0] + tail\n                for x in xrange(1, sp - len(o) + 2)\n                for tail in gen_seg(o[1:], sp - x)]\n\n    return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]\n\n\ndef deduce(hr, vr):\n    \n    def allowable(row):\n        return reduce(lambda a, b: [x | y for x, y in izip(a, b)], row)\n\n    def fits(a, b):\n        return all(x & y for x, y in izip(a, b))\n\n    def fix_col(n):\n        \n        c = [x[n] for x in can_do]\n        cols[n] = [x for x in cols[n] if fits(x, c)]\n        for i, x in enumerate(allowable(cols[n])):\n            if x != can_do[i][n]:\n                mod_rows.add(i)\n                can_do[i][n] &= x\n\n    def fix_row(n):\n        \n        c = can_do[n]\n        rows[n] = [x for x in rows[n] if fits(x, c)]\n        for i, x in enumerate(allowable(rows[n])):\n            if x != can_do[n][i]:\n                mod_cols.add(i)\n                can_do[n][i] &= x\n\n    def show_gram(m):\n        \n        \n        for x in m:\n            print \" \".join(\"x\n        print\n\n    w, h = len(vr), len(hr)\n    rows = [gen_row(w, x) for x in hr]\n    cols = [gen_row(h, x) for x in vr]\n    can_do = map(allowable, rows)\n\n    \n    mod_rows, mod_cols = set(), set(xrange(w))\n\n    while mod_cols:\n        for i in mod_cols:\n            fix_col(i)\n        mod_cols = set()\n        for i in mod_rows:\n            fix_row(i)\n        mod_rows = set()\n\n    if all(can_do[i][j] in (1, 2) for j in xrange(w) for i in xrange(h)):\n        print \"Solution would be unique\" \n    else:\n        print \"Solution may not be unique, doing exhaustive search:\"\n\n    \n    \n    \n    out = [0] * h\n\n    def try_all(n = 0):\n        if n >= h:\n            for j in xrange(w):\n                if [x[j] for x in out] not in cols[j]:\n                    return 0\n            show_gram(out)\n            return 1\n        sol = 0\n        for x in rows[n]:\n            out[n] = x\n            sol += try_all(n + 1)\n        return sol\n\n    n = try_all()\n    if not n:\n        print \"No solution.\"\n    elif n == 1:\n        print \"Unique solution.\"\n    else:\n        print n, \"solutions.\"\n    print\n\n\ndef solve(p, show_runs=True):\n    s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]\n         for l in p.splitlines()]\n    if show_runs:\n        print \"Horizontal runs:\", s[0]\n        print \"Vertical runs:\", s[1]\n    deduce(s[0], s[1])\n\n\ndef main():\n    \n    fn = \"nonogram_problems.txt\"\n    for p in (x for x in open(fn).read().split(\"\\n\\n\") if x):\n        solve(p)\n\n    print \"Extra example not solvable by deduction alone:\"\n    solve(\"B B A A\\nB B A A\")\n\n    print \"Extra example where there is no solution:\"\n    solve(\"B A A\\nA A A\")\n\nmain()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\ntype BitSet []bool\n\nfunc (bs BitSet) and(other BitSet) {\n    for i := range bs {\n        if bs[i] && other[i] {\n            bs[i] = true\n        } else {\n            bs[i] = false\n        }\n    }\n}\n\nfunc (bs BitSet) or(other BitSet) {\n    for i := range bs {\n        if bs[i] || other[i] {\n            bs[i] = true\n        } else {\n            bs[i] = false\n        }\n    }\n}\n\nfunc iff(cond bool, s1, s2 string) string {\n    if cond {\n        return s1\n    }\n    return s2\n}\n\nfunc newPuzzle(data [2]string) {\n    rowData := strings.Fields(data[0])\n    colData := strings.Fields(data[1])\n    rows := getCandidates(rowData, len(colData))\n    cols := getCandidates(colData, len(rowData))\n\n    for {\n        numChanged := reduceMutual(cols, rows)\n        if numChanged == -1 {\n            fmt.Println(\"No solution\")\n            return\n        }\n        if numChanged == 0 {\n            break\n        }\n    }\n\n    for _, row := range rows {\n        for i := 0; i < len(cols); i++ {\n            fmt.Printf(iff(row[0][i], \"# \", \". \"))\n        }\n        fmt.Println()\n    }\n    fmt.Println()\n}\n\n\nfunc getCandidates(data []string, le int) [][]BitSet {\n    var result [][]BitSet\n    for _, s := range data {\n        var lst []BitSet\n        a := []byte(s)\n        sumBytes := 0\n        for _, b := range a {\n            sumBytes += int(b - 'A' + 1)\n        }\n        prep := make([]string, len(a))\n        for i, b := range a {\n            prep[i] = strings.Repeat(\"1\", int(b-'A'+1))\n        }\n        for _, r := range genSequence(prep, le-sumBytes+1) {\n            bits := []byte(r[1:])\n            bitset := make(BitSet, len(bits))\n            for i, b := range bits {\n                bitset[i] = b == '1'\n            }\n            lst = append(lst, bitset)\n        }\n        result = append(result, lst)\n    }\n    return result\n}\n\nfunc genSequence(ones []string, numZeros int) []string {\n    le := len(ones)\n    if le == 0 {\n        return []string{strings.Repeat(\"0\", numZeros)}\n    }\n    var result []string\n    for x := 1; x < numZeros-le+2; x++ {\n        skipOne := ones[1:]\n        for _, tail := range genSequence(skipOne, numZeros-x) {\n            result = append(result, strings.Repeat(\"0\", x)+ones[0]+tail)\n        }\n    }\n    return result\n}\n\n\n\nfunc reduceMutual(cols, rows [][]BitSet) int {\n    countRemoved1 := reduce(cols, rows)\n    if countRemoved1 == -1 {\n        return -1\n    }\n    countRemoved2 := reduce(rows, cols)\n    if countRemoved2 == -1 {\n        return -1\n    }\n    return countRemoved1 + countRemoved2\n}\n\nfunc reduce(a, b [][]BitSet) int {\n    countRemoved := 0\n    for i := 0; i < len(a); i++ {\n        commonOn := make(BitSet, len(b))\n        for j := 0; j < len(b); j++ {\n            commonOn[j] = true\n        }\n        commonOff := make(BitSet, len(b))\n\n        \n        for _, candidate := range a[i] {\n            commonOn.and(candidate)\n            commonOff.or(candidate)\n        }\n\n        \n        for j := 0; j < len(b); j++ {\n            fi, fj := i, j\n            for k := len(b[j]) - 1; k >= 0; k-- {\n                cnd := b[j][k]\n                if (commonOn[fj] && !cnd[fi]) || (!commonOff[fj] && cnd[fi]) {\n                    lb := len(b[j])\n                    copy(b[j][k:], b[j][k+1:])\n                    b[j][lb-1] = nil\n                    b[j] = b[j][:lb-1]\n                    countRemoved++\n                }\n            }\n            if len(b[j]) == 0 {\n                return -1\n            }\n        }\n    }\n    return countRemoved\n}\n\nfunc main() {\n    p1 := [2]string{\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"}\n\n    p2 := [2]string{\n        \"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\",\n        \"D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\",\n    }\n\n    p3 := [2]string{\n        \"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH \" +\n            \"BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n        \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF \" +\n            \"AAAAD BDG CEF CBDB BBB FC\",\n    }\n\n    p4 := [2]string{\n        \"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G\",\n        \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ \" +\n            \"ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\",\n    }\n\n    for _, puzzleData := range [][2]string{p1, p2, p3, p4} {\n        newPuzzle(puzzleData)\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 238,
    "input": "Translate Python to Go:def hourglass_puzzle():\n    t4 = 0\n    while t4 < 10_000:\n        t7_left = 7 - t4 % 7\n        if t7_left == 9 - 4:\n            break\n        t4 += 4\n    else:\n        print('Not found')\n        return \n    print(f)\n \nhourglass_puzzle()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n)\n\nfunc minimum(a []int) int {\n    min := a[0]\n    for i := 1; i < len(a); i++ {\n        if a[i] < min {\n            min = a[i]\n        }\n    }\n    return min\n}\n\nfunc sum(a []int) int {\n    s := 0\n    for _, i := range a {\n        s = s + i\n    }\n    return s\n}\n\nfunc hourglassFlipper(hourglasses []int, target int) (int, []int) {\n    flippers := make([]int, len(hourglasses))\n    copy(flippers, hourglasses)\n    var series []int\n    for iter := 0; iter < 10000; iter++ {\n        n := minimum(flippers)\n        series = append(series, n)\n        for i := 0; i < len(flippers); i++ {\n            flippers[i] -= n\n        }\n        for i, flipper := range flippers {\n            if flipper == 0 {\n                flippers[i] = hourglasses[i]\n            }\n        }\n        for start := len(series) - 1; start >= 0; start-- {\n            if sum(series[start:]) == target {\n                return start, series\n            }\n        }\n    }\n    log.Fatal(\"Unable to find an answer within 10,000 iterations.\")\n    return 0, nil\n}\n\nfunc main() {\n    fmt.Print(\"Flip an hourglass every time it runs out of grains, \")\n    fmt.Println(\"and note the interval in time.\")\n    hgs := [][]int{{4, 7}, {5, 7, 31}}\n    ts := []int{9, 36}\n    for i := 0; i < len(hgs); i++ {\n        start, series := hourglassFlipper(hgs[i], ts[i])\n        end := len(series) - 1\n        fmt.Println(\"\\nSeries:\", series)\n        fmt.Printf(\"Use hourglasses from indices %d to %d (inclusive) to sum \", start, end)\n        fmt.Println(ts[i], \"using\", hgs[i])\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 239,
    "input": "Translate C++ to VB:for(int i = 10; i >= 0; --i)\n  std::cout << i << \"\\n\";\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "For i = 10 To 0 Step -1\n   Debug.Print i\nNext i\n",
    "input_language": "C++",
    "output_language": "VB"
  },
  {
    "id": 240,
    "input": "Translate C++ to Java:#include <array>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\nstruct FieldDetails {string_view Name; int NumBits;};\n\n\n\ntemplate <const char *T> consteval auto ParseDiagram()\n{  \n    \n    constexpr string_view rawArt(T);\n    constexpr auto firstBar = rawArt.find(\"|\");\n    constexpr auto lastBar = rawArt.find_last_of(\"|\");\n    constexpr auto art = rawArt.substr(firstBar, lastBar - firstBar);\n    static_assert(firstBar < lastBar, \"ASCII Table has no fields\");\n    \n    \n    constexpr auto numFields = \n        count(rawArt.begin(), rawArt.end(), '|') -\n        count(rawArt.begin(), rawArt.end(), '\\n') / 2;    \n    array<FieldDetails, numFields> fields;\n    \n    \n    bool isValidDiagram = true;\n    int startDiagramIndex = 0;\n    int totalBits = 0;\n    for(int i = 0; i < numFields; )\n    {\n        auto beginningBar = art.find(\"|\", startDiagramIndex);\n        auto endingBar = art.find(\"|\", beginningBar + 1);\n        auto field = art.substr(beginningBar + 1, endingBar - beginningBar - 1);\n        if(field.find(\"-\") == field.npos) \n        {\n            int numBits = (field.size() + 1) / 3;\n            auto nameStart = field.find_first_not_of(\" \");\n            auto nameEnd = field.find_last_not_of(\" \");\n            if (nameStart > nameEnd || nameStart == string_view::npos) \n            {\n                \n                isValidDiagram = false;\n                field = \"\"sv;\n            }\n            else\n            {\n                field = field.substr(nameStart, 1 + nameEnd - nameStart);\n            }\n            fields[i++] = FieldDetails {field, numBits};\n            totalBits += numBits;\n        }\n        startDiagramIndex = endingBar;\n    }\n    \n    int numRawBytes = isValidDiagram ? (totalBits - 1) / 8 + 1 : 0;\n    return make_pair(fields, numRawBytes);\n}\n\n\ntemplate <const char *T> auto Encode(auto inputValues)\n{\n    constexpr auto parsedDiagram = ParseDiagram<T>();\n    static_assert(parsedDiagram.second > 0, \"Invalid ASCII talble\");\n    array<unsigned char, parsedDiagram.second> data;\n\n    int startBit = 0;\n    int i = 0;\n    for(auto value : inputValues)\n    {\n        const auto &field = parsedDiagram.first[i++];\n        int remainingValueBits = field.NumBits;\n        while(remainingValueBits > 0)\n        {\n            \n            auto [fieldStartByte, fieldStartBit] = div(startBit, 8);\n            int unusedBits = 8 - fieldStartBit;\n            int numBitsToEncode = min({unusedBits, 8, field.NumBits});\n            int divisor = 1 << (remainingValueBits - numBitsToEncode);\n            unsigned char bitsToEncode = value / divisor;\n            data[fieldStartByte] <<= numBitsToEncode;\n            data[fieldStartByte] |= bitsToEncode;\n            value %= divisor;\n            startBit += numBitsToEncode;\n            remainingValueBits -= numBitsToEncode;\n        }\n    }\n    \n    return data;\n}\n\n\ntemplate <const char *T> void Decode(auto data)\n{\n    cout << \"Name      Bit Pattern\\n\";\n    cout << \"=======   ================\\n\";\n    constexpr auto parsedDiagram = ParseDiagram<T>();\n    static_assert(parsedDiagram.second > 0, \"Invalid ASCII talble\");\n\n    int startBit = 0;\n    for(const auto& field : parsedDiagram.first)\n    {\n        \n        auto [fieldStartByte, fieldStartBit] = div(startBit, 8);\n        unsigned char firstByte = data[fieldStartByte];\n        firstByte <<= fieldStartBit;\n        firstByte >>= fieldStartBit;\n        int64_t value = firstByte;\n        auto endBit = startBit + field.NumBits;\n        auto [fieldEndByte, fieldEndBit] = div(endBit, 8);\n        fieldEndByte = min(fieldEndByte, (int)(ssize(data) - 1));\n        for(int index = fieldStartByte + 1; index <= fieldEndByte; index++)\n        {\n            value <<= 8;\n            value += data[index];\n        }\n        value >>= fieldEndBit;\n        startBit = endBit;\n        \n        cout << field.Name << \n            string_view(\"        \", (7 - field.Name.size())) << \"   \" << \n            string_view(bitset<64>(value).to_string()).substr(64 - field.NumBits, 64) <<  \"\\n\";\n    }\n            \n}\n\nint main(void) \n{\n    static constexpr char art[] = R\"(\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+)\";\n    \n    \n    auto rawData = Encode<art> (initializer_list<int64_t> {\n        30791,\n        0, 15, 0, 1, 1, 1, 3, 15,\n        21654,\n        57646,\n        7153,\n        27044\n    });\n    \n    cout << \"Raw encoded data in hex:\\n\";\n    for (auto v : rawData) printf(\"%.2X\", v);\n    cout << \"\\n\\n\";\n    \n    cout << \"Decoded raw data:\\n\";\n    Decode<art>(rawData);\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AsciiArtDiagramConverter {\n\n    private static final String TEST = \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                      ID                       |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    QDCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ANCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    NSCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ARCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\";\n\n    public static void main(String[] args) {\n        validate(TEST);\n        display(TEST);\n        Map<String,List<Integer>> asciiMap = decode(TEST);\n        displayMap(asciiMap);\n        displayCode(asciiMap, \"78477bbf5496e12e1bf169a4\");\n    }\n\n    private static void displayCode(Map<String,List<Integer>> asciiMap, String hex) {\n        System.out.printf(\"%nTest string in hex:%n%s%n%n\", hex);\n\n        String bin = new BigInteger(hex,16).toString(2);\n\n        \n        int length = 0;\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            length += pos.get(1) - pos.get(0) + 1;\n        }\n        while ( length > bin.length() ) {\n            bin = \"0\" + bin;\n        }\n        System.out.printf(\"Test string in binary:%n%s%n%n\", bin);\n\n        System.out.printf(\"Name      Size  Bit Pattern%n\");\n        System.out.printf(\"-------- -----  -----------%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            int start = pos.get(0);\n            int end   = pos.get(1);\n            System.out.printf(\"%-8s    %2d  %s%n\", code, end-start+1, bin.substring(start, end+1));\n        }\n\n    }\n\n\n    private static void display(String ascii) {\n        System.out.printf(\"%nDiagram:%n%n\");\n        for ( String s : TEST.split(\"\\\\r\\\\n\") ) {\n            System.out.println(s);\n        }\n    }\n\n    private static void displayMap(Map<String,List<Integer>> asciiMap) {\n        System.out.printf(\"%nDecode:%n%n\");\n\n\n        System.out.printf(\"Name      Size  Start    End%n\");\n        System.out.printf(\"-------- -----  -----  -----%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            System.out.printf(\"%-8s    %2d     %2d     %2d%n\", code, pos.get(1)-pos.get(0)+1, pos.get(0), pos.get(1));\n        }\n\n    }\n\n    private static Map<String,List<Integer>> decode(String ascii) {\n        Map<String,List<Integer>> map = new LinkedHashMap<>();\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        int size = split[0].indexOf(\"+\", 1) - split[0].indexOf(\"+\");\n        int length = split[0].length() - 1;\n        for ( int i = 1 ; i < split.length ; i += 2 ) {\n            int barIndex = 1;\n            String test = split[i];\n            int next;\n            while ( barIndex < length && (next = test.indexOf(\"|\", barIndex)) > 0 ) {\n                \n                List<Integer> startEnd = new ArrayList<>();\n                startEnd.add((barIndex/size) + (i/2)*(length/size));\n                startEnd.add(((next-1)/size) + (i/2)*(length/size));\n                String code = test.substring(barIndex, next).replace(\" \", \"\");\n                map.put(code, startEnd);\n                \n                barIndex = next + 1;\n            }\n        }\n\n        return map;\n    }\n\n    private static void validate(String ascii) {\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        if ( split.length % 2 != 1 ) {\n            throw new RuntimeException(\"ERROR 1:  Invalid number of input lines.  Line count = \" + split.length);\n        }\n        int size = 0;\n        for ( int i = 0 ; i < split.length ; i++ ) {\n            String test = split[i];\n            if ( i % 2 == 0 ) {\n                \n                if ( ! test.matches(\"^\\\\+([-]+\\\\+)+$\") ) {\n                    throw new RuntimeException(\"ERROR 2:  Improper line format.  Line = \" + test);\n                }\n                if ( size == 0 ) {\n                    int firstPlus = test.indexOf(\"+\");\n                    int secondPlus = test.indexOf(\"+\", 1);\n                    size = secondPlus - firstPlus;\n                }\n                if ( ((test.length()-1) % size) != 0 ) {\n                    throw new RuntimeException(\"ERROR 3:  Improper line format.  Line = \" + test);\n                }\n                \n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    if ( test.charAt(j) != '+' ) {\n                        throw new RuntimeException(\"ERROR 4:  Improper line format.  Line = \" + test);\n                    }\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        if ( test.charAt(k) != '-' ) {\n                            throw new RuntimeException(\"ERROR 5:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n            }\n            else {\n                \n                if ( ! test.matches(\"^\\\\|(\\\\s*[A-Za-z]+\\\\s*\\\\|)+$\") ) {\n                    throw new RuntimeException(\"ERROR 6:  Improper line format.  Line = \" + test);\n                }\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        \n                        if ( test.charAt(k) == '|' ) {\n                            throw new RuntimeException(\"ERROR 7:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 241,
    "input": "Translate PHP to Go:<?php\n$colors = array(array(  0,   0,   0),   // black\n                array(255,   0,   0),   // red\n                array(  0, 255,   0),   // green\n                array(  0,   0, 255),   // blue\n                array(255,   0, 255),   // magenta\n                array(  0, 255, 255),   // cyan\n                array(255, 255,   0),   // yellow\n                array(255, 255, 255));  // white\n\ndefine('BARWIDTH', 640 / count($colors));\ndefine('HEIGHT',   480);\n\n$image = imagecreate(BARWIDTH * count($colors), HEIGHT);\n\nforeach ($colors as $position => $color) {\n    $color = imagecolorallocate($image, $color[0], $color[1], $color[2]);\n    imagefilledrectangle($image, $position * BARWIDTH, 0,\n                         $position * BARWIDTH + BARWIDTH - 1,\n                         HEIGHT - 1, $color);\n}\n\nheader('Content-type:image/png');\nimagepng($image);\nimagedestroy($image);\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"github.com/fogleman/gg\"\n\nvar colors = [8]string{\n    \"000000\", \n    \"FF0000\", \n    \"00FF00\", \n    \"0000FF\", \n    \"FF00FF\", \n    \"00FFFF\", \n    \"FFFF00\", \n    \"FFFFFF\", \n}\n\nfunc drawBars(dc *gg.Context) {\n    w := float64(dc.Width() / len(colors))\n    h := float64(dc.Height())\n    for i := range colors {\n        dc.SetHexColor(colors[i])\n        dc.DrawRectangle(w*float64(i), 0, w, h)\n        dc.Fill()\n    }\n}\n\nfunc main() {\n    dc := gg.NewContext(400, 400)\n    drawBars(dc)\n    dc.SavePNG(\"color_bars.png\")\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 242,
    "input": "Translate C to PHP:\n#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct arg\n{\n  int       (*fn)(struct arg*);\n  int        *k;\n  struct arg *x1, *x2, *x3, *x4, *x5;\n} ARG;\n\n\nint f_1 (ARG* _) { return -1; }\nint f0  (ARG* _) { return  0; }\nint f1  (ARG* _) { return  1; }\n\n\nint eval(ARG* a) { return a->fn(a); }\n#define MAKE_ARG(...) (&(ARG){__VA_ARGS__})\n#define FUN(...) MAKE_ARG(B, &k, __VA_ARGS__)\n\nint A(ARG*);\n\n\nint B(ARG* a)\n{\n  int k = *a->k -= 1;\n  return A(FUN(a, a->x1, a->x2, a->x3, a->x4));\n}\n\nint A(ARG* a)\n{\n  return *a->k <= 0 ? eval(a->x4) + eval(a->x5) : B(a);\n}\n\nint main(int argc, char **argv)\n{\n  int k = argc == 2 ? strtol(argv[1], 0, 0) : 10;\n  printf(\"%d\\n\", A(FUN(MAKE_ARG(f1), MAKE_ARG(f_1), MAKE_ARG(f_1),\n                       MAKE_ARG(f1), MAKE_ARG(f0))));\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\nfunction A($k,$x1,$x2,$x3,$x4,$x5) {\n    $b = function () use (&$b,&$k,$x1,$x2,$x3,$x4) {\n        return A(--$k,$b,$x1,$x2,$x3,$x4);\n    };\n    return $k <= 0 ? $x4() + $x5() : $b();\n}  \n\necho A(10, function () { return  1; },\n           function () { return -1; },\n           function () { return -1; },\n           function () { return  1; }, \n           function () { return  0; }) . \"\\n\";\n?>\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 243,
    "input": "Translate C to C++:#include<graphics.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\n\n#define pi M_PI\n\ntypedef struct{\n\tdouble x,y;\n}point;\n\nvoid kochCurve(point p1,point p2,int times){\n\tpoint p3,p4,p5;\n\tdouble theta = pi/3;\n\t\n\tif(times>0){\n\t\tp3 = (point){(2*p1.x+p2.x)/3,(2*p1.y+p2.y)/3};\n\t\tp5 = (point){(2*p2.x+p1.x)/3,(2*p2.y+p1.y)/3};\n\t\t\n\t\tp4 = (point){p3.x + (p5.x - p3.x)*cos(theta) + (p5.y - p3.y)*sin(theta),p3.y - (p5.x - p3.x)*sin(theta) + (p5.y - p3.y)*cos(theta)};\n\t\t\n\t\tkochCurve(p1,p3,times-1);\n\t\tkochCurve(p3,p4,times-1);\n\t\tkochCurve(p4,p5,times-1);\n\t\tkochCurve(p5,p2,times-1);\n\t}\n\t\n\telse{\n\t\tline(p1.x,p1.y,p2.x,p2.y);\n\t}\n}\n\nint main(int argC, char** argV)\n{\n\tint w,h,r;\n\tpoint p1,p2;\n\t\n\tif(argC!=4){\n\t\tprintf(\"Usage : %s <window width> <window height> <recursion level>\",argV[0]);\n\t}\n\t\n\telse{\n\t\tw = atoi(argV[1]);\n\t\th = atoi(argV[2]);\n\t\tr = atoi(argV[3]);\n\t\t\n\t\tinitwindow(w,h,\"Koch Curve\");\n\t\t\n\t\tp1 = (point){10,h-10};\n\t\tp2 = (point){w-10,h-10};\n\t\t\n\t\tkochCurve(p1,p2,r);\n\t\t\n\t\tgetch();\n\t\n\t\tclosegraph();\n\t}\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "\n#include <fstream>\n#include <iostream>\n#include <vector>\n\nconstexpr double sqrt3_2 = 0.86602540378444; \n\nstruct point {\n    double x;\n    double y;\n};\n\nstd::vector<point> koch_next(const std::vector<point>& points) {\n    size_t size = points.size();\n    std::vector<point> output(4*(size - 1) + 1);\n    double x0, y0, x1, y1;\n    size_t j = 0;\n    for (size_t i = 0; i + 1 < size; ++i) {\n        x0 = points[i].x;\n        y0 = points[i].y;\n        x1 = points[i + 1].x;\n        y1 = points[i + 1].y;\n        double dy = y1 - y0;\n        double dx = x1 - x0;\n        output[j++] = {x0, y0};\n        output[j++] = {x0 + dx/3, y0 + dy/3};\n        output[j++] = {x0 + dx/2 - dy * sqrt3_2/3, y0 + dy/2 + dx * sqrt3_2/3};\n        output[j++] = {x0 + 2 * dx/3, y0 + 2 * dy/3};\n    }\n    output[j] = {x1, y1};\n    return output;\n}\n\nstd::vector<point> koch_points(int size, int iterations) {\n    double length = size * sqrt3_2 * 0.95;\n    double x = (size - length)/2;\n    double y = size/2 - length * sqrt3_2/3;\n    std::vector<point> points{\n        {x, y},\n        {x + length/2, y + length * sqrt3_2},\n        {x + length, y},\n        {x, y}\n    };\n    for (int i = 0; i < iterations; ++i)\n        points = koch_next(points);\n    return points;\n}\n\nvoid koch_curve_svg(std::ostream& out, int size, int iterations) {\n    out << \"<svg xmlns='http:\n        << size << \"' height='\" << size << \"'>\\n\";\n    out << \"<rect width='100%' height='100%' fill='black'/>\\n\";\n    out << \"<path stroke-width='1' stroke='white' fill='none' d='\";\n    auto points(koch_points(size, iterations));\n    for (size_t i = 0, n = points.size(); i < n; ++i)\n        out << (i == 0 ? \"M\" : \"L\") << points[i].x << ',' << points[i].y << '\\n';\n    out << \"z'/>\\n</svg>\\n\";\n}\n\nint main() {\n    std::ofstream out(\"koch_curve.svg\");\n    if (!out) {\n        std::cerr << \"Cannot open output file\\n\";\n        return EXIT_FAILURE;\n    }\n    koch_curve_svg(out, 600, 5);\n    return EXIT_SUCCESS;\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 244,
    "input": "Translate Python to Go:\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef digSum(n, b):\n    s = 0\n    while n:\n        s += (n % b)\n        n = n // b\n    return s\n\nif __name__ == '__main__':\n    for n in range(11, 99):\n        if isPrime(digSum(n**3, 10)) and isPrime(digSum(n**2, 10)):\n            print(n, end = \"  \")\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nfunc main() {\n    for i := 1; i < 100; i++ {\n        if !rcu.IsPrime(rcu.DigitSum(i*i, 10)) {\n            continue\n        }\n        if rcu.IsPrime(rcu.DigitSum(i*i*i, 10)) {\n            fmt.Printf(\"%d \", i)\n        }\n    }\n    fmt.Println()\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 245,
    "input": "Translate PHP to Go:'c';                      # character\n'hello';                  # these two strings are the same\n\"hello\";\n'Hi $name. How are you?'; # result: \"Hi $name. How are you?\"\n\"Hi $name. How are you?\"; # result: \"Hi Bob. How are you?\"\n'\\n';                     # 2-character string with a backslash and \"n\"\n\"\\n\";                     # newline character\n`ls`;                     # runs a command in the shell and returns the output as a string\n<<END                     # Here-Document\nHi, whatever goes here gets put into the string,\nincluding newlines and $variables,\nuntil the label we put above\nEND;\n<<'END'                   # Here-Document like single-quoted\nSame as above, but no interpolation of $variables.\nEND;\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "ch := 'z'\nch = 122          \nch = '\\x7a'       \nch = '\\u007a'     \nch = '\\U0000007a' \nch = '\\172'       \n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 246,
    "input": "Translate Java to Go:import java.util.Arrays;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] N = {1, -12, 0, -42};\n        int[] D = {1, -3};\n\n        System.out.printf(\"%s / %s = %s\",\n                Arrays.toString(N),\n                Arrays.toString(D),\n                Arrays.deepToString(extendedSyntheticDivision(N, D)));\n    }\n\n    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {\n        int[] out = dividend.clone();\n        int normalizer = divisor[0];\n\n        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {\n            out[i] /= normalizer;\n\n            int coef = out[i];\n            if (coef != 0) {\n                for (int j = 1; j < divisor.length; j++)\n                    out[i + j] += -divisor[j] * coef;\n            }\n        }\n\n        int separator = out.length - (divisor.length - 1);\n\n        return new int[][]{\n            Arrays.copyOfRange(out, 0, separator),\n            Arrays.copyOfRange(out, separator, out.length)\n        };\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nfunc div(dividend, divisor []*big.Rat) (quotient, remainder []*big.Rat) {\n    out := make([]*big.Rat, len(dividend))\n    for i, c := range dividend {\n        out[i] = new(big.Rat).Set(c)\n    }\n    for i := 0; i < len(dividend)-(len(divisor)-1); i++ {\n        out[i].Quo(out[i], divisor[0])\n        if coef := out[i]; coef.Sign() != 0 {\n            var a big.Rat\n            for j := 1; j < len(divisor); j++ {\n                out[i+j].Add(out[i+j], a.Mul(a.Neg(divisor[j]), coef))\n            }\n        }\n    }\n    separator := len(out) - (len(divisor) - 1)\n    return out[:separator], out[separator:]\n}\n\nfunc main() {\n    N := []*big.Rat{\n        big.NewRat(1, 1),\n        big.NewRat(-12, 1),\n        big.NewRat(0, 1),\n        big.NewRat(-42, 1)}\n    D := []*big.Rat{big.NewRat(1, 1), big.NewRat(-3, 1)}\n    Q, R := div(N, D)\n    fmt.Printf(\"%v / %v = %v remainder %v\\n\", N, D, Q, R)\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 247,
    "input": "Translate Python to Go:\nfrom __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    tree := eertree([]byte(\"eertree\"))\n    fmt.Println(subPalindromes(tree))\n}\n\ntype edges map[byte]int\n\ntype node struct {\n    length int\n    edges\n    suffix int\n}\n\nconst evenRoot = 0\nconst oddRoot = 1\n\nfunc eertree(s []byte) []node {\n    tree := []node{\n        evenRoot: {length: 0, suffix: oddRoot, edges: edges{}},\n        oddRoot:  {length: -1, suffix: oddRoot, edges: edges{}},\n    }\n    suffix := oddRoot\n    var n, k int\n    for i, c := range s {\n        for n = suffix; ; n = tree[n].suffix {\n            k = tree[n].length\n            if b := i - k - 1; b >= 0 && s[b] == c {\n                break\n            }\n        }\n        if e, ok := tree[n].edges[c]; ok {\n            suffix = e\n            continue\n        }\n        suffix = len(tree)\n        tree = append(tree, node{length: k + 2, edges: edges{}})\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1 {\n            tree[suffix].suffix = 0\n            continue\n        }\n        for {\n            n = tree[n].suffix\n            if b := i - tree[n].length - 1; b >= 0 && s[b] == c {\n                break\n            }\n        }\n        tree[suffix].suffix = tree[n].edges[c]\n    }\n    return tree\n}\n\nfunc subPalindromes(tree []node) (s []string) {\n    var children func(int, string)\n    children = func(n int, p string) {\n        for c, n := range tree[n].edges {\n            c := string(c)\n            p := c + p + c\n            s = append(s, p)\n            children(n, p)\n        }\n    }\n    children(0, \"\")\n    for c, n := range tree[1].edges {\n        c := string(c)\n        s = append(s, c)\n        children(n, c)\n    }\n    return\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 248,
    "input": "Translate PHP to Python:<?php\n \nfunction gcd($a, $b)\n{\n    if ($a == 0)\n       return $b;\n    if ($b == 0)\n       return $a;\n    if($a == $b)\n        return $a;\n    if($a > $b)\n        return gcd($a-$b, $b);\n    return gcd($a, $b-$a);\n}\n\n$pytha = 0;\n$prim = 0;\n$max_p = 100;\n\nfor ($a = 1; $a <= $max_p / 3; $a++) {\n    $aa = $a**2;\n    for ($b = $a + 1; $b < $max_p/2; $b++) {\n        $bb = $b**2;\n        for ($c = $b + 1; $c < $max_p/2; $c++) {\n            $cc = $c**2;\n            if ($aa + $bb < $cc) break;\n            if ($a + $b + $c > $max_p) break;\n\n            if ($aa + $bb == $cc) {\n                $pytha++;\n                if (gcd($a, $b) == 1) $prim++;\n            }\n        }\n    }\n}\n\necho 'Up to ' . $max_p . ', there are ' . $pytha . ' triples, of which ' . $prim . ' are primitive.';\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 249,
    "input": "Translate Java to Go:import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class ImageNoise {\n    int framecount = 0;\n    int fps = 0;\n    BufferedImage image;\n    Kernel kernel;\n    ConvolveOp cop;\n    JFrame frame = new JFrame(\"Java Image Noise\");\n\n    JPanel panel = new JPanel() {\n        private int show_fps = 0; \n        private MouseAdapter ma = new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                show_fps = (show_fps + 1) % 3;\n            }\n        };\n        {addMouseListener(ma);}\n\n        @Override\n        public Dimension getPreferredSize() {\n            return new Dimension(320, 240);\n        }\n\n        @Override\n        @SuppressWarnings(\"fallthrough\")\n        public void paintComponent(Graphics g1) {\n            Graphics2D g = (Graphics2D) g1;\n            drawNoise();\n            g.drawImage(image, 0, 0, null);\n\n            switch (show_fps) {\n            case 0: \n                \n                int xblur = getWidth() - 130, yblur = getHeight() - 32;\n                BufferedImage bc = image.getSubimage(xblur, yblur, 115, 32);\n                BufferedImage bs = new BufferedImage(bc.getWidth(), bc.getHeight(),\n                                                     BufferedImage.TYPE_BYTE_GRAY);\n                cop.filter(bc, bs);\n                g.drawImage(bs, xblur, yblur , null);\n            case 1: \n                \n                g.setColor(Color.RED);\n                g.setFont(new Font(\"Monospaced\", Font.BOLD, 20));\n                g.drawString(\"FPS: \" + fps, getWidth() - 120, getHeight() - 10);\n            }\n            framecount++;\n        }\n    };\n    \n    \n    Timer repainter = new Timer(1, new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            panel.repaint();\n        }\n    });\n    \n    \n    Timer framerateChecker = new Timer(1000, new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            fps = framecount;\n            framecount = 0;\n        }\n    });\n    \n    public ImageNoise() {\n        \n        float[] vals = new float[121];\n        Arrays.fill(vals, 1/121f);\n        kernel = new Kernel(11, 11, vals);\n        cop = new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);\n        \n        \n        frame.add(panel);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.pack();\n        frame.setVisible(true);\n        repainter.start();\n        framerateChecker.start();\n    }\n\n    void drawNoise() {\n        int w = panel.getWidth(), h = panel.getHeight();\n        \n        \n        if (null == image || image.getWidth() != w || image.getHeight() != h) {\n            image = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_GRAY);\n        }\n        Random rand = new Random();\n        int[] data = new int[w * h];\n        \n        for (int x = 0; x < w * h / 32; x++) {\n            int r = rand.nextInt();\n            for (int i = 0; i < 32; i++) {\n                data[x * 32 + i] = (r & 1) * Integer.MAX_VALUE;\n                r >>>= 1;\n            }\n        }\n        \n        image.getRaster().setPixels(0, 0, w, h, data);\n    }\n    \n    public static void main(String[] args) {\n        \n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                ImageNoise i = new ImageNoise();\n            }\n        });\n    }\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"code.google.com/p/x-go-binding/ui/x11\"\n    \"fmt\"\n    \"image\"\n    \"image/color\"\n    \"image/draw\"\n    \"log\"\n    \"os\"\n    \"time\"\n)\n\nvar randcol = genrandcol()\n\nfunc genrandcol() <-chan color.Color {\n    c := make(chan color.Color)\n\n    go func() {\n        for {\n            select {\n            case c <- image.Black:\n            case c <- image.White:\n            }\n        }\n    }()\n\n    return c\n}\n\nfunc gennoise(screen draw.Image) {\n    for y := 0; y < 240; y++ {\n        for x := 0; x < 320; x++ {\n            screen.Set(x, y, <-randcol)\n        }\n    }\n}\n\nfunc fps() chan<- bool {\n    up := make(chan bool)\n\n    go func() {\n        var frames int64\n        var lasttime time.Time\n        var totaltime time.Duration\n\n        for {\n            <-up\n            frames++\n            now := time.Now()\n            totaltime += now.Sub(lasttime)\n            if totaltime > time.Second {\n                fmt.Printf(\"FPS: %v\\n\", float64(frames)/totaltime.Seconds())\n                frames = 0\n                totaltime = 0\n            }\n            lasttime = now\n        }\n    }()\n\n    return up\n}\n\nfunc main() {\n    win, err := x11.NewWindow()\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    defer win.Close()\n\n    go func() {\n        upfps := fps()\n        screen := win.Screen()\n\n        for {\n            gennoise(screen)\n\n            win.FlushImage()\n\n            upfps <- true\n        }\n    }()\n\n    for _ = range win.EventChan() {\n    }\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 250,
    "input": "Translate C++ to C#:#include <iostream\">\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\n\nconst uint* binary(uint n, uint length);\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r);\n\nvector<uint> factors(uint x);\n\nbool isPrime(uint number);\n\nbool isZum(uint n);\n\nostream& operator<<(ostream& os, const vector<uint>& zumz) {\n    for (uint i = 0; i < zumz.size(); i++) {\n        if (i % 10 == 0)\n            os << endl;\n        os << setw(10) << zumz[i] << ' ';\n    }\n    return os;\n}\n\nint main() {\n    cout << \"First 220 Zumkeller numbers:\" << endl;\n    vector<uint> zumz;\n    for (uint n = 2; zumz.size() < 220; n++)\n        if (isZum(n))\n            zumz.push_back(n);\n    cout << zumz << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers:\" << endl;\n    vector<uint> zumz2;\n    for (uint n = 2; zumz2.size() < 40; n++)\n        if (n % 2 && isZum(n))\n            zumz2.push_back(n);\n    cout << zumz2 << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers not ending in 5:\" << endl;\n    vector<uint> zumz3;\n    for (uint n = 2; zumz3.size() < 40; n++)\n        if (n % 2 && (n % 10) !=  5 && isZum(n))\n            zumz3.push_back(n);\n    cout << zumz3 << endl << endl;\n\n    return 0;\n}\n\n\nconst uint* binary(uint n, uint length) {\n    uint* bin = new uint[length];\t    \n    fill(bin, bin + length, 0);         \n    \n    for (uint i = 0; n > 0; i++) {\n        uint rem = n % 2;\n        n /= 2;\n        if (rem)\n            bin[length - 1 - i] = 1;\n    }\n\n    return bin;\n}\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r) {\n    vector<uint> subset;\n    \n    const uint* bits = binary(r, d.size() - 1);\n\n    \n    for (uint i = 0; i < d.size() - 1; i++)\n        if (bits[i])\n            subset.push_back(d[i]);\n\n    delete[] bits;\n\n    return accumulate(subset.begin(), subset.end(), 0u);\n}\n\nvector<uint> factors(uint x) {\n    vector<uint> result;\n    \n    for (uint i = 1; i * i <= x; i++) {\n        \n        if (x % i == 0) {\n            result.push_back(i);\n\n            if (x / i != i)\n                result.push_back(x / i);\n        }\n    }\n\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n\nbool isPrime(uint number) {\n    if (number < 2) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n    for (uint i = 3; i * i <= number; i += 2)\n        if (number % i == 0) return false;\n\n    return true;\n}\n\nbool isZum(uint n) {\n    \n    if (isPrime(n))\n        return false;\n\n    \n    const auto d = factors(n);\n    uint s = accumulate(d.begin(), d.end(), 0u);\n\n    \n    if (s % 2 || s < 2 * n)\n        return false;\n\n    \n    \n    \n    if (n % 2 || d.size() >= 24)\n        return true;\n\n    if (!(s % 2) && d[d.size() - 1] <= s / 2)\n        for (uint x = 2; (uint) log2(x) < (d.size() - 1); x++) \n            if (sum_subset_unrank_bin(d, x) == s / 2)\n                return true; \n\n    \n    return false;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ZumkellerNumbers {\n    class Program {\n        static List<int> GetDivisors(int n) {\n            List<int> divs = new List<int> {\n                1, n\n            };\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs.Add(j);\n                    }\n                }\n            }\n            return divs;\n        }\n\n        static bool IsPartSum(List<int> divs, int sum) {\n            if (sum == 0) {\n                return true;\n            }\n            var le = divs.Count;\n            if (le == 0) {\n                return false;\n            }\n            var last = divs[le - 1];\n            List<int> newDivs = new List<int>();\n            for (int i = 0; i < le - 1; i++) {\n                newDivs.Add(divs[i]);\n            }\n            if (last > sum) {\n                return IsPartSum(newDivs, sum);\n            }\n            return IsPartSum(newDivs, sum) || IsPartSum(newDivs, sum - last);\n        }\n\n        static bool IsZumkeller(int n) {\n            var divs = GetDivisors(n);\n            var sum = divs.Sum();\n            \n            if (sum % 2 == 1) {\n                return false;\n            }\n            \n            if (n % 2 == 1) {\n                var abundance = sum - 2 * n;\n                return abundance > 0 && abundance % 2 == 0;\n            }\n            \n            return IsPartSum(divs, sum / 2);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The first 220 Zumkeller numbers are:\");\n            int i = 2;\n            for (int count = 0; count < 220; i++) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,3} \", i);\n                    count++;\n                    if (count % 20 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,5} \", i);\n                    count++;\n                    if (count % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers which don't end in 5 are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (i % 10 != 5 && IsZumkeller(i)) {\n                    Console.Write(\"{0,7} \", i);\n                    count++;\n                    if (count % 8 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 251,
    "input": "Translate C++ to PHP:#include <algorithm>\n#include <cctype>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n\nbool endsWithIgnoreCase(const std::string& str, const std::string& suffix) {\n    const size_t n1 = str.length();\n    const size_t n2 = suffix.length();\n    if (n1 < n2)\n        return false;\n    return std::equal(str.begin() + (n1 - n2), str.end(), suffix.begin(),\n        [](char c1, char c2) {\n            return std::tolower(static_cast<unsigned char>(c1))\n                == std::tolower(static_cast<unsigned char>(c2));\n    });\n}\n\nbool filenameHasExtension(const std::string& filename,\n                          const std::vector<std::string>& extensions) {\n    return std::any_of(extensions.begin(), extensions.end(),\n        [&filename](const std::string& extension) {\n            return endsWithIgnoreCase(filename, \".\" + extension);\n    });\n}\n\nvoid test(const std::string& filename,\n          const std::vector<std::string>& extensions) {\n    std::cout << std::setw(20) << std::left << filename\n        << \": \" << std::boolalpha\n        << filenameHasExtension(filename, extensions) << '\\n';\n}\n\nint main() {\n    const std::vector<std::string> extensions{\"zip\", \"rar\", \"7z\",\n        \"gz\", \"archive\", \"A##\", \"tar.bz2\"};\n    test(\"MyData.a##\", extensions);\n    test(\"MyData.tar.Gz\", extensions);\n    test(\"MyData.gzip\", extensions);\n    test(\"MyData.7z.backup\", extensions);\n    test(\"MyData...\", extensions);\n    test(\"MyData\", extensions);\n    test(\"MyData_v1.0.tar.bz2\", extensions);\n    test(\"MyData_v1.0.bz2\", extensions);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "$allowed = ['zip', 'rar', '7z', 'gz', 'archive', 'A##', 'tar.bz2'];\n$lc_allowed = array_map('strtolower', $allowed);\n\n$tests = [\n    ['MyData.a##',true],\n    ['MyData.tar.Gz',true],\n    ['MyData.gzip',false],\n    ['MyData.7z.backup',false],\n    ['MyData...',false],\n    ['MyData',false],\n    ['archive.tar.gz', true]\n];\n\nforeach ($tests as $test) {\n    $ext = pathinfo($test[0], PATHINFO_EXTENSION);\n    if (in_array(strtolower($ext), $lc_allowed)) {\n        $result = 'true';\n    } else {\n        $result = 'false';\n    }\n    printf(\"%20s : %s \\n\", $test[0],$result);\n}\n",
    "input_language": "C++",
    "output_language": "PHP"
  },
  {
    "id": 252,
    "input": "Translate C to PHP:#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define strcomp(X, Y) strcasecmp(X, Y)\n\nstruct option\n{ const char *name, *value; \n  int flag; };\n\n\nstruct option updlist[] =\n{ { \"NEEDSPEELING\", NULL },\n  { \"SEEDSREMOVED\", \"\" },\n  { \"NUMBEROFBANANAS\", \"1024\" },\n  { \"NUMBEROFSTRAWBERRIES\", \"62000\" },\n  { NULL, NULL } };\n\nint output_opt(FILE *to, struct option *opt)\n{ if (opt->value == NULL)\n    return fprintf(to, \"; %s\\n\", opt->name);\n  else if (opt->value[0] == 0)\n    return fprintf(to, \"%s\\n\", opt->name);\n  else \n    return fprintf(to, \"%s %s\\n\", opt->name, opt->value); }\n\nint update(FILE *from, FILE *to, struct option *updlist) \n{ char line_buf[256], opt_name[128];\n  int i;\n  for (;;)\n  { size_t len, space_span, span_to_hash;\n    if (fgets(line_buf, sizeof line_buf, from) == NULL)\n      break;\n    len = strlen(line_buf);\n    space_span = strspn(line_buf, \"\\t \");\n    span_to_hash = strcspn(line_buf, \"#\");\n    if (space_span == span_to_hash)\n      goto line_out;\n    if (space_span == len)\n      goto line_out;\n    if ((sscanf(line_buf, \"; %127s\", opt_name) == 1) ||\n        (sscanf(line_buf, \"%127s\", opt_name) == 1))\n    { int flag = 0;\n      for (i = 0; updlist[i].name; i++)\n      { if (strcomp(updlist[i].name, opt_name) == 0)\n        { if (output_opt(to, &updlist[i]) < 0)\n            return -1;\n          updlist[i].flag = 1;\n          flag = 1; } }\n      if (flag == 0)\n        goto line_out; }\n    else\n  line_out: \n      if (fprintf(to, \"%s\", line_buf) < 0)\n        return -1;\n    continue; }\n  { for (i = 0; updlist[i].name; i++)\n    { if (!updlist[i].flag)\n        if (output_opt(to, &updlist[i]) < 0)\n          return -1; } }\n  return feof(from) ? 0 : -1; }\n\nint main(void)\n{ if (update(stdin, stdout, updlist) < 0)\n  { fprintf(stderr, \"failed\\n\");\n    return (EXIT_FAILURE); }\n  return 0; }\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\n\n$conf = file_get_contents('update-conf-file.txt');\n\n$conf = preg_replace('/^(needspeeling)(|\\s*\\S*)$/mi', '; $1', $conf);\n\n$conf = preg_replace('/^;?\\s*(seedsremoved)/mi', '$1', $conf);\n\n$conf = preg_replace('/^(numberofbananas)(|\\s*\\S*)$/mi', '$1 1024', $conf);\n\nif (preg_match('/^;?\\s*(numberofstrawberries)/mi', $conf, $matches)) {\n    $conf = preg_replace('/^(numberofstrawberries)(|\\s*\\S*)$/mi', '$1 62000', $conf);\n} else {\n    $conf .= 'NUMBEROFSTRAWBERRIES 62000' . PHP_EOL;\n}\n\necho $conf;\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 253,
    "input": "Translate PHP to Go:<?php\nforeach(scandir('.') as $fileName){\n    echo $fileName.\"\\n\";\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sort\"\n)\n\nfunc main() {\n\tf, err := os.Open(\".\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfiles, err := f.Readdirnames(0)\n\tf.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tsort.Strings(files)\n\tfor _, n := range files {\n\t\tfmt.Println(n)\n\t}\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 254,
    "input": "Translate C to Python:#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct node_t {\n    char *elem;\n    int length;\n    struct node_t *next;\n} node;\n\nnode *make_node(char *s) {\n    node *t = malloc(sizeof(node));\n    t->elem = s;\n    t->length = strlen(s);\n    t->next = NULL;\n    return t;\n}\n\nvoid append_node(node *head, node *elem) {\n    while (head->next != NULL) {\n        head = head->next;\n    }\n    head->next = elem;\n}\n\nvoid print_node(node *n) {\n    putc('[', stdout);\n    while (n != NULL) {\n        printf(\"`%s` \", n->elem);\n        n = n->next;\n    }\n    putc(']', stdout);\n}\n\nchar *lcs(node *list) {\n    int minLen = INT_MAX;\n    int i;\n\n    char *res;\n    node *ptr;\n\n    if (list == NULL) {\n        return \"\";\n    }\n    if (list->next == NULL) {\n        return list->elem;\n    }\n\n    for (ptr = list; ptr != NULL; ptr = ptr->next) {\n        minLen = min(minLen, ptr->length);\n    }\n    if (minLen == 0) {\n        return \"\";\n    }\n\n    res = \"\";\n    for (i = 1; i < minLen; i++) {\n        char *suffix = &list->elem[list->length - i];\n\n        for (ptr = list->next; ptr != NULL; ptr = ptr->next) {\n            char *e = &ptr->elem[ptr->length - i];\n            if (strcmp(suffix, e) != 0) {\n                return res;\n            }\n        }\n\n        res = suffix;\n    }\n\n    return res;\n}\n\nvoid test(node *n) {\n    print_node(n);\n    printf(\" -> `%s`\\n\", lcs(n));\n}\n\nvoid case1() {\n    node *n = make_node(\"baabababc\");\n    append_node(n, make_node(\"baabc\"));\n    append_node(n, make_node(\"bbbabc\"));\n    test(n);\n}\n\nvoid case2() {\n    node *n = make_node(\"baabababc\");\n    append_node(n, make_node(\"baabc\"));\n    append_node(n, make_node(\"bbbazc\"));\n    test(n);\n}\n\nvoid case3() {\n    node *n = make_node(\"Sunday\");\n    append_node(n, make_node(\"Monday\"));\n    append_node(n, make_node(\"Tuesday\"));\n    append_node(n, make_node(\"Wednesday\"));\n    append_node(n, make_node(\"Thursday\"));\n    append_node(n, make_node(\"Friday\"));\n    append_node(n, make_node(\"Saturday\"));\n    test(n);\n}\n\nvoid case4() {\n    node *n = make_node(\"longest\");\n    append_node(n, make_node(\"common\"));\n    append_node(n, make_node(\"suffix\"));\n    test(n);\n}\n\nvoid case5() {\n    node *n = make_node(\"suffix\");\n    test(n);\n}\n\nvoid case6() {\n    node *n = make_node(\"\");\n    test(n);\n}\n\nint main() {\n    case1();\n    case2();\n    case3();\n    case4();\n    case5();\n    case6();\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\nfrom itertools import takewhile\nfrom functools import reduce\n\n\n\ndef longestCommonSuffix(xs):\n    \n    def allSame(cs):\n        h = cs[0]\n        return all(h == c for c in cs[1:])\n\n    def firstCharPrepended(s, cs):\n        return cs[0] + s\n    return reduce(\n        firstCharPrepended,\n        takewhile(\n            allSame,\n            zip(*(reversed(x) for x in xs))\n        ),\n        ''\n    )\n\n\n\n\ndef main():\n    \n\n    samples = [\n        [\n            \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n            \"Thursday\", \"Friday\", \"Saturday\"\n        ], [\n            \"Sondag\", \"Maandag\", \"Dinsdag\", \"Woensdag\",\n            \"Donderdag\", \"Vrydag\", \"Saterdag\"\n        ]\n    ]\n    for xs in samples:\n        print(\n            longestCommonSuffix(xs)\n        )\n\n\n\nif __name__ == '__main__':\n    main()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 255,
    "input": "Translate C to Java:   #include<stdlib.h>\n   #include<ctype.h>\n   #include<stdio.h>\n   \n   int** oddMagicSquare(int n) {\n        if (n < 3 || n % 2 == 0)\n            return NULL;\n \n        int value = 0;\n        int squareSize = n * n;\n        int c = n / 2, r = 0,i;\n \n        int** result = (int**)malloc(n*sizeof(int*));\n\t\t\n\t\tfor(i=0;i<n;i++)\n\t\t\tresult[i] = (int*)malloc(n*sizeof(int));\n \n        while (++value <= squareSize) {\n            result[r][c] = value;\n            if (r == 0) {\n                if (c == n - 1) {\n                    r++;\n                } else {\n                    r = n - 1;\n                    c++;\n                }\n            } else if (c == n - 1) {\n                r--;\n                c = 0;\n            } else if (result[r - 1][c + 1] == 0) {\n                r--;\n                c++;\n            } else {\n                r++;\n            }\n        }\n        return result;\n    }\n \n    int** singlyEvenMagicSquare(int n) {\n        if (n < 6 || (n - 2) % 4 != 0)\n            return NULL;\n \n        int size = n * n;\n        int halfN = n / 2;\n        int subGridSize = size / 4, i;\n \n        int** subGrid = oddMagicSquare(halfN);\n        int gridFactors[] = {0, 2, 3, 1};\n        int** result = (int**)malloc(n*sizeof(int*));\n\t\t\n\t\tfor(i=0;i<n;i++)\n\t\t\tresult[i] = (int*)malloc(n*sizeof(int));\n \n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                int grid = (r / halfN) * 2 + (c / halfN);\n                result[r][c] = subGrid[r % halfN][c % halfN];\n                result[r][c] += gridFactors[grid] * subGridSize;\n            }\n        }\n \n        int nColsLeft = halfN / 2;\n        int nColsRight = nColsLeft - 1;\n \n        for (int r = 0; r < halfN; r++)\n            for (int c = 0; c < n; c++) {\n                if (c < nColsLeft || c >= n - nColsRight\n                        || (c == nColsLeft && r == nColsLeft)) {\n \n                    if (c == 0 && r == nColsLeft)\n                        continue;\n \n                    int tmp = result[r][c];\n                    result[r][c] = result[r + halfN][c];\n                    result[r + halfN][c] = tmp;\n                }\n            }\n \n        return result;\n    }\n\t\n\tint numDigits(int n){\n\t\tint count = 1;\n\t\t\n\t\twhile(n>=10){\n\t\t\tn /= 10;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tvoid printMagicSquare(int** square,int rows){\n\t\tint i,j;\n\t\t\n\t\tfor(i=0;i<rows;i++){\n\t\t\tfor(j=0;j<rows;j++){\n\t\t\t\tprintf(\"%*s%d\",rows - numDigits(square[i][j]),\"\",square[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\nMagic constant: %d \", (rows * rows + 1) * rows / 2);\n\t}\n\t\n\tint main(int argC,char* argV[])\n\t{\n\t\tint n;\n\t\t\n\t\tif(argC!=2||isdigit(argV[1][0])==0)\n\t\t\tprintf(\"Usage : %s <integer specifying rows in magic square>\",argV[0]);\n\t\telse{\n\t\t\tn = atoi(argV[1]);\n\t\t\tprintMagicSquare(singlyEvenMagicSquare(n),n);\n\t\t}\n\t\treturn 0;\n\t}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class MagicSquareSinglyEven {\n\n    public static void main(String[] args) {\n        int n = 6;\n        for (int[] row : magicSquareSinglyEven(n)) {\n            for (int x : row)\n                System.out.printf(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int n) {\n        if (n < 3 || n % 2 == 0)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int value = 0;\n        int gridSize = n * n;\n        int c = n / 2, r = 0;\n\n        int[][] result = new int[n][n];\n\n        while (++value <= gridSize) {\n            result[r][c] = value;\n            if (r == 0) {\n                if (c == n - 1) {\n                    r++;\n                } else {\n                    r = n - 1;\n                    c++;\n                }\n            } else if (c == n - 1) {\n                r--;\n                c = 0;\n            } else if (result[r - 1][c + 1] == 0) {\n                r--;\n                c++;\n            } else {\n                r++;\n            }\n        }\n        return result;\n    }\n\n    static int[][] magicSquareSinglyEven(final int n) {\n        if (n < 6 || (n - 2) % 4 != 0)\n            throw new IllegalArgumentException(\"base must be a positive \"\n                    + \"multiple of 4 plus 2\");\n\n        int size = n * n;\n        int halfN = n / 2;\n        int subSquareSize = size / 4;\n\n        int[][] subSquare = magicSquareOdd(halfN);\n        int[] quadrantFactors = {0, 2, 3, 1};\n        int[][] result = new int[n][n];\n\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                int quadrant = (r / halfN) * 2 + (c / halfN);\n                result[r][c] = subSquare[r % halfN][c % halfN];\n                result[r][c] += quadrantFactors[quadrant] * subSquareSize;\n            }\n        }\n\n        int nColsLeft = halfN / 2;\n        int nColsRight = nColsLeft - 1;\n\n        for (int r = 0; r < halfN; r++)\n            for (int c = 0; c < n; c++) {\n                if (c < nColsLeft || c >= n - nColsRight\n                        || (c == nColsLeft && r == nColsLeft)) {\n\n                    if (c == 0 && r == nColsLeft)\n                        continue;\n\n                    int tmp = result[r][c];\n                    result[r][c] = result[r + halfN][c];\n                    result[r + halfN][c] = tmp;\n                }\n            }\n\n        return result;\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 256,
    "input": "Translate C to Go:#include<graphics.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<time.h>\n\ntypedef struct{\n\tdouble x,y;\n}point;\n\nvoid pythagorasTree(point a,point b,int times){\n\t\n\tpoint c,d,e;\n\t\n\tc.x = b.x - (a.y -  b.y);\n\tc.y = b.y - (b.x - a.x);\n\t\n\td.x = a.x - (a.y -  b.y);\n\td.y = a.y - (b.x - a.x);\n\t\n\te.x = d.x +  ( b.x - a.x - (a.y -  b.y) ) / 2;\n\te.y = d.y -  ( b.x - a.x + a.y -  b.y ) / 2;\n\t\n\tif(times>0){\n\t\tsetcolor(rand()%15 + 1);\n\t\t\n\t\tline(a.x,a.y,b.x,b.y);\n\t\tline(c.x,c.y,b.x,b.y);\n\t\tline(c.x,c.y,d.x,d.y);\n\t\tline(a.x,a.y,d.x,d.y);\n\t\t\n\t\tpythagorasTree(d,e,times-1);\n\t\tpythagorasTree(e,c,times-1);\n\t}\n}\n\nint main(){\n\t\n\tpoint a,b;\n\tdouble side;\n\tint iter;\n\t\n\ttime_t t;\n\t\n\tprintf(\"Enter initial side length : \");\n\tscanf(\"%lf\",&side);\n\t\n\tprintf(\"Enter number of iterations : \");\n\tscanf(\"%d\",&iter);\n\t\n\ta.x = 6*side/2 - side/2;\n\ta.y = 4*side;\n\tb.x = 6*side/2 + side/2;\n\tb.y = 4*side;\n\t\n\tinitwindow(6*side,4*side,\"Pythagoras Tree ?\");\n\t\n\tsrand((unsigned)time(&t));\n\t\n\tpythagorasTree(a,b,iter);\n\t\n\tgetch();\n\t\n\tclosegraph();\n\t\n\treturn 0;\n\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n\t\"image/png\"\n\t\"log\"\n\t\"os\"\n)\n\nconst (\n\twidth, height = 800, 600\n\tmaxDepth      = 11                    \n\tcolFactor     = uint8(255 / maxDepth) \n\tfileName      = \"pythagorasTree.png\"\n)\n\nfunc main() {\n\timg := image.NewNRGBA(image.Rect(0, 0, width, height)) \n\tbg := image.NewUniform(color.RGBA{255, 255, 255, 255}) \n\tdraw.Draw(img, img.Bounds(), bg, image.ZP, draw.Src)   \n\n\tdrawSquares(340, 550, 460, 550, img, 0) \n\n\timgFile, err := os.Create(fileName)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer imgFile.Close()\n\tif err := png.Encode(imgFile, img); err != nil {\n\t\timgFile.Close()\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc drawSquares(ax, ay, bx, by int, img *image.NRGBA, depth int) {\n\tif depth > maxDepth {\n\t\treturn\n\t}\n\tdx, dy := bx-ax, ay-by\n\tx3, y3 := bx-dy, by-dx\n\tx4, y4 := ax-dy, ay-dx\n\tx5, y5 := x4+(dx-dy)/2, y4-(dx+dy)/2\n\tcol := color.RGBA{0, uint8(depth) * colFactor, 0, 255}\n\tdrawLine(ax, ay, bx, by, img, col)\n\tdrawLine(bx, by, x3, y3, img, col)\n\tdrawLine(x3, y3, x4, y4, img, col)\n\tdrawLine(x4, y4, ax, ay, img, col)\n\tdrawSquares(x4, y4, x5, y5, img, depth+1)\n\tdrawSquares(x5, y5, x3, y3, img, depth+1)\n}\n\nfunc drawLine(x0, y0, x1, y1 int, img *image.NRGBA, col color.RGBA) {\n\tdx := abs(x1 - x0)\n\tdy := abs(y1 - y0)\n\tvar sx, sy int = -1, -1\n\tif x0 < x1 {\n\t\tsx = 1\n\t}\n\tif y0 < y1 {\n\t\tsy = 1\n\t}\n\terr := dx - dy\n\tfor {\n\t\timg.Set(x0, y0, col)\n\t\tif x0 == x1 && y0 == y1 {\n\t\t\tbreak\n\t\t}\n\t\te2 := 2 * err\n\t\tif e2 > -dy {\n\t\t\terr -= dy\n\t\t\tx0 += sx\n\t\t}\n\t\tif e2 < dx {\n\t\t\terr += dx\n\t\t\ty0 += sy\n\t\t}\n\t}\n}\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 257,
    "input": "Translate C++ to Python:#include <string>\n#include <iostream>\n#include \"Poco/MD5Engine.h\"\n#include \"Poco/DigestStream.h\"\n\nusing Poco::DigestEngine ;\nusing Poco::MD5Engine ;\nusing Poco::DigestOutputStream ;\n\nint main( ) {\n   std::string myphrase ( \"The quick brown fox jumped over the lazy dog's back\" ) ;\n   MD5Engine md5 ;\n   DigestOutputStream outstr( md5 ) ;\n   outstr << myphrase ;\n   outstr.flush( ) ; \n   const DigestEngine::Digest& digest = md5.digest( ) ;\n   std::cout << myphrase << \" as a MD5 digest :\\n\" << DigestEngine::digestToHex( digest ) \n      << \" !\" << std::endl ;\n   return 0 ;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": ">>> import hashlib\n>>> \n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 258,
    "input": "Translate Python to Go:\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isBackPrime(n):\n    if not isPrime(n):\n        return False\n    m = 0\n    while n:\n        m *= 10\n        m += n % 10\n        n //= 10\n    return isPrime(m)\n\nif __name__ == '__main__':\n    for n in range(2, 499):\n        if isBackPrime(n):\n            print(n, end=' ');\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc sieve(limit int) []bool {\n    limit++\n    \n    c := make([]bool, limit) \n    c[0] = true\n    c[1] = true\n    for i := 4; i < limit; i += 2 {\n        c[i] = true\n    }\n    p := 3 \n    for {\n        p2 := p * p\n        if p2 >= limit {\n            break\n        }\n        for i := p2; i < limit; i += 2 * p {\n            c[i] = true\n        }\n        for {\n            p += 2\n            if !c[p] {\n                break\n            }\n        }\n    }\n    return c\n}\n\nfunc reversed(n int) int {\n    rev := 0\n    for n > 0 {\n        rev = rev*10 + n%10\n        n /= 10\n    }\n    return rev\n}\n\nfunc main() {\n    c := sieve(999)\n    reversedPrimes := []int{2}\n    for i := 3; i < 500; i += 2 {\n        if !c[i] && !c[reversed(i)] {\n            reversedPrimes = append(reversedPrimes, i)\n        }\n    }\n    fmt.Println(\"Primes under 500 which are also primes when the digits are reversed:\")\n    for i, p := range reversedPrimes {\n        fmt.Printf(\"%5d\", p)\n        if (i+1) % 10 == 0 {\n            fmt.Println()\n        }\n    }\n    fmt.Printf(\"\\n\\n%d such primes found.\\n\", len(reversedPrimes))\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 259,
    "input": "Translate PHP to Python:<?php\n\n$max = 20;\n$factor = array(3 => 'Fizz', 5 => 'Buzz', 7 => 'Jazz');\n\nfor ($i = 1 ; $i <= $max ; $i++) {\n    $matched = false;\n    foreach ($factor AS $number => $word) {\n        if ($i % $number == 0) {\n            echo $word;\n            $matched = true;\n        }\n    }\n    echo ($matched ? '' : $i), PHP_EOL;\n}\n\n?>\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def genfizzbuzz(factorwords, numbers):\n    \n    factorwords.sort(key=lambda factor_and_word: factor_and_word[0])\n    lines = []\n    for num in numbers:\n        words = ''.join(word for factor, word in factorwords if (num % factor) == 0)\n        lines.append(words if words else str(num))\n    return '\\n'.join(lines)\n\nif __name__ == '__main__':\n    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 260,
    "input": "Translate C++ to Go:#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <string>\n\nunsigned int reverse(unsigned int base, unsigned int n) {\n    unsigned int rev = 0;\n    for (; n > 0; n /= base)\n        rev = rev * base + (n % base);\n    return rev;\n}\n\nclass palindrome_generator {\npublic:\n    explicit palindrome_generator(unsigned int base)\n        : base_(base), upper_(base) {}\n    unsigned int next_palindrome();\n\nprivate:\n    unsigned int base_;\n    unsigned int lower_ = 1;\n    unsigned int upper_;\n    unsigned int next_ = 0;\n    bool even_ = false;\n};\n\nunsigned int palindrome_generator::next_palindrome() {\n    ++next_;\n    if (next_ == upper_) {\n        if (even_) {\n            lower_ = upper_;\n            upper_ *= base_;\n        }\n        next_ = lower_;\n        even_ = !even_;\n    }\n    return even_ ? next_ * upper_ + reverse(base_, next_)\n                 : next_ * lower_ + reverse(base_, next_ / base_);\n}\n\nbool is_prime(unsigned int n) {\n    if (n < 2)\n        return false;\n    if (n % 2 == 0)\n        return n == 2;\n    if (n % 3 == 0)\n        return n == 3;\n    for (unsigned int p = 5; p * p <= n; p += 4) {\n        if (n % p == 0)\n            return false;\n        p += 2;\n        if (n % p == 0)\n            return false;\n    }\n    return true;\n}\n\nstd::string to_string(unsigned int base, unsigned int n) {\n    assert(base <= 36);\n    static constexpr char digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    std::string str;\n    for (; n != 0; n /= base)\n        str += digits[n % base];\n    std::reverse(str.begin(), str.end());\n    return str;\n}\n\nvoid print_palindromic_primes(unsigned int base, unsigned int limit) {\n    auto width =\n        static_cast<unsigned int>(std::ceil(std::log(limit) / std::log(base)));\n    unsigned int count = 0;\n    auto columns = 80 / (width + 1);\n    std::cout << \"Base \" << base << \" palindromic primes less than \" << limit\n              << \":\\n\";\n    palindrome_generator pgen(base);\n    unsigned int palindrome;\n    while ((palindrome = pgen.next_palindrome()) < limit) {\n        if (is_prime(palindrome)) {\n            ++count;\n            std::cout << std::setw(width) << to_string(base, palindrome)\n                      << (count % columns == 0 ? '\\n' : ' ');\n        }\n    }\n    if (count % columns != 0)\n        std::cout << '\\n';\n    std::cout << \"Count: \" << count << '\\n';\n}\n\nvoid count_palindromic_primes(unsigned int base, unsigned int limit) {\n    unsigned int count = 0;\n    palindrome_generator pgen(base);\n    unsigned int palindrome;\n    while ((palindrome = pgen.next_palindrome()) < limit)\n        if (is_prime(palindrome))\n            ++count;\n    std::cout << \"Number of base \" << base << \" palindromic primes less than \"\n              << limit << \": \" << count << '\\n';\n}\n\nint main() {\n    print_palindromic_primes(10, 1000);\n    std::cout << '\\n';\n    print_palindromic_primes(10, 100000);\n    std::cout << '\\n';\n    count_palindromic_primes(10, 1000000000);\n    std::cout << '\\n';\n    print_palindromic_primes(16, 500);\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nfunc reversed(n int) int {\n    rev := 0\n    for n > 0 {\n        rev = rev*10 + n%10\n        n /= 10\n    }\n    return rev\n}\n\nfunc main() {\n    primes := rcu.Primes(99999)\n    var pals []int\n    for _, p := range primes {\n        if p == reversed(p) {\n            pals = append(pals, p)\n        }\n    }\n    fmt.Println(\"Palindromic primes under 1,000:\")\n    var smallPals, bigPals []int\n    for _, p := range pals {\n        if p < 1000 {\n            smallPals = append(smallPals, p)\n        } else {\n            bigPals = append(bigPals, p)\n        }\n    }\n    rcu.PrintTable(smallPals, 10, 3, false)\n    fmt.Println()\n    fmt.Println(len(smallPals), \"such primes found.\")\n\n    fmt.Println(\"\\nAdditional palindromic primes under 100,000:\")\n    rcu.PrintTable(bigPals, 10, 6, true)\n    fmt.Println()\n    fmt.Println(len(bigPals), \"such primes found,\", len(pals), \"in all.\")\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 261,
    "input": "Translate C++ to Go:#include <iostream>\n#include <string>\n#include <cstdint>\n\ntypedef std::uint64_t integer;\n\nstruct number_names {\n    const char* cardinal;\n    const char* ordinal;\n};\n\nconst number_names small[] = {\n    { \"zero\", \"zeroth\" }, { \"one\", \"first\" }, { \"two\", \"second\" },\n    { \"three\", \"third\" }, { \"four\", \"fourth\" }, { \"five\", \"fifth\" },\n    { \"six\", \"sixth\" }, { \"seven\", \"seventh\" }, { \"eight\", \"eighth\" },\n    { \"nine\", \"ninth\" }, { \"ten\", \"tenth\" }, { \"eleven\", \"eleventh\" },\n    { \"twelve\", \"twelfth\" }, { \"thirteen\", \"thirteenth\" },\n    { \"fourteen\", \"fourteenth\" }, { \"fifteen\", \"fifteenth\" },\n    { \"sixteen\", \"sixteenth\" }, { \"seventeen\", \"seventeenth\" },\n    { \"eighteen\", \"eighteenth\" }, { \"nineteen\", \"nineteenth\" }\n};\n\nconst number_names tens[] = {\n    { \"twenty\", \"twentieth\" }, { \"thirty\", \"thirtieth\" },\n    { \"forty\", \"fortieth\" }, { \"fifty\", \"fiftieth\" },\n    { \"sixty\", \"sixtieth\" }, { \"seventy\", \"seventieth\" },\n    { \"eighty\", \"eightieth\" }, { \"ninety\", \"ninetieth\" }\n};\n\nstruct named_number {\n    const char* cardinal;\n    const char* ordinal;\n    integer number;\n};\n\nconst named_number named_numbers[] = {\n    { \"hundred\", \"hundredth\", 100 },\n    { \"thousand\", \"thousandth\", 1000 },\n    { \"million\", \"millionth\", 1000000 },\n    { \"billion\", \"billionth\", 1000000000 },\n    { \"trillion\", \"trillionth\", 1000000000000 },\n    { \"quadrillion\", \"quadrillionth\", 1000000000000000ULL },\n    { \"quintillion\", \"quintillionth\", 1000000000000000000ULL }\n};\n\nconst char* get_name(const number_names& n, bool ordinal) {\n    return ordinal ? n.ordinal : n.cardinal;\n}\n\nconst char* get_name(const named_number& n, bool ordinal) {\n    return ordinal ? n.ordinal : n.cardinal;\n}\n\nconst named_number& get_named_number(integer n) {\n    constexpr size_t names_len = std::size(named_numbers);\n    for (size_t i = 0; i + 1 < names_len; ++i) {\n        if (n < named_numbers[i + 1].number)\n            return named_numbers[i];\n    }\n    return named_numbers[names_len - 1];\n}\n\nstd::string number_name(integer n, bool ordinal) {\n    std::string result;\n    if (n < 20)\n        result = get_name(small[n], ordinal);\n    else if (n < 100) {\n        if (n % 10 == 0) {\n            result = get_name(tens[n/10 - 2], ordinal);\n        } else {\n            result = get_name(tens[n/10 - 2], false);\n            result += \"-\";\n            result += get_name(small[n % 10], ordinal);\n        }\n    } else {\n        const named_number& num = get_named_number(n);\n        integer p = num.number;\n        result = number_name(n/p, false);\n        result += \" \";\n        if (n % p == 0) {\n            result += get_name(num, ordinal);\n        } else {\n            result += get_name(num, false);\n            result += \" \";\n            result += number_name(n % p, ordinal);\n        }\n    }\n    return result;\n}\n\nvoid test_ordinal(integer n) {\n    std::cout << n << \": \" << number_name(n, true) << '\\n';\n}\n\nint main() {\n    test_ordinal(1);\n    test_ordinal(2);\n    test_ordinal(3);\n    test_ordinal(4);\n    test_ordinal(5);\n    test_ordinal(11);\n    test_ordinal(15);\n    test_ordinal(21);\n    test_ordinal(42);\n    test_ordinal(65);\n    test_ordinal(98);\n    test_ordinal(100);\n    test_ordinal(101);\n    test_ordinal(272);\n    test_ordinal(300);\n    test_ordinal(750);\n    test_ordinal(23456);\n    test_ordinal(7891233);\n    test_ordinal(8007006005004003LL);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "import (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfor _, n := range []int64{\n\t\t1, 2, 3, 4, 5, 11, 65, 100, 101, 272, 23456, 8007006005004003,\n\t} {\n\t\tfmt.Println(sayOrdinal(n))\n\t}\n}\n\nvar irregularOrdinals = map[string]string{\n\t\"one\":    \"first\",\n\t\"two\":    \"second\",\n\t\"three\":  \"third\",\n\t\"five\":   \"fifth\",\n\t\"eight\":  \"eighth\",\n\t\"nine\":   \"ninth\",\n\t\"twelve\": \"twelfth\",\n}\n\nfunc sayOrdinal(n int64) string {\n\ts := say(n)\n\ti := strings.LastIndexAny(s, \" -\")\n\ti++\n\t\n\t\n\t\n\t\n\tif x, ok := irregularOrdinals[s[i:]]; ok {\n\t\ts = s[:i] + x\n\t} else if s[len(s)-1] == 'y' {\n\t\ts = s[:i] + s[i:len(s)-1] + \"ieth\"\n\t} else {\n\t\ts = s[:i] + s[i:] + \"th\"\n\t}\n\treturn s\n}\n\n\n\nvar small = [...]string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\",\n\t\"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\",\n\t\"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"}\nvar tens = [...]string{\"\", \"\", \"twenty\", \"thirty\", \"forty\",\n\t\"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"}\nvar illions = [...]string{\"\", \" thousand\", \" million\", \" billion\",\n\t\" trillion\", \" quadrillion\", \" quintillion\"}\n\nfunc say(n int64) string {\n\tvar t string\n\tif n < 0 {\n\t\tt = \"negative \"\n\t\t\n\t\tn = -n\n\t}\n\tswitch {\n\tcase n < 20:\n\t\tt += small[n]\n\tcase n < 100:\n\t\tt += tens[n/10]\n\t\ts := n % 10\n\t\tif s > 0 {\n\t\t\tt += \"-\" + small[s]\n\t\t}\n\tcase n < 1000:\n\t\tt += small[n/100] + \" hundred\"\n\t\ts := n % 100\n\t\tif s > 0 {\n\t\t\tt += \" \" + say(s)\n\t\t}\n\tdefault:\n\t\t\n\t\tsx := \"\"\n\t\tfor i := 0; n > 0; i++ {\n\t\t\tp := n % 1000\n\t\t\tn /= 1000\n\t\t\tif p > 0 {\n\t\t\t\tix := say(p) + illions[i]\n\t\t\t\tif sx != \"\" {\n\t\t\t\t\tix += \" \" + sx\n\t\t\t\t}\n\t\t\t\tsx = ix\n\t\t\t}\n\t\t}\n\t\tt += sx\n\t}\n\treturn t\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  },
  {
    "id": 262,
    "input": "Translate C to Java:int meaning_of_life();\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 263,
    "input": "Translate Python to Go:def load_ast()\n    line = readline()\n    \n    line_list = tokenize the line, respecting double quotes\n\n    text = line_list[0] \n\n    if text == \";\"   \n        return NULL\n\n    node_type = text \n\n    \n    \n    \n    if len(line_list) > 1\n        return make_leaf(node_type, line_list[1])\n\n    left = load_ast()\n    right = load_ast()\n    return make_node(node_type, left, right)\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype NodeType int\n\nconst (\n    ndIdent NodeType = iota\n    ndString\n    ndInteger\n    ndSequence\n    ndIf\n    ndPrtc\n    ndPrts\n    ndPrti\n    ndWhile\n    ndAssign\n    ndNegate\n    ndNot\n    ndMul\n    ndDiv\n    ndMod\n    ndAdd\n    ndSub\n    ndLss\n    ndLeq\n    ndGtr\n    ndGeq\n    ndEql\n    ndNeq\n    ndAnd\n    ndOr\n)\n\ntype Tree struct {\n    nodeType NodeType\n    left     *Tree\n    right    *Tree\n    value    int\n}\n\n\ntype atr struct {\n    enumText string\n    nodeType NodeType\n}\n\nvar atrs = []atr{\n    {\"Identifier\", ndIdent},\n    {\"String\", ndString},\n    {\"Integer\", ndInteger},\n    {\"Sequence\", ndSequence},\n    {\"If\", ndIf},\n    {\"Prtc\", ndPrtc},\n    {\"Prts\", ndPrts},\n    {\"Prti\", ndPrti},\n    {\"While\", ndWhile},\n    {\"Assign\", ndAssign},\n    {\"Negate\", ndNegate},\n    {\"Not\", ndNot},\n    {\"Multiply\", ndMul},\n    {\"Divide\", ndDiv},\n    {\"Mod\", ndMod},\n    {\"Add\", ndAdd},\n    {\"Subtract\", ndSub},\n    {\"Less\", ndLss},\n    {\"LessEqual\", ndLeq},\n    {\"Greater\", ndGtr},\n    {\"GreaterEqual\", ndGeq},\n    {\"Equal\", ndEql},\n    {\"NotEqual\", ndNeq},\n    {\"And\", ndAnd},\n    {\"Or\", ndOr},\n}\n\nvar (\n    stringPool   []string\n    globalNames  []string\n    globalValues = make(map[int]int)\n)\n\nvar (\n    err     error\n    scanner *bufio.Scanner\n)\n\nfunc reportError(msg string) {\n    log.Fatalf(\"error : %s\\n\", msg)\n}\n\nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc btoi(b bool) int {\n    if b {\n        return 1\n    }\n    return 0\n}\n\nfunc itob(i int) bool {\n    if i == 0 {\n        return false\n    }\n    return true\n}\n\nfunc makeNode(nodeType NodeType, left *Tree, right *Tree) *Tree {\n    return &Tree{nodeType, left, right, 0}\n}\n\nfunc makeLeaf(nodeType NodeType, value int) *Tree {\n    return &Tree{nodeType, nil, nil, value}\n}\n\nfunc interp(x *Tree) int { \n    if x == nil {\n        return 0\n    }\n    switch x.nodeType {\n    case ndInteger:\n        return x.value\n    case ndIdent:\n        return globalValues[x.value]\n    case ndString:\n        return x.value\n    case ndAssign:\n        n := interp(x.right)\n        globalValues[x.left.value] = n\n        return n\n    case ndAdd:\n        return interp(x.left) + interp(x.right)\n    case ndSub:\n        return interp(x.left) - interp(x.right)\n    case ndMul:\n        return interp(x.left) * interp(x.right)\n    case ndDiv:\n        return interp(x.left) / interp(x.right)\n    case ndMod:\n        return interp(x.left) % interp(x.right)\n    case ndLss:\n        return btoi(interp(x.left) < interp(x.right))\n    case ndGtr:\n        return btoi(interp(x.left) > interp(x.right))\n    case ndLeq:\n        return btoi(interp(x.left) <= interp(x.right))\n    case ndEql:\n        return btoi(interp(x.left) == interp(x.right))\n    case ndNeq:\n        return btoi(interp(x.left) != interp(x.right))\n    case ndAnd:\n        return btoi(itob(interp(x.left)) && itob(interp(x.right)))\n    case ndOr:\n        return btoi(itob(interp(x.left)) || itob(interp(x.right)))\n    case ndNegate:\n        return -interp(x.left)\n    case ndNot:\n        if interp(x.left) == 0 {\n            return 1\n        }\n        return 0\n    case ndIf:\n        if interp(x.left) != 0 {\n            interp(x.right.left)\n        } else {\n            interp(x.right.right)\n        }\n        return 0\n    case ndWhile:\n        for interp(x.left) != 0 {\n            interp(x.right)\n        }\n        return 0\n    case ndPrtc:\n        fmt.Printf(\"%c\", interp(x.left))\n        return 0\n    case ndPrti:\n        fmt.Printf(\"%d\", interp(x.left))\n        return 0\n    case ndPrts:\n        fmt.Print(stringPool[interp(x.left)])\n        return 0\n    case ndSequence:\n        interp(x.left)\n        interp(x.right)\n        return 0\n    default:\n        reportError(fmt.Sprintf(\"interp: unknown tree type %d\\n\", x.nodeType))\n    }\n    return 0\n}\n\nfunc getEnumValue(name string) NodeType {\n    for _, atr := range atrs {\n        if atr.enumText == name {\n            return atr.nodeType\n        }\n    }\n    reportError(fmt.Sprintf(\"Unknown token %s\\n\", name))\n    return -1\n}\n\nfunc fetchStringOffset(s string) int {\n    var d strings.Builder\n    s = s[1 : len(s)-1]\n    for i := 0; i < len(s); i++ {\n        if s[i] == '\\\\' && (i+1) < len(s) {\n            if s[i+1] == 'n' {\n                d.WriteByte('\\n')\n                i++\n            } else if s[i+1] == '\\\\' {\n                d.WriteByte('\\\\')\n                i++\n            }\n        } else {\n            d.WriteByte(s[i])\n        }\n    }\n    s = d.String()\n    for i := 0; i < len(stringPool); i++ {\n        if s == stringPool[i] {\n            return i\n        }\n    }\n    stringPool = append(stringPool, s)\n    return len(stringPool) - 1\n}\n\nfunc fetchVarOffset(name string) int {\n    for i := 0; i < len(globalNames); i++ {\n        if globalNames[i] == name {\n            return i\n        }\n    }\n    globalNames = append(globalNames, name)\n    return len(globalNames) - 1\n}\n\nfunc loadAst() *Tree {\n    var nodeType NodeType\n    var s string\n    if scanner.Scan() {\n        line := strings.TrimRight(scanner.Text(), \" \\t\")\n        tokens := strings.Fields(line)\n        first := tokens[0]\n        if first[0] == ';' {\n            return nil\n        }\n        nodeType = getEnumValue(first)\n        le := len(tokens)\n        if le == 2 {\n            s = tokens[1]\n        } else if le > 2 {\n            idx := strings.Index(line, `\"`)\n            s = line[idx:]\n        }\n    }\n    check(scanner.Err())\n    if s != \"\" {\n        var n int\n        switch nodeType {\n        case ndIdent:\n            n = fetchVarOffset(s)\n        case ndInteger:\n            n, err = strconv.Atoi(s)\n            check(err)\n        case ndString:\n            n = fetchStringOffset(s)\n        default:\n            reportError(fmt.Sprintf(\"Unknown node type: %s\\n\", s))\n        }\n        return makeLeaf(nodeType, n)\n    }    \n    left := loadAst()\n    right := loadAst()\n    return makeNode(nodeType, left, right)\n}\n\nfunc main() {\n    ast, err := os.Open(\"ast.txt\")\n    check(err)\n    defer ast.Close()\n    scanner = bufio.NewScanner(ast)\n    x := loadAst()\n    interp(x)\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 264,
    "input": "Translate Python to C#:class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 265,
    "input": "Translate Java to Python:import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImageProcessing {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        BufferedImage img = ImageIO.read(new File(\"example.png\"));\n\n        BufferedImage bwimg = toBlackAndWhite(img);\n\n        ImageIO.write(bwimg, \"png\", new File(\"example-bw.png\"));\n    }\n\n    private static int luminance(int rgb) {\n        int r = (rgb >> 16) & 0xFF;\n        int g = (rgb >> 8) & 0xFF;\n        int b = rgb & 0xFF;\n        return (r + b + g) / 3;\n    }\n\n    private static BufferedImage toBlackAndWhite(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = computeHistogram(img);\n\n        int median = getMedian(width * height, histo);\n\n        BufferedImage bwimg = new BufferedImage(width, height, img.getType());\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                bwimg.setRGB(x, y, luminance(img.getRGB(x, y)) >= median ? 0xFFFFFFFF : 0xFF000000);\n            }\n        }\n        return bwimg;\n    }\n\n    private static int[] computeHistogram(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = new int[256];\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                histo[luminance(img.getRGB(x, y))]++;\n            }\n        }\n        return histo;\n    }\n\n    private static int getMedian(int total, int[] histo) {\n        int median = 0;\n        int sum = 0;\n        for (int i = 0; i < histo.length && sum + histo[i] < total / 2; i++) {\n            sum += histo[i];\n            median++;\n        }\n        return median;\n    }\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from PIL import Image\n\n\nimage = Image.open(\"lena.jpg\")\n\nwidth, height = image.size\n\namount = width * height\n\n\ntotal = 0\n\nbw_image = Image.new('L', (width, height), 0)\n\nbm_image = Image.new('1', (width, height), 0)\n\nfor h in range(0, height):\n    for w in range(0, width):\n        r, g, b = image.getpixel((w, h))\n\n        greyscale = int((r + g + b) / 3)\n        total += greyscale\n\n        bw_image.putpixel((w, h), gray_scale)\n\n\navg = total / amount\n\nblack = 0\nwhite = 1\n\nfor h in range(0, height):\n    for w in range(0, width):\n        v = bw_image.getpixel((w, h))\n\n        if v >= avg:\n            bm_image.putpixel((w, h), white)\n        else:\n            bm_image.putpixel((w, h), black)\n\nbw_image.show()\nbm_image.show()\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 266,
    "input": "Translate PHP to Python:<?php\nclass SimpleClass {\n    private $answer = \"hello\\\"world\\nforever :)\";\n}\n \n$class = new SimpleClass;\nob_start();\n\n\n\nvar_export($class);\n$class_content = ob_get_clean();\n \n$class_content = preg_replace('\"^SimpleClass::__set_state\\(\"', 'return ', $class_content);\n$class_content = preg_replace('\"\\)$\"', ';', $class_content);\n\n$new_class = eval($class_content);\necho $new_class['answer'];\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": ">>> class MyClassName:\n\t__private = 123\n\tnon_private = __private * 2\n\n\t\n>>> mine = MyClassName()\n>>> mine.non_private\n246\n>>> mine.__private\nTraceback (most recent call last):\n  File \"<pyshell\n    mine.__private\nAttributeError: 'MyClassName' object has no attribute '__private'\n>>> mine._MyClassName__private\n123\n>>>\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 267,
    "input": "Translate C++ to Python:#include <fstream>\nusing namespace std;\n\nint main()\n{\n    ofstream file(\"new.txt\");\n    file << \"this is a string\";\n    file.close();\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "with open(filename, 'w') as f:\n    f.write(data)\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 268,
    "input": "Translate Java to Go:import java.util.Scanner;\n\npublic class Pigdice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint players = 0;\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tSystem.out.println(\"Hello, welcome to Pig Dice the game! How many players? \");\n\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\tif(nextInt > 0) {\n\t\t\t\t\tplayers = nextInt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"That wasn't an integer. Try again. \\n\");\n\t\t\t\tscan.next();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Alright, starting with \" + players + \" players. \\n\");\n\t\t\n\t\t\n\t\tplay(players, scan);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tpublic static void play(int group, Scanner scan) {\n\t\t\n\t\tfinal int STRATEGIES = 5;\n\t\t\n\t\t\n\t\tDice dice = new Dice();\n\t\t\n\t\t\n\t\tPlayer[] players = new Player[group];\n\t\tfor(int count = 0; count < group; count++) {\n\t\t\tplayers[count] = new Player(count);\n\t\t\tSystem.out.println(\"Player \" + players[count].getNumber() + \"  is alive! \");\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(\"Each strategy is numbered 0 - \" + (STRATEGIES - 1) + \". They are as follows: \");\n\t\tSystem.out.println(\">> Enter '0' for a human player. \");\n\t\tSystem.out.println(\">> Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.\");\n\t\tSystem.out.println(\">> Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold. \");\n\t\tSystem.out.println(\">> Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls. \");\n\t\tSystem.out.println(\">> Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll. \");\n\t\t\n\t\t\n\t\tfor(Player player : players) {\n\t\t\tSystem.out.println(\"\\nWhat strategy would you like player \" + player.getNumber() + \" to use? \");\n\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\t\tif (nextInt < Strategy.STRATEGIES.length) {\n\t\t\t\t\t\tplayer.setStrategy(Strategy.STRATEGIES[nextInt]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"That wasn't an option. Try again. \");\n\t\t\t\t\tscan.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint max = 0;\n\t\twhile(max < 100) {\n\t\t\t\n\t\t\t\n\t\t\tfor(Player player : players) {\n\t\t\t\tSystem.out.println(\">> Beginning Player \" + player.getNumber() + \"'s turn. \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setMax(max);\n\t\t\t\twhile(true) {\n\t\t\t\t\tMove choice = player.choose();\n\t\t\t\t\tif(choice == Move.ROLL) {\n\t\t\t\t\t\tint roll = dice.roll();\n\t\t\t\t\t\tSystem.out.println(\"   A \" + roll + \" was rolled. \");\n\t\t\t\t\t\tplayer.setTurnPoints(player.getTurnPoints() + roll);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tplayer.incIter();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(roll == 1) {\n\t\t\t\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"   The player has held. \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.addPoints(player.getTurnPoints());\n\t\t\t\tSystem.out.println(\"   Player \" + player.getNumber() + \"'s turn is now over. Their total is \" + player.getPoints() + \". \\n\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.resetIter();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max < player.getPoints()) {\n\t\t\t\t\tmax = player.getPoints();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max >= 100) {\n\t\t\t\t\tSystem.out.println(\"Player \" + player.getNumber() + \" wins with \" + max + \" points! End scores: \");\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(Player p : players) {\n\t\t\t\t\t\tSystem.out.println(\"Player \" + p.getNumber() + \" had \" + p.getPoints() + \" points. \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package pig\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype (\n\tPlayerID   int\n\tMessageID  int\n\tStrategyID int\n\n\tPigGameData struct {\n\t\tplayer        PlayerID\n\t\tturnCount     int\n\t\tturnRollCount int\n\t\tturnScore     int\n\t\tlastRoll      int\n\t\tscores        [2]int\n\t\tverbose       bool\n\t}\n)\n\nconst (\n\t\n\tgameOver = iota\n\tpiggedOut\n\trolls\n\tpointSpending\n\tholds\n\tturn\n\tgameOverSummary\n\t\n\tplayer1  = PlayerID(0)\n\tplayer2  = PlayerID(1)\n\tnoPlayer = PlayerID(-1)\n\t\n\tmaxScore = 100\n\t\n\tscoreChaseStrat = iota\n\trollCountStrat\n)\n\n\nfunc pluralS(n int) string {\n\tif n != 1 {\n\t\treturn \"s\"\n\t}\n\treturn \"\"\n}\n\n\nfunc New() *PigGameData {\n\treturn &PigGameData{0, 0, 0, 0, 0, [2]int{0, 0}, false}\n}\n\n\nfunc (pg *PigGameData) statusMessage(id MessageID) string {\n\tvar msg string\n\tswitch id {\n\tcase gameOver:\n\t\tmsg = fmt.Sprintf(\"Game is over after %d turns\", pg.turnCount)\n\tcase piggedOut:\n\t\tmsg = fmt.Sprintf(\"    Pigged out after %d roll%s\", pg.turnRollCount, pluralS(pg.turnRollCount))\n\tcase rolls:\n\t\tmsg = fmt.Sprintf(\"    Rolls %d\", pg.lastRoll)\n\tcase pointSpending:\n\t\tmsg = fmt.Sprintf(\"    %d point%s pending\", pg.turnScore, pluralS(pg.turnScore))\n\tcase holds:\n\t\tmsg = fmt.Sprintf(\"    Holds after %d turns, adding %d points for a total of %d\", pg.turnRollCount, pg.turnScore, pg.PlayerScore(noPlayer))\n\tcase turn:\n\t\tmsg = fmt.Sprintf(\"Player %d's turn:\", pg.player+1)\n\tcase gameOverSummary:\n\t\tmsg = fmt.Sprintf(\"Game over after %d turns\\n player 1 %d\\n player 2 %d\\n\", pg.turnCount, pg.PlayerScore(player1), pg.PlayerScore(player2))\n\t}\n\treturn msg\n}\n\n\nfunc (pg *PigGameData) PrintStatus(id MessageID) {\n\tif pg.verbose {\n\t\tfmt.Println(pg.statusMessage(id))\n\t}\n}\n\n\nfunc (pg *PigGameData) Play(id StrategyID) (keepPlaying bool) {\n\tif pg.GameOver() {\n\t\tpg.PrintStatus(gameOver)\n\t\treturn false\n\t}\n\n\tif pg.turnCount == 0 {\n\t\tpg.player = player2\n\t\tpg.NextPlayer()\n\t}\n\n\tpg.lastRoll = rand.Intn(6) + 1\n\tpg.PrintStatus(rolls)\n\tpg.turnRollCount++\n\tif pg.lastRoll == 1 {\n\t\tpg.PrintStatus(piggedOut)\n\t\tpg.NextPlayer()\n\t} else {\n\t\tpg.turnScore += pg.lastRoll\n\t\tpg.PrintStatus(pointSpending)\n\t\tsuccess := false\n\t\tswitch id {\n\t\tcase scoreChaseStrat:\n\t\t\tsuccess = pg.scoreChaseStrategy()\n\t\tcase rollCountStrat:\n\t\t\tsuccess = pg.rollCountStrategy()\n\t\t}\n\t\tif success {\n\t\t\tpg.Hold()\n\t\t\tpg.NextPlayer()\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc (pg *PigGameData) PlayerScore(id PlayerID) int {\n\tif id == noPlayer {\n\t\treturn pg.scores[pg.player]\n\t}\n\treturn pg.scores[id]\n}\n\n\nfunc (pg *PigGameData) GameOver() bool {\n\treturn pg.scores[player1] >= maxScore || pg.scores[player2] >= maxScore\n}\n\n\nfunc (pg *PigGameData) Winner() PlayerID {\n\tfor index, score := range pg.scores {\n\t\tif score >= maxScore {\n\t\t\treturn PlayerID(index)\n\t\t}\n\t}\n\treturn noPlayer\n}\n\n\nfunc (pg *PigGameData) otherPlayer() PlayerID {\n\t\n\treturn 1 - pg.player\n}\n\nfunc (pg *PigGameData) Hold() {\n\tpg.scores[pg.player] += pg.turnScore\n\tpg.PrintStatus(holds)\n\tpg.turnRollCount, pg.turnScore = 0, 0\n}\n\nfunc (pg *PigGameData) NextPlayer() {\n\tpg.turnCount++\n\tpg.turnRollCount, pg.turnScore = 0, 0\n\tpg.player = pg.otherPlayer()\n\tpg.PrintStatus(turn)\n}\n\nfunc (pg *PigGameData) rollCountStrategy() bool {\n\treturn pg.turnRollCount >= 3\n}\n\nfunc (pg *PigGameData) scoreChaseStrategy() bool {\n\tmyScore := pg.PlayerScore(pg.player)\n\totherScore := pg.PlayerScore(pg.otherPlayer())\n\tmyPendingScore := pg.turnScore + myScore\n\treturn myPendingScore >= maxScore || myPendingScore > otherScore || pg.turnRollCount >= 5\n}\n\n\nfunc main() {\n\t\n\trand.Seed(time.Now().UnixNano())\n\n\t\n\tpg := New()\n\tpg.verbose = true\n\tstrategies := [2]StrategyID{scoreChaseStrat, rollCountStrat}\n\n\t\n\tfor !pg.GameOver() {\n\t\tpg.Play(strategies[pg.player])\n\t}\n\tpg.PrintStatus(gameOverSummary)\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 269,
    "input": "Translate C to Python:#include <stdio.h>\n\nvoid transpose(void *dest, void *src, int src_h, int src_w)\n{\n\tint i, j;\n\tdouble (*d)[src_h] = dest, (*s)[src_w] = src;\n\tfor (i = 0; i < src_h; i++)\n\t\tfor (j = 0; j < src_w; j++)\n\t\t\td[j][i] = s[i][j];\n}\n\nint main()\n{\n\tint i, j;\n\tdouble a[3][5] = {{ 0, 1, 2, 3, 4 },\n\t\t\t  { 5, 6, 7, 8, 9 },\n\t\t\t  { 1, 0, 0, 0, 42}};\n\tdouble b[5][3];\n\ttranspose(b, a, 3, 5);\n\n\tfor (i = 0; i < 5; i++)\n\t\tfor (j = 0; j < 3; j++)\n\t\t\tprintf(\"%g%c\", b[i][j], j == 2 ? '\\n' : ' ');\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "m=((1,  1,  1,   1),\n   (2,  4,  8,  16),\n   (3,  9, 27,  81),\n   (4, 16, 64, 256),\n   (5, 25,125, 625))\nprint(zip(*m))\n\n\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 270,
    "input": "Translate C to Go:#include <stdio.h>\n\n#define MAX 15\n\nint count_divisors(int n) {\n    int i, count = 0;\n    for (i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, next = 1;\n    printf(\"The first %d terms of the sequence are:\\n\", MAX);\n    for (i = 1; next <= MAX; ++i) {\n        if (next == count_divisors(i)) {           \n            printf(\"%d \", i);\n            next++;\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport \"fmt\"\n\nfunc countDivisors(n int) int {\n    count := 0\n    for i := 1; i*i <= n; i++ {\n        if n%i == 0 {\n            if i == n/i {\n                count++\n            } else {\n                count += 2\n            }\n        }\n    }\n    return count\n}\n\nfunc main() {\n    const max = 15\n    fmt.Println(\"The first\", max, \"terms of the sequence are:\")\n    for i, next := 1, 1; next <= max; i++ {\n        if next == countDivisors(i) {\n            fmt.Printf(\"%d \", i)\n            next++\n        }\n    }\n    fmt.Println()\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 271,
    "input": "Translate C to Python:#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n \nvoid set_mode(int want_key)\n{\n\tstatic struct termios old, new;\n\tif (!want_key) {\n\t\ttcsetattr(STDIN_FILENO, TCSANOW, &old);\n\t\treturn;\n\t}\n \n\ttcgetattr(STDIN_FILENO, &old);\n\tnew = old;\n\tnew.c_lflag &= ~(ICANON);\n\ttcsetattr(STDIN_FILENO, TCSANOW, &new);\n}\n \nint get_key(int no_timeout)\n{\n\tint c = 0;\n\tstruct timeval tv;\n\tfd_set fs;\n\ttv.tv_usec = tv.tv_sec = 0;\n \n\tFD_ZERO(&fs);\n\tFD_SET(STDIN_FILENO, &fs);\n\n\tselect(STDIN_FILENO + 1, &fs, 0, 0, no_timeout ? 0 : &tv);\n\tif (FD_ISSET(STDIN_FILENO, &fs)) {\n\t\tc = getchar();\n\t\tset_mode(0);\n\t}\n\treturn c;\n}\n \nint main()\n{\n\tint c;\n\twhile(1) {\n\t\tset_mode(1);\n\t\twhile (get_key(0)); \n\t\tprintf(\"Prompt again [Y/N]? \");\n\t\tfflush(stdout);\n\n\t\tc = get_key(1);\n\t\tif (c == 'Y' || c == 'y') {\n\t\t\tprintf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c == 'N' || c == 'n') {\n\t\t\tprintf(\"\\nDone\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"\\nYes or no?\\n\");\n\t}\n\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 272,
    "input": "Translate Python to C#:[print(\"( \" + \"1\"*i + \"3 ) ^ 2 = \" + str(int(\"1\"*i + \"3\")**2)) for i in range(0,8)]\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System; using BI = System.Numerics.BigInteger;\nclass Program { static void Main(string[] args) {\n    for (BI x = 3; BI.Log10(x) < 22; x = (x - 2) * 10 + 3)\n      Console.WriteLine(\"{1,43} {0,-20}\", x, x * x); } }\n",
    "input_language": "Python",
    "output_language": "C#"
  },
  {
    "id": 273,
    "input": "Translate C to Python:#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#define MAX(x,y) ((x) > (y) ? (x) : (y))\n#define MIN(x,y) ((x) < (y) ? (x) : (y)) \n\n\nsize_t base20(unsigned int n, uint8_t *out) {\n    \n    uint8_t *start = out;\n    do {*out++ = n % 20;} while (n /= 20);\n    size_t length = out - start;\n    \n    \n    while (out > start) {\n        uint8_t x = *--out;\n        *out = *start;\n        *start++ = x;\n    }\n    return length;\n}\n\n\nvoid make_digit(int n, char *place, size_t line_length) {\n    static const char *parts[] = {\"    \",\" .  \",\" .. \",\"... \",\"....\",\"----\"};\n    int i;\n\n    \n    for (i=4; i>0; i--, n -= 5)\n        memcpy(place + i*line_length, parts[MAX(0, MIN(5, n))], 4);\n        \n    \n    if (n == -20) place[4 * line_length + 1] = '@';\n}\n\n\nchar *mayan(unsigned int n) {\n    if (n == 0) return NULL; \n    \n    uint8_t digits[15]; \n    size_t n_digits = base20(n, digits);\n    \n    \n    size_t line_length = n_digits*5 + 2;\n    \n    \n    char *str = malloc(line_length * 6 + 1);\n    if (str == NULL) return NULL;\n    str[line_length * 6] = 0;\n    \n    \n    char *ptr;\n    unsigned int i;\n    \n    for (ptr=str, i=0; i<line_length; i+=5, ptr+=5) \n        memcpy(ptr, \"+----\", 5);\n    memcpy(ptr-5, \"+\\n\", 2);\n    memcpy(str+5*line_length, str, line_length);\n    \n    for (ptr=str+line_length, i=0; i<line_length; i+=5, ptr+=5)\n        memcpy(ptr, \"|    \", 5);\n    memcpy(ptr-5, \"|\\n\", 2);\n    memcpy(str+2*line_length, str+line_length, line_length);\n    memcpy(str+3*line_length, str+line_length, 2*line_length);\n\n    \n    for (i=0; i<n_digits; i++)\n        make_digit(digits[i], str+1+5*i, line_length);\n\n    return str;\n}\n        \nint main(int argc, char **argv) {\n    if (argc != 2) {\n        fprintf(stderr, \"usage: mayan <number>\\n\");\n        return 1;\n    }\n    int i = atoi(argv[1]);\n    if (i <= 0) {\n        fprintf(stderr, \"number must be positive\\n\");\n        return 1;\n    }\n    char *m = mayan(i);\n    printf(\"%s\",m);\n    free(m);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\nfrom functools import (reduce)\n\n\n\n\n\ndef mayanNumerals(n):\n    \n    return showIntAtBase(20)(\n        mayanDigit\n    )(n)([])\n\n\n\ndef mayanDigit(n):\n    \n    if 0 < n:\n        r = n % 5\n        return [\n            (['●' * r] if 0 < r else []) +\n            (['━━'] * (n // 5))\n        ]\n    else:\n        return ['Θ']\n\n\n\ndef mayanFramed(n):\n    \n    return 'Mayan ' + str(n) + ':\\n\\n' + (\n        wikiTable({\n            'class': 'wikitable',\n            'style': cssFromDict({\n                'text-align': 'center',\n                'background-color': '\n                'color': '\n                'border': '2px solid silver'\n            }),\n            'colwidth': '3em',\n            'cell': 'vertical-align: bottom;'\n        })([[\n            '<br>'.join(col) for col in mayanNumerals(n)\n        ]])\n    )\n\n\n\n\n\ndef main():\n    \n    print(\n        main.__doc__ + ':\\n\\n' +\n        '\\n'.join(mayanFramed(n) for n in [\n            4005, 8017, 326205, 886205, 1081439556,\n            1000000, 1000000000\n        ])\n    )\n\n\n\n\n\ndef wikiTable(opts):\n    \n    def colWidth():\n        return 'width:' + opts['colwidth'] + '; ' if (\n            'colwidth' in opts\n        ) else ''\n\n    def cellStyle():\n        return opts['cell'] if 'cell' in opts else ''\n\n    return lambda rows: '{| ' + reduce(\n        lambda a, k: (\n            a + k + '=\"' + opts[k] + '\" ' if (\n                k in opts\n            ) else a\n        ),\n        ['class', 'style'],\n        ''\n    ) + '\\n' + '\\n|-\\n'.join(\n        '\\n'.join(\n            ('|' if (\n                0 != i and ('cell' not in opts)\n            ) else (\n                '|style=\"' + colWidth() + cellStyle() + '\"|'\n            )) + (\n                str(x) or ' '\n            ) for x in row\n        ) for i, row in enumerate(rows)\n    ) + '\\n|}\\n\\n'\n\n\n\n\n\ndef cssFromDict(dct):\n    \n    return reduce(\n        lambda a, k: a + k + ':' + dct[k] + '; ',\n        dct.keys(),\n        ''\n    )\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 274,
    "input": "Translate C to C++:#include <stdio.h>\n\nint main() {\n    int i, gprev = 0;\n    int s[7] = {1, 2, 2, 3, 4, 4, 5};\n\n    \n    for (i = 0; i < 7; ++i) {\n\n        int curr = s[i];\n        int prev = 0;\n\n        if (i > 0 && curr == prev) printf(\"%d\\n\", i);\n        prev = curr;\n    }\n\n    \n    for (i = 0; i < 7; ++i) {\n        int curr = s[i];\n        if (i > 0 && curr == gprev) printf(\"%d\\n\", i);\n        gprev = curr;\n    }\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <array>\n#include <iostream>\n\nint main()\n{\n  constexpr std::array s {1,2,2,3,4,4,5};\n\n  if(!s.empty())\n  {\n    int previousValue = s[0];\n\n    for(size_t i = 1; i < s.size(); ++i)\n    {\n      \n      const int currentValue = s[i];\n\n      if(i > 0 && previousValue == currentValue)\n      {\n        std::cout << i << \"\\n\";\n      }\n\n      previousValue = currentValue;\n    }\n  }\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 275,
    "input": "Translate Java to Python:public static void sort(int[] nums){\n\tfor(int currentPlace = 0;currentPlace<nums.length-1;currentPlace++){\n\t\tint smallest = Integer.MAX_VALUE;\n\t\tint smallestAt = currentPlace+1;\n\t\tfor(int check = currentPlace; check<nums.length;check++){\n\t\t\tif(nums[check]<smallest){\n\t\t\t\tsmallestAt = check;\n\t\t\t\tsmallest = nums[check];\n\t\t\t}\n\t\t}\n\t\tint temp = nums[currentPlace];\n\t\tnums[currentPlace] = nums[smallestAt];\n\t\tnums[smallestAt] = temp;\n\t}\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "def selection_sort(lst):\n    for i, e in enumerate(lst):\n        mn = min(range(i,len(lst)), key=lst.__getitem__)\n        lst[i], lst[mn] = lst[mn], e\n    return lst\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 276,
    "input": "Translate C to C++:#include <stdio.h>\n\nvoid recurse(unsigned int i)\n{\n  printf(\"%d\\n\", i);\n  recurse(i+1); \n}\n\nint main()\n{\n  recurse(0);\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <iostream>\n \nvoid recurse(unsigned int i)\n{\n  std::cout<<i<<\"\\n\";\n  recurse(i+1);\n}\n \nint main()\n{\n  recurse(0);\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 277,
    "input": "Translate Python to Go:def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "import (\n\t\"image\"\n\t\"image/gif\"\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc f() (int, float64)  { return 0, 0 }\nfunc g(int, float64) int { return 0 }\nfunc h(string, ...int)   {}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 278,
    "input": "Translate PHP to Python:<?php\n  $code = 'echo \"hello world\"';\n  eval($code);\n  $code = 'return \"hello world\"';\n  print eval($code);\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": ">>> exec \n10\n",
    "input_language": "PHP",
    "output_language": "Python"
  },
  {
    "id": 279,
    "input": "Translate Python to Go:from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"rcu\"\n    \"sort\"\n)\n\nvar primes = rcu.Primes(1e8 - 1)\n\ntype res struct {\n    bc   interface{}\n    next int\n}\n\nfunc getBrilliant(digits, limit int, countOnly bool) res {\n    var brilliant []int\n    count := 0\n    pow := 1\n    next := math.MaxInt\n    for k := 1; k <= digits; k++ {\n        var s []int\n        for _, p := range primes {\n            if p >= pow*10 {\n                break\n            }\n            if p > pow {\n                s = append(s, p)\n            }\n        }\n        for i := 0; i < len(s); i++ {\n            for j := i; j < len(s); j++ {\n                prod := s[i] * s[j]\n                if prod < limit {\n                    if countOnly {\n                        count++\n                    } else {\n                        brilliant = append(brilliant, prod)\n                    }\n                } else {\n                    if next > prod {\n                        next = prod\n                    }\n                    break\n                }\n            }\n        }\n        pow *= 10\n    }\n    if countOnly {\n        return res{count, next}\n    }\n    return res{brilliant, next}\n}\n\nfunc main() {\n    fmt.Println(\"First 100 brilliant numbers:\")\n    brilliant := getBrilliant(2, 10000, false).bc.([]int)\n    sort.Ints(brilliant)\n    brilliant = brilliant[0:100]\n    for i := 0; i < len(brilliant); i++ {\n        fmt.Printf(\"%4d \", brilliant[i])\n        if (i+1)%10 == 0 {\n            fmt.Println()\n        }\n    }\n    fmt.Println()\n    for k := 1; k <= 13; k++ {\n        limit := int(math.Pow(10, float64(k)))\n        r := getBrilliant(k, limit, true)\n        total := r.bc.(int)\n        next := r.next\n        climit := rcu.Commatize(limit)\n        ctotal := rcu.Commatize(total + 1)\n        cnext := rcu.Commatize(next)\n        fmt.Printf(\"First >= %18s is %14s in the series: %18s\\n\", climit, ctotal, cnext)\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 280,
    "input": "Translate C to C++:#include<stdlib.h>\n#include<string.h>\n#include<stdio.h>\n\nint flag = 1;\n\nvoid heapPermute(int n, int arr[],int arrLen){\n\tint temp;\n\tint i;\n\t\n\tif(n==1){\n\t\tprintf(\"\\n[\");\n\t\t\n\t\tfor(i=0;i<arrLen;i++)\n\t\t\tprintf(\"%d,\",arr[i]);\n\t\tprintf(\"\\b] Sign : %d\",flag);\n\t\t\n\t\tflag*=-1;\n\t}\n\telse{\n\t\tfor(i=0;i<n-1;i++){\n\t\t\theapPermute(n-1,arr,arrLen);\n\t\t\t\n\t\t\tif(n%2==0){\n\t\t\t\ttemp = arr[i];\n\t\t\t\tarr[i] = arr[n-1];\n\t\t\t\tarr[n-1] = temp;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp = arr[0];\n\t\t\t\tarr[0] = arr[n-1];\n\t\t\t\tarr[n-1] = temp;\n\t\t\t}\n\t\t}\n\t\theapPermute(n-1,arr,arrLen);\n\t}\n}\n\nint main(int argC,char* argV[0])\n{\n\tint *arr, i=0, count = 1;\n\tchar* token;\n\t\n\tif(argC==1)\n\t\tprintf(\"Usage : %s <comma separated list of integers>\",argV[0]);\n\telse{\n\t\twhile(argV[1][i]!=00){\n\t\t\tif(argV[1][i++]==',')\n\t\t\t\tcount++;\n\t\t}\n\t\t\n\t\tarr = (int*)malloc(count*sizeof(int));\n\t\t\n\t\ti = 0;\n\t\t\n\t\ttoken = strtok(argV[1],\",\");\n\t\t\n\t\twhile(token!=NULL){\n\t\t\tarr[i++] = atoi(token);\n\t\t\ttoken = strtok(NULL,\",\");\n\t\t}\n\t\t\n\t\theapPermute(i,arr,count);\n\t}\n\t\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C++ code.",
    "output": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> UpTo(int n, int offset = 0)\n{\n\tvector<int> retval(n);\n\tfor (int ii = 0; ii < n; ++ii)\n\t\tretval[ii] = ii + offset;\n\treturn retval;\n}\n\nstruct JohnsonTrotterState_\n{\n\tvector<int> values_;\n\tvector<int> positions_;\t\n\tvector<bool> directions_;\n\tint sign_;\n\n\tJohnsonTrotterState_(int n) : values_(UpTo(n, 1)), positions_(UpTo(n + 1, -1)), directions_(n + 1, false), sign_(1) {}\n\n\tint LargestMobile() const\t\n\t{\n\t\tfor (int r = values_.size(); r > 0; --r)\n\t\t{\n\t\t\tconst int loc = positions_[r] + (directions_[r] ? 1 : -1);\n\t\t\tif (loc >= 0 && loc < values_.size() && values_[loc] < r)\n\t\t\t\treturn r;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbool IsComplete() const { return LargestMobile() == 0; }\n\n\tvoid operator++()\t\n\t{\n\t\tconst int r = LargestMobile();\n\t\tconst int rLoc = positions_[r];\n\t\tconst int lLoc = rLoc + (directions_[r] ? 1 : -1);\n\t\tconst int l = values_[lLoc];\n\t\t\n\t\tswap(values_[lLoc], values_[rLoc]);\n\t\tswap(positions_[l], positions_[r]);\n\t\tsign_ = -sign_;\n\t\t\n\t\tfor (auto pd = directions_.begin() + r + 1; pd != directions_.end(); ++pd)\n\t\t\t*pd = !*pd;\n\t}\n};\n\nint main(void)\n{\n\tJohnsonTrotterState_ state(4);\n\tdo\n\t{\n\t\tfor (auto v : state.values_)\n\t\t\tcout << v << \" \";\n\t\tcout << \"\\n\";\n\t\t++state;\n\t} while (!state.IsComplete());\n}\n",
    "input_language": "C",
    "output_language": "C++"
  },
  {
    "id": 281,
    "input": "Translate C# to VB:using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\n\npublic enum Colour { Red, Green, White, Yellow, Blue }\npublic enum Nationality { Englishman, Swede, Dane, Norwegian,German }\npublic enum Pet { Dog, Birds, Cats, Horse, Zebra }\npublic enum Drink { Coffee, Tea, Milk, Beer, Water }\npublic enum Smoke { PallMall, Dunhill, Blend, BlueMaster, Prince}\n\npublic static class ZebraPuzzle\n{\n    private static (Colour[] colours, Drink[] drinks, Smoke[] smokes, Pet[] pets, Nationality[] nations) _solved;\n\n    static ZebraPuzzle()\n    {\n        var solve = from colours in Permute<Colour>()  \n                    where (colours,Colour.White).IsRightOf(colours, Colour.Green) \n                    from nations in Permute<Nationality>()\n                    where nations[0] == Nationality.Norwegian \n                    where (nations, Nationality.Englishman).IsSameIndex(colours, Colour.Red) \n                    where (nations,Nationality.Norwegian).IsNextTo(colours,Colour.Blue) \n                    from drinks in Permute<Drink>()\n                    where drinks[2] == Drink.Milk \n                    where (drinks, Drink.Coffee).IsSameIndex(colours, Colour.Green) \n                    where (drinks, Drink.Tea).IsSameIndex(nations, Nationality.Dane) \n                    from pets in Permute<Pet>()\n                    where (pets, Pet.Dog).IsSameIndex(nations, Nationality.Swede) \n                    from smokes in Permute<Smoke>()\n                    where (smokes, Smoke.PallMall).IsSameIndex(pets, Pet.Birds) \n                    where (smokes, Smoke.Dunhill).IsSameIndex(colours, Colour.Yellow) \n                    where (smokes, Smoke.Blend).IsNextTo(pets, Pet.Cats) \n                    where (smokes, Smoke.Dunhill).IsNextTo(pets, Pet.Horse) \n                    where (smokes, Smoke.BlueMaster).IsSameIndex(drinks, Drink.Beer) \n                    where (smokes, Smoke.Prince).IsSameIndex(nations, Nationality.German) \n                    where (drinks,Drink.Water).IsNextTo(smokes,Smoke.Blend) \n                    select (colours, drinks, smokes, pets, nations);\n\n        _solved = solve.First();\n    }\n    \n    private static int IndexOf<T>(this T[] arr, T obj) => Array.IndexOf(arr, obj);\n\n    private static bool IsRightOf<T, U>(this (T[] a, T v) right, U[] a, U v) => right.a.IndexOf(right.v) == a.IndexOf(v) + 1;\n\n    private static bool IsSameIndex<T, U>(this (T[] a, T v)x, U[] a, U v) => x.a.IndexOf(x.v) == a.IndexOf(v);\n\n    private static bool IsNextTo<T, U>(this (T[] a, T v)x, U[] a,  U v) => (x.a,x.v).IsRightOf(a, v) || (a,v).IsRightOf(x.a,x.v);\n\n    \n    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n    {\n        if (values.Count() == 1)\n            return values.ToSingleton();\n\n        return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())),(v, p) => p.Prepend(v));\n    }\n\n    public static IEnumerable<T[]> Permute<T>() => ToEnumerable<T>().Permutations().Select(p=>p.ToArray());\n\n    private static IEnumerable<T> ToSingleton<T>(this T item){ yield return item; }\n\n    private static IEnumerable<T> ToEnumerable<T>() => Enum.GetValues(typeof(T)).Cast<T>();\n\n    public static new String ToString()\n    {\n        var sb = new StringBuilder();\n        sb.AppendLine(\"House Colour Drink    Nationality Smokes     Pet\");\n        sb.AppendLine(\"───── ────── ──────── ─────────── ────────── ─────\");\n        var (colours, drinks, smokes, pets, nations) = _solved;\n        for (var i = 0; i < 5; i++)\n            sb.AppendLine($\"{i+1,5} {colours[i],-6} {drinks[i],-8} {nations[i],-11} {smokes[i],-10} {pets[i],-10}\");\n        return sb.ToString();\n    }\n\n    public static void Main(string[] arguments)\n    {\n        var owner = _solved.nations[_solved.pets.IndexOf(Pet.Zebra)];\n        WriteLine($\"The zebra owner is {owner}\");\n        Write(ToString());\n        Read();\n    }\n}\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Option Base 1\nPublic Enum attr\n    Colour = 1\n    Nationality\n    Beverage\n    Smoke\n    Pet\nEnd Enum\nPublic Enum Drinks_\n    Beer = 1\n    Coffee\n    Milk\n    Tea\n    Water\nEnd Enum\nPublic Enum nations\n    Danish = 1\n    English\n    German\n    Norwegian\n    Swedish\nEnd Enum\nPublic Enum colors\n    Blue = 1\n    Green\n    Red\n    White\n    Yellow\nEnd Enum\nPublic Enum tobaccos\n    Blend = 1\n    BlueMaster\n    Dunhill\n    PallMall\n    Prince\nEnd Enum\nPublic Enum animals\n    Bird = 1\n    Cat\n    Dog\n    Horse\n    Zebra\nEnd Enum\nPublic permutation As New Collection\nPublic perm(5) As Variant\nConst factorial5 = 120\nPublic Colours As Variant, Nationalities As Variant, Drinks As Variant, Smokes As Variant, Pets As Variant\n\nPrivate Sub generate(n As Integer, A As Variant)\n    If n = 1 Then\n        permutation.Add A\n    Else\n        For i = 1 To n\n            generate n - 1, A\n            If n Mod 2 = 0 Then\n                tmp = A(i)\n                A(i) = A(n)\n                A(n) = tmp\n            Else\n                tmp = A(1)\n                A(1) = A(n)\n                A(n) = tmp\n            End If\n        Next i\n    End If\nEnd Sub\n\nFunction house(i As Integer, name As Variant) As Integer\n    Dim x As Integer\n    For x = 1 To 5\n        If perm(i)(x) = name Then\n            house = x\n            Exit For\n        End If\n    Next x\nEnd Function\n \nFunction left_of(h1 As Integer, h2 As Integer) As Boolean\n    left_of = (h1 - h2) = -1\nEnd Function\n \nFunction next_to(h1 As Integer, h2 As Integer) As Boolean\n    next_to = Abs(h1 - h2) = 1\nEnd Function\n \nPrivate Sub print_house(i As Integer)\n    Debug.Print i & \": \"; Colours(perm(Colour)(i)), Nationalities(perm(Nationality)(i)), _\n        Drinks(perm(Beverage)(i)), Smokes(perm(Smoke)(i)), Pets(perm(Pet)(i))\nEnd Sub\nPublic Sub Zebra_puzzle()\n    Colours = [{\"blue\",\"green\",\"red\",\"white\",\"yellow\"}]\n    Nationalities = [{\"Dane\",\"English\",\"German\",\"Norwegian\",\"Swede\"}]\n    Drinks = [{\"beer\",\"coffee\",\"milk\",\"tea\",\"water\"}]\n    Smokes = [{\"Blend\",\"Blue Master\",\"Dunhill\",\"Pall Mall\",\"Prince\"}]\n    Pets = [{\"birds\",\"cats\",\"dog\",\"horse\",\"zebra\"}]\n    Dim solperms As New Collection\n    Dim solutions As Integer\n    Dim b(5) As Integer, i As Integer\n    For i = 1 To 5: b(i) = i: Next i\n    \n    generate 5, b\n    For c = 1 To factorial5\n        perm(Colour) = permutation(c)\n        \n        If left_of(house(Colour, Green), house(Colour, White)) Then\n            For n = 1 To factorial5\n                perm(Nationality) = permutation(n)\n                \n                \n                \n                If house(Nationality, Norwegian) = 1 _\n                    And house(Nationality, English) = house(Colour, Red) _\n                    And next_to(house(Nationality, Norwegian), house(Colour, Blue)) Then\n                    For d = 1 To factorial5\n                        perm(Beverage) = permutation(d)\n                        \n                        \n                        \n                        If house(Nationality, Danish) = house(Beverage, Tea) _\n                            And house(Beverage, Coffee) = house(Colour, Green) _\n                            And house(Beverage, Milk) = 3 Then\n                            For s = 1 To factorial5\n                                perm(Smoke) = permutation(s)\n                                \n                                \n                                \n                                \n                                If house(Colour, Yellow) = house(Smoke, Dunhill) _\n                                    And house(Nationality, German) = house(Smoke, Prince) _\n                                    And house(Smoke, BlueMaster) = house(Beverage, Beer) _\n                                    And next_to(house(Beverage, Water), house(Smoke, Blend)) Then\n                                    For p = 1 To factorial5\n                                        perm(Pet) = permutation(p)\n                                        \n                                        \n                                        \n                                        \n                                        If house(Nationality, Swedish) = house(Pet, Dog) _\n                                            And house(Smoke, PallMall) = house(Pet, Bird) _\n                                            And next_to(house(Smoke, Blend), house(Pet, Cat)) _\n                                            And next_to(house(Pet, Horse), house(Smoke, Dunhill)) Then\n                                            For i = 1 To 5\n                                                print_house i\n                                            Next i\n                                            Debug.Print\n                                            solutions = solutions + 1\n                                            solperms.Add perm\n                                        End If\n                                    Next p\n                                End If\n                            Next s\n                        End If\n                    Next d\n                End If\n            Next n\n        End If\n    Next c\n    Debug.Print Format(solutions, \"@\"); \" solution\" & IIf(solutions > 1, \"s\", \"\") & \" found\"\n    For i = 1 To solperms.Count\n        For j = 1 To 5\n            perm(j) = solperms(i)(j)\n        Next j\n        Debug.Print \"The \" & Nationalities(perm(Nationality)(house(Pet, Zebra))) & \" owns the Zebra\"\n    Next i\nEnd Sub\n",
    "input_language": "C#",
    "output_language": "VB"
  },
  {
    "id": 282,
    "input": "Translate C++ to Java:#include <iostream>\n#include <cctype>\n#include <functional>\n\nusing namespace std;\n\nbool odd()\n{\n  function<void ()> prev = []{};\n  while(true) {\n    int c = cin.get();\n    if (!isalpha(c)) {\n      prev();\n      cout.put(c);\n      return c != '.';\n    }\n    prev = [=] { cout.put(c); prev();  };\n  }\n}\n\nbool even() \n{\n  while(true) {\n    int c;\n    cout.put(c = cin.get());\n    if (!isalpha(c)) return c != '.';\n  }\n}\n\n\nint main()\n{\n  bool e = false;\n  while( e ? odd() : even() ) e = !e;\n  return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Java"
  },
  {
    "id": 283,
    "input": "Translate C++ to Python:#include <iostream>\n\nbool is_prime(int n) {\n    if (n < 2) {\n        return false;\n    }\n\n    if (n % 2 == 0) {\n        return n == 2;\n    }\n    if (n % 3 == 0) {\n        return n == 3;\n    }\n\n    int i = 5;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i += 2;\n\n        if (n % i == 0) {\n            return false;\n        }\n        i += 4;\n    }\n\n    return true;\n}\n\nint main() {\n    const int start = 1;\n    const int stop = 1000;\n\n    int sum = 0;\n    int count = 0;\n    int sc = 0;\n\n    for (int p = start; p < stop; p++) {\n        if (is_prime(p)) {\n            count++;\n            sum += p;\n            if (is_prime(sum)) {\n                printf(\"The sum of %3d primes in [2, %3d] is %5d which is also prime\\n\", count, p, sum);\n                sc++;\n            }\n        }\n    }\n    printf(\"There are %d summerized primes in [%d, %d)\\n\", sc, start, stop);\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\n\n\nfrom itertools import accumulate, chain, takewhile\n\n\n\ndef primeSums():\n    \n    return (\n        x for x in enumerate(\n            accumulate(\n                chain([(0, 0)], primes()),\n                lambda a, p: (p, p + a[1])\n            )\n        ) if isPrime(x[1][1])\n    )\n\n\n\n\ndef main():\n    \n    for x in takewhile(\n            lambda t: 1000 > t[1][0],\n            primeSums()\n    ):\n        print(f'{x[0]} -> {x[1][1]}')\n\n\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n",
    "input_language": "C++",
    "output_language": "Python"
  },
  {
    "id": 284,
    "input": "Translate Python to Go:import os\ntargetfile = \"pycon-china\"\nos.rename(os.path.realpath(targetfile), os.path.realpath(targetfile)+\".bak\")\nf = open(os.path.realpath(targetfile), \"w\")\nf.write(\"this task was solved during a talk about rosettacode at the PyCon China in 2011\")\nf.close()\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n)\n\nfunc main() {\n    fn := \"myth\"\n    bx := \".backup\"\n    \n    var err error\n    if tf, err := os.Readlink(fn); err == nil {\n        fn = tf\n    }\n    \n    var fi os.FileInfo\n    if fi, err = os.Stat(fn); err != nil {\n        fmt.Println(err)\n        return\n    }\n    \n    if err = os.Rename(fn, fn+bx); err != nil {\n        fmt.Println(err)\n        return\n    }\n    \n    err = ioutil.WriteFile(fn, []byte(\"you too!\\n\"), fi.Mode().Perm())\n    if err != nil {\n        fmt.Println(err)\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 285,
    "input": "Translate C to Java:#include <stdio.h>\n#include <ctype.h>\n\nstatic int \nowp(int odd)\n{\n        int ch, ret;\n        ch = getc(stdin);\n        if (!odd) {\n                putc(ch, stdout);\n                if (ch == EOF || ch == '.')\n                        return EOF;\n                if (ispunct(ch))\n                        return 0;\n                owp(odd);\n                return 0;\n        } else {\n                if (ispunct(ch))\n                        return ch; \n                ret = owp(odd);\n                putc(ch, stdout);\n                return ret;\n        }\n}\n\nint\nmain(int argc, char **argv)\n{\n        int ch = 1;\n        while ((ch = owp(!ch)) != EOF) {\n                if (ch)\n                        putc(ch, stdout);\n                if (ch == '.')\n                        break;\n        }\n        return 0;\n}\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}\n",
    "input_language": "C",
    "output_language": "Java"
  },
  {
    "id": 286,
    "input": "Translate PHP to Go:<?php\nclass Node {\n    public $val;\n    public $back = NULL;\n}\n\nfunction lis($n) {\n    $pileTops = array();\n\n    foreach ($n as $x) {\n\n        $low = 0; $high = count($pileTops)-1;\n        while ($low <= $high) {\n            $mid = (int)(($low + $high) / 2);\n            if ($pileTops[$mid]->val >= $x)\n                $high = $mid - 1;\n            else\n                $low = $mid + 1;\n        }\n        $i = $low;\n        $node = new Node();\n        $node->val = $x;\n        if ($i != 0)\n            $node->back = $pileTops[$i-1];\n        $pileTops[$i] = $node;\n    }\n    $result = array();\n    for ($node = count($pileTops) ? $pileTops[count($pileTops)-1] : NULL;\n         $node != NULL; $node = $node->back)\n        $result[] = $node->val;\n\n    return array_reverse($result);\n}\n\nprint_r(lis(array(3, 2, 6, 4, 5, 1)));\nprint_r(lis(array(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)));\n?>\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n  \"fmt\"\n  \"sort\"\n)\n\ntype Node struct {\n    val int\n    back *Node\n}\n\nfunc lis (n []int) (result []int) {\n  var pileTops []*Node\n  \n  for _, x := range n {\n    j := sort.Search(len(pileTops), func (i int) bool { return pileTops[i].val >= x })\n    node := &Node{ x, nil }\n    if j != 0 { node.back = pileTops[j-1] }\n    if j != len(pileTops) {\n      pileTops[j] = node\n    } else {\n      pileTops = append(pileTops, node)\n    }\n  }\n\n  if len(pileTops) == 0 { return []int{} }\n  for node := pileTops[len(pileTops)-1]; node != nil; node = node.back {\n    result = append(result, node.val)\n  }\n  \n  for i := 0; i < len(result)/2; i++ {\n    result[i], result[len(result)-i-1] = result[len(result)-i-1], result[i]\n  }\n  return\n}\n\nfunc main() {\n    for _, d := range [][]int{{3, 2, 6, 4, 5, 1},\n            {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}} {\n        fmt.Printf(\"an L.I.S. of %v is %v\\n\", d, lis(d))\n    }\n}\n",
    "input_language": "PHP",
    "output_language": "Go"
  },
  {
    "id": 287,
    "input": "Translate C to Go:#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUFFER_SIZE 128\n\ntypedef unsigned char character;\ntypedef character *string;\n\ntypedef struct node_t node;\nstruct node_t {\n    enum tag_t {\n        NODE_LEAF,\n        NODE_TREE,\n        NODE_SEQ,\n    } tag;\n\n    union {\n        string str;\n        node *root;\n    } data;\n\n    node *next;\n};\n\nnode *allocate_node(enum tag_t tag) {\n    node *n = malloc(sizeof(node));\n    if (n == NULL) {\n        fprintf(stderr, \"Failed to allocate node for tag: %d\\n\", tag);\n        exit(1);\n    }\n    n->tag = tag;\n    n->next = NULL;\n    return n;\n}\n\nnode *make_leaf(string str) {\n    node *n = allocate_node(NODE_LEAF);\n    n->data.str = str;\n    return n;\n}\n\nnode *make_tree() {\n    node *n = allocate_node(NODE_TREE);\n    n->data.root = NULL;\n    return n;\n}\n\nnode *make_seq() {\n    node *n = allocate_node(NODE_SEQ);\n    n->data.root = NULL;\n    return n;\n}\n\nvoid deallocate_node(node *n) {\n    if (n == NULL) {\n        return;\n    }\n\n    deallocate_node(n->next);\n    n->next = NULL;\n\n    if (n->tag == NODE_LEAF) {\n        free(n->data.str);\n        n->data.str = NULL;\n    } else if (n->tag == NODE_TREE || n->tag == NODE_SEQ) {\n        deallocate_node(n->data.root);\n        n->data.root = NULL;\n    } else {\n        fprintf(stderr, \"Cannot deallocate node with tag: %d\\n\", n->tag);\n        exit(1);\n    }\n\n    free(n);\n}\n\nvoid append(node *root, node *elem) {\n    if (root == NULL) {\n        fprintf(stderr, \"Cannot append to uninitialized node.\");\n        exit(1);\n    }\n    if (elem == NULL) {\n        return;\n    }\n\n    if (root->tag == NODE_SEQ || root->tag == NODE_TREE) {\n        if (root->data.root == NULL) {\n            root->data.root = elem;\n        } else {\n            node *it = root->data.root;\n            while (it->next != NULL) {\n                it = it->next;\n            }\n            it->next = elem;\n        }\n    } else {\n        fprintf(stderr, \"Cannot append to node with tag: %d\\n\", root->tag);\n        exit(1);\n    }\n}\n\nsize_t count(node *n) {\n    if (n == NULL) {\n        return 0;\n    }\n\n    if (n->tag == NODE_LEAF) {\n        return 1;\n    }\n    if (n->tag == NODE_TREE) {\n        size_t sum = 0;\n        node *it = n->data.root;\n        while (it != NULL) {\n            sum += count(it);\n            it = it->next;\n        }\n        return sum;\n    }\n    if (n->tag == NODE_SEQ) {\n        size_t prod = 1;\n        node *it = n->data.root;\n        while (it != NULL) {\n            prod *= count(it);\n            it = it->next;\n        }\n        return prod;\n    }\n\n    fprintf(stderr, \"Cannot count node with tag: %d\\n\", n->tag);\n    exit(1);\n}\n\nvoid expand(node *n, size_t pos) {\n    if (n == NULL) {\n        return;\n    }\n\n    if (n->tag == NODE_LEAF) {\n        printf(n->data.str);\n    } else if (n->tag == NODE_TREE) {\n        node *it = n->data.root;\n        while (true) {\n            size_t cnt = count(it);\n            if (pos < cnt) {\n                expand(it, pos);\n                break;\n            }\n            pos -= cnt;\n            it = it->next;\n        }\n    } else if (n->tag == NODE_SEQ) {\n        size_t prod = pos;\n        node *it = n->data.root;\n        while (it != NULL) {\n            size_t cnt = count(it);\n\n            size_t rem = prod % cnt;\n            expand(it, rem);\n\n            it = it->next;\n        }\n    } else {\n        fprintf(stderr, \"Cannot expand node with tag: %d\\n\", n->tag);\n        exit(1);\n    }\n}\n\nstring allocate_string(string src) {\n    size_t len = strlen(src);\n    string out = calloc(len + 1, sizeof(character));\n    if (out == NULL) {\n        fprintf(stderr, \"Failed to allocate a copy of the string.\");\n        exit(1);\n    }\n    strcpy(out, src);\n    return out;\n}\n\nnode *parse_seq(string input, size_t *pos);\n\nnode *parse_tree(string input, size_t *pos) {\n    node *root = make_tree();\n\n    character buffer[BUFFER_SIZE] = { 0 };\n    size_t bufpos = 0;\n    size_t depth = 0;\n    bool asSeq = false;\n    bool allow = false;\n\n    while (input[*pos] != 0) {\n        character c = input[(*pos)++];\n        if (c == '\\\\') {\n            c = input[(*pos)++];\n            if (c == 0) {\n                break;\n            }\n            buffer[bufpos++] = '\\\\';\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        } else if (c == '{') {\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n            asSeq = true;\n            depth++;\n        } else if (c == '}') {\n            if (depth-- > 0) {\n                buffer[bufpos++] = c;\n                buffer[bufpos] = 0;\n            } else {\n                if (asSeq) {\n                    size_t new_pos = 0;\n                    node *seq = parse_seq(buffer, &new_pos);\n                    append(root, seq);\n                } else {\n                    append(root, make_leaf(allocate_string(buffer)));\n                }\n                break;\n            }\n        } else if (c == ',') {\n            if (depth == 0) {\n                if (asSeq) {\n                    size_t new_pos = 0;\n                    node *seq = parse_seq(buffer, &new_pos);\n                    append(root, seq);\n                    bufpos = 0;\n                    buffer[bufpos] = 0;\n                    asSeq = false;\n                } else {\n                    append(root, make_leaf(allocate_string(buffer)));\n                    bufpos = 0;\n                    buffer[bufpos] = 0;\n                }\n            } else {\n                buffer[bufpos++] = c;\n                buffer[bufpos] = 0;\n            }\n        } else {\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        }\n    }\n\n    return root;\n}\n\nnode *parse_seq(string input, size_t *pos) {\n    node *root = make_seq();\n\n    character buffer[BUFFER_SIZE] = { 0 };\n    size_t bufpos = 0;\n\n    while (input[*pos] != 0) {\n        character c = input[(*pos)++];\n        if (c == '\\\\') {\n            c = input[(*pos)++];\n            if (c == 0) {\n                break;\n            }\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        } else if (c == '{') {\n            node *tree = parse_tree(input, pos);\n            if (bufpos > 0) {\n                append(root, make_leaf(allocate_string(buffer)));\n                bufpos = 0;\n                buffer[bufpos] = 0;\n            }\n            append(root, tree);\n        } else {\n            buffer[bufpos++] = c;\n            buffer[bufpos] = 0;\n        }\n    }\n\n    if (bufpos > 0) {\n        append(root, make_leaf(allocate_string(buffer)));\n        bufpos = 0;\n        buffer[bufpos] = 0;\n    }\n\n    return root;\n}\n\nvoid test(string input) {\n    size_t pos = 0;\n    node *n = parse_seq(input, &pos);\n    size_t cnt = count(n);\n    size_t i;\n\n    printf(\"Pattern: %s\\n\", input);\n\n    for (i = 0; i < cnt; i++) {\n        expand(n, i);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n\n    deallocate_node(n);\n}\n\nint main() {\n    test(\"~/{Downloads,Pictures}/*.{jpg,gif,png}\");\n    test(\"It{{em,alic}iz,erat}e{d,}, please.\");\n    test(\"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\");\n\n    \n    \n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package expand\n\n\ntype Expander interface {\n\tExpand() []string\n}\n\n\ntype Text string\n\nfunc (t Text) Expand() []string { return []string{string(t)} }\n\n\n\ntype Alternation []Expander\n\nfunc (alt Alternation) Expand() []string {\n\tvar out []string\n\tfor _, e := range alt {\n\t\tout = append(out, e.Expand()...)\n\t}\n\treturn out\n}\n\n\n\ntype Sequence []Expander\n\nfunc (seq Sequence) Expand() []string {\n\tif len(seq) == 0 {\n\t\treturn nil\n\t}\n\tout := seq[0].Expand()\n\tfor _, e := range seq[1:] {\n\t\tout = combine(out, e.Expand())\n\t}\n\treturn out\n}\n\nfunc combine(al, bl []string) []string {\n\tout := make([]string, 0, len(al)*len(bl))\n\tfor _, a := range al {\n\t\tfor _, b := range bl {\n\t\t\tout = append(out, a+b)\n\t\t}\n\t}\n\treturn out\n}\n\n\nconst (\n\tescape   = '\\\\'\n\taltStart = '{'\n\taltEnd   = '}'\n\taltSep   = ','\n)\n\ntype piT struct{ pos, cnt, depth int }\n\ntype Brace string\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Expand(s string) []string   { return Brace(s).Expand() }\nfunc (b Brace) Expand() []string { return b.Expander().Expand() }\nfunc (b Brace) Expander() Expander {\n\ts := string(b)\n\t\n\tvar posInfo []piT\n\tvar stack []int \n\tremovePosInfo := func(i int) {\n\t\tend := len(posInfo) - 1\n\t\tcopy(posInfo[i:end], posInfo[i+1:])\n\t\tposInfo = posInfo[:end]\n\t}\n\n\tinEscape := false\n\tfor i, r := range s {\n\t\tif inEscape {\n\t\t\tinEscape = false\n\t\t\tcontinue\n\t\t}\n\t\tswitch r {\n\t\tcase escape:\n\t\t\tinEscape = true\n\t\tcase altStart:\n\t\t\tstack = append(stack, len(posInfo))\n\t\t\tposInfo = append(posInfo, piT{i, 0, len(stack)})\n\t\tcase altEnd:\n\t\t\tif len(stack) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsi := len(stack) - 1\n\t\t\tpi := stack[si]\n\t\t\tif posInfo[pi].cnt == 0 {\n\t\t\t\tremovePosInfo(pi)\n\t\t\t\tfor pi < len(posInfo) {\n\t\t\t\t\tif posInfo[pi].depth == len(stack) {\n\t\t\t\t\t\tremovePosInfo(pi)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpi++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tposInfo = append(posInfo, piT{i, -2, len(stack)})\n\t\t\t}\n\t\t\tstack = stack[:si]\n\t\tcase altSep:\n\t\t\tif len(stack) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tposInfo = append(posInfo, piT{i, -1, len(stack)})\n\t\t\tposInfo[stack[len(stack)-1]].cnt++\n\t\t}\n\t}\n\t\n\tfor len(stack) > 0 {\n\t\tsi := len(stack) - 1\n\t\tpi := stack[si]\n\t\tdepth := posInfo[pi].depth\n\t\tremovePosInfo(pi)\n\t\tfor pi < len(posInfo) {\n\t\t\tif posInfo[pi].depth == depth {\n\t\t\t\tremovePosInfo(pi)\n\t\t\t} else {\n\t\t\t\tpi++\n\t\t\t}\n\t\t}\n\t\tstack = stack[:si]\n\t}\n\treturn buildExp(s, 0, posInfo)\n}\n\nfunc buildExp(s string, off int, info []piT) Expander {\n\tif len(info) == 0 {\n\t\treturn Text(s)\n\t}\n\t\n\tvar seq Sequence\n\ti := 0\n\tvar dj, j, depth int\n\tfor dk, piK := range info {\n\t\tk := piK.pos - off\n\t\tswitch s[k] {\n\t\tcase altStart:\n\t\t\tif depth == 0 {\n\t\t\t\tdj = dk\n\t\t\t\tj = k\n\t\t\t\tdepth = piK.depth\n\t\t\t}\n\t\tcase altEnd:\n\t\t\tif piK.depth != depth {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif j > i {\n\t\t\t\tseq = append(seq, Text(s[i:j]))\n\t\t\t}\n\t\t\talt := buildAlt(s[j+1:k], depth, j+1+off, info[dj+1:dk])\n\t\t\tseq = append(seq, alt)\n\t\t\ti = k + 1\n\t\t\tdepth = 0\n\t\t}\n\t}\n\tif j := len(s); j > i {\n\t\tseq = append(seq, Text(s[i:j]))\n\t}\n\tif len(seq) == 1 {\n\t\treturn seq[0]\n\t}\n\treturn seq\n}\n\nfunc buildAlt(s string, depth, off int, info []piT) Alternation {\n\t\n\tvar alt Alternation\n\ti := 0\n\tvar di int\n\tfor dk, piK := range info {\n\t\tif piK.depth != depth {\n\t\t\tcontinue\n\t\t}\n\t\tif k := piK.pos - off; s[k] == altSep {\n\t\t\tsub := buildExp(s[i:k], i+off, info[di:dk])\n\t\t\talt = append(alt, sub)\n\t\t\ti = k + 1\n\t\t\tdi = dk + 1\n\t\t}\n\t}\n\tsub := buildExp(s[i:], i+off, info[di:])\n\talt = append(alt, sub)\n\treturn alt\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 288,
    "input": "Translate C++ to PHP:#include <Rcpp.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nusing namespace Rcpp ;\n\n\nCharacterVector getNameInfo(std::string fqdn) {\n\n  struct addrinfo hints, *res, *res0;\n\tint error;\n\tchar host[NI_MAXHOST];\n\n  memset(&hints, 0, sizeof hints);\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_DGRAM;\n\n\terror = getaddrinfo(fqdn.c_str(), NULL, &hints, &res0);\n\tif (error) { return(NA_STRING);\t}\n\n  int i = 0 ;\n\tfor (res = res0; res; res = res->ai_next) {\n  \terror = getnameinfo(res->ai_addr, res->ai_addrlen,\n\t\t    host, sizeof host, NULL, 0, NI_NUMERICHOST);\n\t\tif (!error) { i++ ; }\n\t}\n\n  CharacterVector results(i) ;\n\n  i = 0;\n\n  for (res = res0; res; res = res->ai_next) {\n\t\terror = getnameinfo(res->ai_addr, res->ai_addrlen,\n\t\t    host, sizeof host, NULL, 0, NI_NUMERICHOST);\n\t\tif (!error) { results[i++] = host ; }\n\t}\n\n  freeaddrinfo(res0);\n\n  return(results) ;\n\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\n  $ipv4_record = dns_get_record(\"www.kame.net\",DNS_A);\n  $ipv6_record = dns_get_record(\"www.kame.net\",DNS_AAAA);\n  print \"ipv4: \" . $ipv4_record[0][\"ip\"] . \"\\n\";\n  print \"ipv6: \" . $ipv6_record[0][\"ipv6\"] . \"\\n\";\n?>\n",
    "input_language": "C++",
    "output_language": "PHP"
  },
  {
    "id": 289,
    "input": "Translate Python to Go:from collections import Counter\n\ndef cumulative_freq(freq):\n    cf = {}\n    total = 0\n    for b in range(256):\n        if b in freq:\n            cf[b] = total\n            total += freq[b]\n    return cf\n\ndef arithmethic_coding(bytes, radix):\n\n    \n    freq = Counter(bytes)\n\n    \n    cf = cumulative_freq(freq)\n\n    \n    base = len(bytes)\n\n    \n    lower = 0\n\n    \n    pf = 1\n\n    \n    \n    for b in bytes:\n        lower = lower*base + cf[b]*pf\n        pf *= freq[b]\n\n    \n    upper = lower+pf\n\n    pow = 0\n    while True:\n        pf //= radix\n        if pf==0: break\n        pow += 1\n\n    enc = (upper-1) // radix**pow\n    return enc, pow, freq\n\ndef arithmethic_decoding(enc, radix, pow, freq):\n\n    \n    enc *= radix**pow;\n\n    \n    base = sum(freq.values())\n\n    \n    cf = cumulative_freq(freq)\n\n    \n    dict = {}\n    for k,v in cf.items():\n        dict[v] = k\n\n    \n    lchar = None\n    for i in range(base):\n        if i in dict:\n            lchar = dict[i]\n        elif lchar is not None:\n            dict[i] = lchar\n\n    \n    decoded = bytearray()\n    for i in range(base-1, -1, -1):\n        pow = base**i\n        div = enc//pow\n\n        c  = dict[div]\n        fv = freq[c]\n        cv = cf[c]\n\n        rem = (enc - pow*cv) // fv\n\n        enc = rem\n        decoded.append(c)\n\n    \n    return bytes(decoded)\n\nradix = 10      \n\nfor str in b'DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT'.split():\n    enc, pow, freq = arithmethic_coding(str, radix)\n    dec = arithmethic_decoding(enc, radix, pow, freq)\n\n    print(\"%-25s=> %19s * %d^%s\" % (str, enc, radix, pow))\n\n    if str != dec:\n    \traise Exception(\"\\tHowever that is incorrect!\")\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nfunc cumulative_freq(freq map[byte]int64) map[byte]int64 {\n    total := int64(0)\n    cf := make(map[byte]int64)\n    for i := 0; i < 256; i++ {\n        b := byte(i)\n        if v, ok := freq[b]; ok {\n            cf[b] = total\n            total += v\n        }\n    }\n    return cf\n}\n\nfunc arithmethic_coding(str string, radix int64) (*big.Int,\n                                *big.Int, map[byte]int64) {\n\n    \n    chars := []byte(str)\n\n    \n    freq := make(map[byte]int64)\n    for _, c := range chars {\n        freq[c] += 1\n    }\n\n    \n    cf := cumulative_freq(freq)\n\n    \n    base := len(chars)\n\n    \n    L := big.NewInt(0)\n\n    \n    pf := big.NewInt(1)\n\n    \n    \n    bigBase := big.NewInt(int64(base))\n\n    for _, c := range chars {\n        x := big.NewInt(cf[c])\n\n        L.Mul(L, bigBase)\n        L.Add(L, x.Mul(x, pf))\n        pf.Mul(pf, big.NewInt(freq[c]))\n    }\n\n    \n    U := big.NewInt(0)\n    U.Set(L)\n    U.Add(U, pf)\n\n    bigOne := big.NewInt(1)\n    bigZero := big.NewInt(0)\n    bigRadix := big.NewInt(radix)\n\n    tmp := big.NewInt(0).Set(pf)\n    powr := big.NewInt(0)\n\n    for {\n        tmp.Div(tmp, bigRadix)\n        if tmp.Cmp(bigZero) == 0 {\n            break\n        }\n        powr.Add(powr, bigOne)\n    }\n\n    diff := big.NewInt(0)\n    diff.Sub(U, bigOne)\n    diff.Div(diff, big.NewInt(0).Exp(bigRadix, powr, nil))\n\n    return diff, powr, freq\n}\n\nfunc arithmethic_decoding(num *big.Int, radix int64,\n          pow *big.Int, freq map[byte]int64) string {\n\n    powr := big.NewInt(radix)\n\n    enc := big.NewInt(0).Set(num)\n    enc.Mul(enc, powr.Exp(powr, pow, nil))\n\n    base := int64(0)\n    for _, v := range freq {\n        base += v\n    }\n\n    \n    cf := cumulative_freq(freq)\n\n    \n    dict := make(map[int64]byte)\n    for k, v := range cf {\n        dict[v] = k\n    }\n\n    \n    lchar := -1\n    for i := int64(0); i < base; i++ {\n        if v, ok := dict[i]; ok {\n            lchar = int(v)\n        } else if lchar != -1 {\n            dict[i] = byte(lchar)\n        }\n    }\n\n    \n    decoded := make([]byte, base)\n    bigBase := big.NewInt(base)\n\n    for i := base - 1; i >= 0; i-- {\n\n        pow := big.NewInt(0)\n        pow.Exp(bigBase, big.NewInt(i), nil)\n\n        div := big.NewInt(0)\n        div.Div(enc, pow)\n\n        c := dict[div.Int64()]\n        fv := freq[c]\n        cv := cf[c]\n\n        prod := big.NewInt(0).Mul(pow, big.NewInt(cv))\n        diff := big.NewInt(0).Sub(enc, prod)\n        enc.Div(diff, big.NewInt(fv))\n\n        decoded[base-i-1] = c\n    }\n\n    \n    return string(decoded)\n}\n\nfunc main() {\n\n    var radix = int64(10)\n\n    strSlice := []string{\n        `DABDDB`,\n        `DABDDBBDDBA`,\n        `ABRACADABRA`,\n        `TOBEORNOTTOBEORTOBEORNOT`,\n    }\n\n    for _, str := range strSlice {\n        enc, pow, freq := arithmethic_coding(str, radix)\n        dec := arithmethic_decoding(enc, radix, pow, freq)\n        fmt.Printf(\"%-25s=> %19s * %d^%s\\n\", str, enc, radix, pow)\n\n        if str != dec {\n            panic(\"\\tHowever that is incorrect!\")\n        }\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 290,
    "input": "Translate Python to Go:\nfrom unicodedata import name\n\n\ndef unicode_code(ch):\n    return 'U+{:04x}'.format(ord(ch))\n\n\ndef utf8hex(ch):\n    return \" \".join([hex(c)[2:] for c in ch.encode('utf8')]).upper()\n\n\nif __name__ == \"__main__\":\n    print('{:<11} {:<36} {:<15} {:<15}'.format('Character', 'Name', 'Unicode', 'UTF-8 encoding (hex)'))\n    chars = ['A', 'ö', 'Ж', '€', '𝄞']\n    for char in chars:\n        print('{:<11} {:<36} {:<15} {:<15}'.format(char, name(char), unicode_code(char), utf8hex(char)))\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"bytes\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"log\"\n    \"strings\"\n)\n\nvar testCases = []struct {\n    rune\n    string\n}{\n    {'A', \"41\"},\n    {'ö', \"C3 B6\"},\n    {'Ж', \"D0 96\"},\n    {'€', \"E2 82 AC\"},\n    {'𝄞', \"F0 9D 84 9E\"},\n}\n\nfunc main() {\n    for _, tc := range testCases {\n        \n        u := fmt.Sprintf(\"U+%04X\", tc.rune)\n        b, err := hex.DecodeString(strings.Replace(tc.string, \" \", \"\", -1))\n        if err != nil {\n            log.Fatal(\"bad test data\")\n        }\n        \n        e := encodeUTF8(tc.rune)\n        d := decodeUTF8(b)\n        \n        fmt.Printf(\"%c  %-7s  %X\\n\", d, u, e)\n        \n        if !bytes.Equal(e, b) {\n            log.Fatal(\"encodeUTF8 wrong\")\n        }\n        if d != tc.rune {\n            log.Fatal(\"decodeUTF8 wrong\")\n        }\n    }\n}\n\nconst (\n    \n    b2Lead = 0xC0 \n    b2Mask = 0x1F \n\n    \n    b3Lead = 0xE0 \n    b3Mask = 0x0F \n\n    \n    b4Lead = 0xF0 \n    b4Mask = 0x07 \n\n    \n    mbLead = 0x80 \n    mbMask = 0x3F \n)\n\nfunc encodeUTF8(r rune) []byte {\n    switch i := uint32(r); {\n    case i <= 1<<7-1: \n        return []byte{byte(r)}\n    case i <= 1<<11-1: \n        return []byte{\n            b2Lead | byte(r>>6),\n            mbLead | byte(r)&mbMask}\n    case i <= 1<<16-1: \n        return []byte{\n            b3Lead | byte(r>>12),\n            mbLead | byte(r>>6)&mbMask,\n            mbLead | byte(r)&mbMask}\n    default:\n        return []byte{\n            b4Lead | byte(r>>18),\n            mbLead | byte(r>>12)&mbMask,\n            mbLead | byte(r>>6)&mbMask,\n            mbLead | byte(r)&mbMask}\n    }\n}\n\nfunc decodeUTF8(b []byte) rune {\n    switch b0 := b[0]; {\n    case b0 < 0x80:\n        return rune(b0)\n    case b0 < 0xE0:\n        return rune(b0&b2Mask)<<6 |\n            rune(b[1]&mbMask)\n    case b0 < 0xF0:\n        return rune(b0&b3Mask)<<12 |\n            rune(b[1]&mbMask)<<6 |\n            rune(b[2]&mbMask)\n    default:\n        return rune(b0&b4Mask)<<18 |\n            rune(b[1]&mbMask)<<12 |\n            rune(b[2]&mbMask)<<6 |\n            rune(b[3]&mbMask)\n    }\n}\n",
    "input_language": "Python",
    "output_language": "Go"
  },
  {
    "id": 291,
    "input": "Translate Java to Python:import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MetallicRatios {\n\n    private static String[] ratioDescription = new String[] {\"Platinum\", \"Golden\", \"Silver\", \"Bronze\", \"Copper\", \"Nickel\", \"Aluminum\", \"Iron\", \"Tin\", \"Lead\"};\n    \n    public static void main(String[] args) {\n        int elements = 15;\n        for ( int b = 0 ; b < 10 ; b++ ) {\n            System.out.printf(\"Lucas sequence for %s ratio, where b = %d:%n\", ratioDescription[b], b);\n            System.out.printf(\"First %d elements: %s%n\", elements, lucasSequence(1, 1, b, elements));\n            int decimalPlaces = 32;\n            BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n            System.out.printf(\"Value to %d decimal places after %s iterations : %s%n\", decimalPlaces, ratio[1], ratio[0]);\n            System.out.printf(\"%n\");\n        }\n        int b = 1;\n        int decimalPlaces = 256;\n        System.out.printf(\"%s ratio, where b = %d:%n\", ratioDescription[b], b);\n        BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n        System.out.printf(\"Value to %d decimal places after %s iterations : %s%n\", decimalPlaces, ratio[1], ratio[0]);\n    }\n    \n    private static BigDecimal[] lucasSequenceRatio(int x0, int x1, int b, int digits) {\n        BigDecimal x0Bi = BigDecimal.valueOf(x0);\n        BigDecimal x1Bi = BigDecimal.valueOf(x1);\n        BigDecimal bBi = BigDecimal.valueOf(b);\n        MathContext mc = new MathContext(digits);\n        BigDecimal fractionPrior = x1Bi.divide(x0Bi, mc);\n        int iterations = 0;\n        while ( true ) {\n            iterations++;\n            BigDecimal x = bBi.multiply(x1Bi).add(x0Bi);\n            BigDecimal fractionCurrent = x.divide(x1Bi, mc);\n            if ( fractionCurrent.compareTo(fractionPrior) == 0 ) {\n                break;\n            }\n            x0Bi = x1Bi;\n            x1Bi = x;\n            fractionPrior = fractionCurrent;\n        }\n        return new BigDecimal[] {fractionPrior, BigDecimal.valueOf(iterations)};\n    }\n\n    private static List<BigInteger> lucasSequence(int x0, int x1, int b, int n) {\n        List<BigInteger> list = new ArrayList<>();\n        BigInteger x0Bi = BigInteger.valueOf(x0);\n        BigInteger x1Bi = BigInteger.valueOf(x1);\n        BigInteger bBi = BigInteger.valueOf(b);\n        if ( n > 0 ) {\n            list.add(x0Bi);\n        }\n        if ( n > 1 ) {\n            list.add(x1Bi);\n        }\n        while ( n > 2 ) {\n            BigInteger x = bBi.multiply(x1Bi).add(x0Bi);\n            list.add(x);\n            n--;\n            x0Bi = x1Bi;\n            x1Bi = x;\n        }\n        return list;\n    }\n    \n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "from itertools import count, islice\nfrom _pydecimal import getcontext, Decimal\n\ndef metallic_ratio(b):\n    m, n = 1, 1\n    while True:\n        yield m, n\n        m, n = m*b + n, m\n\ndef stable(b, prec):\n    def to_decimal(b):\n        for m,n in metallic_ratio(b):\n            yield Decimal(m)/Decimal(n)\n\n    getcontext().prec = prec\n    last = 0\n    for i,x in zip(count(), to_decimal(b)):\n        if x == last:\n            print(f'after {i} iterations:\\n\\t{x}')\n            break\n        last = x\n\nfor b in range(4):\n    coefs = [n for _,n in islice(metallic_ratio(b), 15)]\n    print(f'\\nb = {b}: {coefs}')\n    stable(b, 32)\n\nprint(f'\\nb = 1 with 256 digits:')\nstable(1, 256)\n",
    "input_language": "Java",
    "output_language": "Python"
  },
  {
    "id": 292,
    "input": "Translate Java to Go:public class FizzBuzz {\n\n    public static void main(String[] args) {\n        Sound[] sounds = {new Sound(3, \"Fizz\"), new Sound(5, \"Buzz\"),  new Sound(7, \"Baxx\")};\n        for (int i = 1; i <= 20; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (Sound sound : sounds) {\n                sb.append(sound.generate(i));\n            }\n            System.out.println(sb.length() == 0 ? i : sb.toString());\n        }\n    }\n\n    private static class Sound {\n        private final int trigger;\n        private final String onomatopoeia;\n\n        public Sound(int trigger, String onomatopoeia) {\n            this.trigger = trigger;\n            this.onomatopoeia = onomatopoeia;\n        }\n\n        public String generate(int i) {\n            return i % trigger == 0 ? onomatopoeia : \"\";\n        }\n\n    }\n\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n\t\"fmt\"\n)\n\nconst numbers = 3\n\nfunc main() {\n\n\t\n\tmax := 20\n\twords := map[int]string{\n\t\t3: \"Fizz\",\n\t\t5: \"Buzz\",\n\t\t7: \"Baxx\",\n\t}\n\tkeys := []int{3, 5, 7}\n\tdivisible := false\n\tfor i := 1; i <= max; i++ {\n\t\tfor _, n := range keys {\n\t\t\tif i % n == 0 {\n\t\t\t\tfmt.Print(words[n])\n\t\t\t\tdivisible = true\n\t\t\t}\n\t\t}\n\t\tif !divisible {\n\t\t\tfmt.Print(i)\n\t\t}\n\t\tfmt.Println()\n\t\tdivisible = false\n\t}\n\n}\n",
    "input_language": "Java",
    "output_language": "Go"
  },
  {
    "id": 293,
    "input": "Translate C to Go:#include <stdio.h>\n\nint min(int a, int b) {\n    if (a < b) return a;\n    return b;\n}\n\nint main() {\n    int n;\n    int numbers1[5] = {5, 45, 23, 21, 67};\n    int numbers2[5] = {43, 22, 78, 46, 38};\n    int numbers3[5] = {9, 98, 12, 98, 53};\n    int numbers[5]  = {};\n    for (n = 0; n < 5; ++n) {\n        numbers[n] = min(min(numbers1[n], numbers2[n]), numbers3[n]);\n        printf(\"%d \", numbers[n]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"rcu\"\n)\n\nfunc main() {\n    numbers1 := [5]int{5, 45, 23, 21, 67}\n    numbers2 := [5]int{43, 22, 78, 46, 38}\n    numbers3 := [5]int{9, 98, 12, 98, 53}\n    numbers := [5]int{}\n    for n := 0; n < 5; n++ {\n        numbers[n] = rcu.Min(rcu.Min(numbers1[n], numbers2[n]), numbers3[n])\n    }\n    fmt.Println(numbers)\n}\n",
    "input_language": "C",
    "output_language": "Go"
  },
  {
    "id": 294,
    "input": "Translate PHP to Java:<?php\nfile_put_contents('/dev/lp0', 'Hello world!');\n?>\n\nDo not return anything including notes and the like except for one translated Java code.",
    "output": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n",
    "input_language": "PHP",
    "output_language": "Java"
  },
  {
    "id": 295,
    "input": "Translate PHP to VB:$string = \"The quick brown fox jumped over the lazy dog's back\";\necho md5( $string );\n\nDo not return anything including notes and the like except for one translated VB code.",
    "output": "Imports System.Security.Cryptography\nImports System.Text\n\nModule MD5hash\n    Sub Main(args As String())\n        Console.WriteLine(GetMD5(\"Visual Basic .Net\"))\n    End Sub\n\n    Private Function GetMD5(plainText As String) As String\n        Dim hash As String = \"\"\n\n        Using hashObject As MD5 = MD5.Create()\n            Dim ptBytes As Byte() = hashObject.ComputeHash(Encoding.UTF8.GetBytes(plainText))\n            Dim hashBuilder As New StringBuilder\n\n            For i As Integer = 0 To ptBytes.Length - 1\n                hashBuilder.Append(ptBytes(i).ToString(\"X2\"))\n            Next\n            hash = hashBuilder.ToString\n        End Using\n\n        Return hash\n    End Function\n\nEnd Module\n",
    "input_language": "PHP",
    "output_language": "VB"
  },
  {
    "id": 296,
    "input": "Translate C++ to C#:#include <iostream>\n#include <iterator>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace detail {\n\ntemplate <typename ForwardIterator>\nclass tokenizer\n{\n\t\n\tForwardIterator _tbegin, _tend, _end;\n\t\npublic:\n\t\n\ttokenizer(ForwardIterator begin, ForwardIterator end)\n\t\t: _tbegin(begin), _tend(begin), _end(end)\n\t{ }\n\t\n\ttemplate <typename Lambda>\n\tbool next(Lambda istoken)\n\t{\n\t\tif (_tbegin == _end) {\n\t\t\treturn false;\n\t\t}\n\t\t_tbegin = _tend;\n\t\tfor (; _tend != _end && !istoken(*_tend); ++_tend) {\n\t\t\tif (*_tend == '\\\\' && std::next(_tend) != _end) {\n\t\t\t\t++_tend;\n\t\t\t}\n\t\t}\n\t\tif (_tend == _tbegin) {\n\t\t\t_tend++;\n\t\t}\n\t\treturn _tbegin != _end;\n\t}\n\t\n\tForwardIterator begin() const { return _tbegin; }\n\tForwardIterator end()   const { return _tend; }\n\tbool operator==(char c) { return *_tbegin == c; }\n\t\n};\n\ntemplate <typename List>\nvoid append_all(List & lista, const List & listb)\n{\n\tif (listb.size() == 1) {\n\t\tfor (auto & a : lista) {\n\t\t\ta += listb.back();\n\t\t}\n\t} else {\n\t\tList tmp;\n\t\tfor (auto & a : lista) {\n\t\t\tfor (auto & b : listb) {\n\t\t\t\ttmp.push_back(a + b);\n\t\t\t}\n\t\t}\n\t\tlista = std::move(tmp);\n\t}\n}\n\ntemplate <typename String, typename List, typename Tokenizer>\nList expand(Tokenizer & token)\n{\n\t\n\tstd::vector<List> alts{ { String() } };\n\t\n\twhile (token.next([](char c) { return c == '{' || c == ',' || c == '}'; })) {\n\t\t\n\t\tif (token == '{') {\n\t\t\tappend_all(alts.back(), expand<String, List>(token));\n\t\t} else if (token == ',') {\n\t\t\talts.push_back({ String() });\n\t\t} else if (token == '}') {\n\t\t\tif (alts.size() == 1) {\n\t\t\t\tfor (auto & a : alts.back()) {\n\t\t\t\t\ta = '{' + a + '}';\n\t\t\t\t}\n\t\t\t\treturn alts.back();\n\t\t\t} else {\n\t\t\t\tfor (std::size_t i = 1; i < alts.size(); i++) {\n\t\t\t\t\talts.front().insert(alts.front().end(),\n\t\t\t\t\t\tstd::make_move_iterator(std::begin(alts[i])),\n\t\t\t\t\t\tstd::make_move_iterator(std::end(alts[i])));\n\t\t\t\t}\n\t\t\t\treturn std::move(alts.front());\n\t\t\t}\n\t\t} else {\n\t\t\tfor (auto & a : alts.back()) {\n\t\t\t\ta.append(token.begin(), token.end());\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tList result{ String{ '{' } };\n\tappend_all(result, alts.front());\n\tfor (std::size_t i = 1; i < alts.size(); i++) {\n\t\tfor (auto & a : result) {\n\t\t\ta += ',';\n\t\t}\n\t\tappend_all(result, alts[i]);\n\t}\n\treturn result;\n}\n\n} \n\ntemplate <\n\ttypename ForwardIterator,\n\ttypename String = std::basic_string<\n\t\ttypename std::iterator_traits<ForwardIterator>::value_type\n\t>,\n\ttypename List = std::vector<String>\n>\nList expand(ForwardIterator begin, ForwardIterator end)\n{\n\tdetail::tokenizer<ForwardIterator> token(begin, end);\n\tList list{ String() };\n\twhile (token.next([](char c) { return c == '{'; })) {\n\t\tif (token == '{') {\n\t\t\tdetail::append_all(list, detail::expand<String, List>(token));\n\t\t} else {\n\t\t\tfor (auto & a : list) {\n\t\t\t\ta.append(token.begin(), token.end());\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\ntemplate <\n\ttypename Range,\n\ttypename String = std::basic_string<typename Range::value_type>,\n\ttypename List = std::vector<String>\n>\nList expand(const Range & range)\n{\n\tusing Iterator = typename Range::const_iterator;\n\treturn expand<Iterator, String, List>(std::begin(range), std::end(range));\n}\n\nint main()\n{\n\t\n\tfor (std::string string : {\n\t\tR\"(~/{Downloads,Pictures}/*.{jpg,gif,png})\",\n\t\tR\"(It{{em,alic}iz,erat}e{d,}, please.)\",\n\t\tR\"({,{,gotta have{ ,\\, again\\, }}more }cowbell!)\",\n\t\tR\"({}} some {\\\\{edge,edgy} }{ cases, here\\\\\\})\",\n\t\tR\"(a{b{1,2}c)\",\n\t\tR\"(a{1,2}b}c)\",\n\t\tR\"(a{1,{2},3}b)\",\n\t\tR\"(a{b{1,2}c{}})\",\n\t\tR\"(more{ darn{ cowbell,},})\",\n\t\tR\"(ab{c,d\\,e{f,g\\h},i\\,j{k,l\\,m}n,o\\,p}qr)\",\n\t\tR\"({a,{\\,b}c)\",\n\t\tR\"(a{b,{{c}})\",\n\t\tR\"({a{\\}b,c}d)\",\n\t\tR\"({a,b{{1,2}e}f)\",\n\t\tR\"({}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\})\",\n\t\tR\"({{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{)\",\n\t}) {\n\t\tstd::cout << string << '\\n';\n\t\tfor (auto expansion : expand(string)) {\n\t\t\tstd::cout << \"    \" << expansion << '\\n';\n\t\t}\n\t\tstd::cout << '\\n';\n\t}\n\t\n\treturn 0;\n}\n\nDo not return anything including notes and the like except for one translated C# code.",
    "output": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing static System.Linq.Enumerable;\n\npublic static class BraceExpansion\n{\n    enum TokenType { OpenBrace, CloseBrace, Separator, Text, Alternate, Concat }\n    const char L = '{', R = '}', S = ',';\n    \n    public static void Main() {\n        string[] input = {\n            \"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            @\"{,{,gotta have{ ,\\, again\\, }}more }cowbell!\",\n            @\"{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\"\n        };\n        foreach (string text in input) Expand(text);\n    }\n    \n    static void Expand(string input) {\n        Token token = Tokenize(input);\n        foreach (string value in token) Console.WriteLine(value);\n        Console.WriteLine();\n    }\n    \n    static Token Tokenize(string input) {\n        var tokens = new List<Token>();\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        int level = 0;\n        \n        foreach (char c in input) {\n            (escaping, level, tokens, buffer) = c switch {\n                _ when escaping => (false, level, tokens, buffer.Append(c)),\n                '\\\\' => (true, level, tokens, buffer.Append(c)),\n                L => (escaping, level + 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.OpenBrace)), buffer),\n                S when level > 0 => (escaping, level,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.Separator)), buffer),\n                R when level > 0 => (escaping, level - 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.CloseBrace)).Merge(), buffer),\n                _ => (escaping, level, tokens, buffer.Append(c))\n            };\n        }\n        if (buffer.Length > 0) tokens.Add(buffer.Flush());\n        for (int i = 0; i < tokens.Count; i++) {\n            if (tokens[i].Type == TokenType.OpenBrace || tokens[i].Type == TokenType.Separator) {\n                tokens[i] = tokens[i].Value; \n            }\n        }\n        return new Token(tokens, TokenType.Concat);\n    }\n    \n    static List<Token> Merge(this List<Token> list) {\n        int separators = 0;\n        int last = list.Count - 1;\n        for (int i = list.Count - 3; i >= 0; i--) {\n            if (list[i].Type == TokenType.Separator) {\n                separators++;\n                Concat(list, i + 1, last);\n                list.RemoveAt(i);\n                last = i;\n            } else if (list[i].Type == TokenType.OpenBrace) {\n                Concat(list, i + 1, last);\n                if (separators > 0) {\n                    list[i] = new Token(list.Range((i+1)..^1), TokenType.Alternate);\n                    list.RemoveRange(i+1, list.Count - i - 1);\n                } else {\n                    list[i] = L.ToString();\n                    list[^1] = R.ToString();\n                    Concat(list, i, list.Count);\n                }\n                break;\n            }\n        }\n        return list;\n    }\n    \n    static void Concat(List<Token> list, int s, int e) {\n        for (int i = e - 2; i >= s; i--) {\n            (Token a, Token b) = (list[i], list[i+1]);\n            switch (a.Type, b.Type) {\n                case (TokenType.Text, TokenType.Text):\n                    list[i] = a.Value + b.Value;\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Concat):\n                    a.SubTokens.AddRange(b.SubTokens);\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Text) when b.Value == \"\":\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Text, TokenType.Concat) when a.Value == \"\":\n                    list.RemoveAt(i);\n                    break;\n                default:\n                    list[i] = new Token(new [] { a, b }, TokenType.Concat);\n                    list.RemoveAt(i+1);\n                    break;\n            }\n        }\n    }\n    \n    private struct Token : IEnumerable<string>\n    {\n        private List<Token>? _subTokens;\n        \n        public string Value { get; }\n        public TokenType Type { get; }\n        public List<Token> SubTokens => _subTokens ??= new List<Token>();\n        \n        public Token(string value, TokenType type) => (Value, Type, _subTokens) = (value, type, null);\n        public Token(IEnumerable<Token> subTokens, TokenType type) => (Value, Type, _subTokens) = (\"\", type, subTokens.ToList());\n        \n        public static implicit operator Token(string value) => new Token(value, TokenType.Text);\n        \n        public IEnumerator<string> GetEnumerator() => (Type switch\n        {\n            TokenType.Concat => SubTokens.Select(t => t.AsEnumerable()).CartesianProduct().Select(p => string.Join(\"\", p)),\n            TokenType.Alternate => from t in SubTokens from s in t select s,\n            _ => Repeat(Value, 1)\n        }).GetEnumerator();\n        \n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();        \n    }\n    \n    \n    static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n                from acc in accumulator\n                from item in sequence\n                select acc.Concat(new [] { item }));\n    }\n    \n    static List<Token> With(this List<Token> list, Token token) {\n        list.Add(token);\n        return list;\n    }\n    \n    static IEnumerable<Token> Range(this List<Token> list, Range range) {\n        int start = range.Start.GetOffset(list.Count);\n        int end = range.End.GetOffset(list.Count);\n        for (int i = start; i < end; i++) yield return list[i];\n    }\n    \n    static string Flush(this StringBuilder builder) {\n        string result = builder.ToString();\n        builder.Clear();\n        return result;\n    }\n}\n",
    "input_language": "C++",
    "output_language": "C#"
  },
  {
    "id": 297,
    "input": "Translate C to Python:#include <stdio.h>\n#include <gmp.h>\n\nvoid jacobsthal(mpz_t r, unsigned long n) {\n    mpz_t s;\n    mpz_init(s);\n    mpz_set_ui(r, 1);\n    mpz_mul_2exp(r, r, n);\n    mpz_set_ui(s, 1);\n    if (n % 2) mpz_neg(s, s);\n    mpz_sub(r, r, s);\n    mpz_div_ui(r, r, 3);\n}\n\nvoid jacobsthal_lucas(mpz_t r, unsigned long n) {\n    mpz_t a;\n    mpz_init(a);\n    mpz_set_ui(r, 1);\n    mpz_mul_2exp(r, r, n);\n    mpz_set_ui(a, 1);\n    if (n % 2) mpz_neg(a, a);\n    mpz_add(r, r, a);\n}\n\nint main() {\n    int i, count;\n    mpz_t jac[30], j;\n    printf(\"First 30 Jacobsthal numbers:\\n\");\n    for (i = 0; i < 30; ++i) {\n        mpz_init(jac[i]);\n        jacobsthal(jac[i], i);\n        gmp_printf(\"%9Zd \", jac[i]);\n        if (!((i+1)%5)) printf(\"\\n\");\n    }\n\n    printf(\"\\nFirst 30 Jacobsthal-Lucas numbers:\\n\");\n    mpz_init(j);\n    for (i = 0; i < 30; ++i) {\n        jacobsthal_lucas(j, i);\n        gmp_printf(\"%9Zd \", j);\n        if (!((i+1)%5)) printf(\"\\n\");\n    }\n\n    printf(\"\\nFirst 20 Jacobsthal oblong numbers:\\n\");\n    for (i = 0; i < 20; ++i) {\n        mpz_mul(j, jac[i], jac[i+1]);\n        gmp_printf(\"%11Zd \", j);\n        if (!((i+1)%5)) printf(\"\\n\");\n    }\n\n    printf(\"\\nFirst 20 Jacobsthal primes:\\n\");\n    for (i = 0, count = 0; count < 20; ++i) {\n        jacobsthal(j, i);\n        if (mpz_probab_prime_p(j, 15) > 0) {\n            gmp_printf(\"%Zd\\n\", j);\n            ++count;\n        }\n    }\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Python code.",
    "output": "\nfrom math import floor, pow\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef odd(n):\n    return n and 1 != 0\n    \ndef jacobsthal(n):\n    return floor((pow(2,n)+odd(n))/3)\n\ndef jacobsthal_lucas(n):\n    return int(pow(2,n)+pow(-1,n))\n\ndef jacobsthal_oblong(n):\n    return jacobsthal(n)*jacobsthal(n+1)\n\n\nif __name__ == '__main__':\n    print(\"First 30 Jacobsthal numbers:\")\n    for j in range(0, 30):\n        print(jacobsthal(j), end=\"  \")\n\n    print(\"\\n\\nFirst 30 Jacobsthal-Lucas numbers: \")\n    for j in range(0, 30):\n        print(jacobsthal_lucas(j), end = '\\t')\n\n    print(\"\\n\\nFirst 20 Jacobsthal oblong numbers: \")\n    for j in range(0, 20):\n        print(jacobsthal_oblong(j), end=\"  \")\n\n    print(\"\\n\\nFirst 10 Jacobsthal primes: \")\n    for j in range(3, 33):\n        if isPrime(jacobsthal(j)):\n            print(jacobsthal(j))\n",
    "input_language": "C",
    "output_language": "Python"
  },
  {
    "id": 298,
    "input": "Translate C to PHP:#include <stdio.h>\n#include <stdlib.h>\n\nchar chr_legal[] = \"abcdefghijklmnopqrstuvwxyz0123456789_-./\";\nint  chr_idx[256] = {0};\nchar idx_chr[256] = {0};\n\n#define FNAME 0\ntypedef struct trie_t *trie, trie_t;\nstruct trie_t {\n    trie next[sizeof(chr_legal)]; \n    int eow;\n};\n\ntrie trie_new() { return calloc(sizeof(trie_t), 1); }\n\n#define find_word(r, w) trie_trav(r, w, 1)\n\ntrie trie_trav(trie root, const char * str, int no_create)\n{\n    int c;\n    while (root) {\n        if ((c = str[0]) == '\\0') {\n            if (!root->eow && no_create) return 0;\n            break;\n        }\n        if (! (c = chr_idx[c]) ) {\n            str++;\n            continue;\n        }\n\n        if (!root->next[c]) {\n            if (no_create) return 0;\n            root->next[c] = trie_new();\n        }\n        root = root->next[c];\n        str++;\n    }\n    return root;\n}\n\n\nint trie_all(trie root, char path[], int depth, int (*callback)(char *))\n{\n    int i;\n    if (root->eow && !callback(path)) return 0;\n\n    for (i = 1; i < sizeof(chr_legal); i++) {\n        if (!root->next[i]) continue;\n\n        path[depth] = idx_chr[i];\n        path[depth + 1] = '\\0';\n        if (!trie_all(root->next[i], path, depth + 1, callback))\n            return 0;\n    }\n    return 1;\n}\n\nvoid add_index(trie root, const char *word, const char *fname)\n{\n    trie x = trie_trav(root, word, 0);\n    x->eow = 1;\n\n    if (!x->next[FNAME])\n        x->next[FNAME] = trie_new();\n    x = trie_trav(x->next[FNAME], fname, 0);\n    x->eow = 1;\n}\n\nint print_path(char *path)\n{\n    printf(\" %s\", path);\n    return 1;\n}\n\n\nconst char *files[] = { \"f1.txt\", \"source/f2.txt\", \"other_file\" };\nconst char *text[][5] ={{ \"it\", \"is\", \"what\", \"it\", \"is\" },\n                { \"what\", \"is\", \"it\", 0 },\n                { \"it\", \"is\", \"a\", \"banana\", 0 }};\n\ntrie init_tables()\n{\n    int i, j;\n    trie root = trie_new();\n    for (i = 0; i < sizeof(chr_legal); i++) {\n        chr_idx[(int)chr_legal[i]] = i + 1;\n        idx_chr[i + 1] = chr_legal[i];\n    }\n\n\n#define USE_ADVANCED_FILE_HANDLING 0\n#if USE_ADVANCED_FILE_HANDLING\n    void read_file(const char * fname) {\n        char cmd[1024];\n        char word[1024];\n        sprintf(cmd, \"perl -p -e 'while(/(\\\\w+)/g) {print lc($1),\\\"\\\\n\\\"}' %s\", fname);\n        FILE *in = popen(cmd, \"r\");\n        while (!feof(in)) {\n            fscanf(in, \"%1000s\", word);\n            add_index(root, word, fname);\n        }\n        pclose(in);\n    };\n\n    read_file(\"f1.txt\");\n    read_file(\"source/f2.txt\");\n    read_file(\"other_file\");\n#else\n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 5; j++) {\n            if (!text[i][j]) break;\n            add_index(root, text[i][j], files[i]);\n        }\n    }\n#endif \n\n    return root;\n}\n\nvoid search_index(trie root, const char *word)\n{\n    char path[1024];\n    printf(\"Search for \\\"%s\\\": \", word);\n    trie found = find_word(root, word);\n\n    if (!found) printf(\"not found\\n\");\n    else {\n        trie_all(found->next[FNAME], path, 0, print_path);\n        printf(\"\\n\");\n    }\n}\n\nint main()\n{\n    trie root = init_tables();\n\n    search_index(root, \"what\");\n    search_index(root, \"is\");\n    search_index(root, \"banana\");\n    search_index(root, \"boo\");\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\n\nfunction buildInvertedIndex($filenames)\n{\n    $invertedIndex = [];\n\n    foreach($filenames as $filename)\n    {\n        $data = file_get_contents($filename);\n\n        if($data === false) die('Unable to read file: ' . $filename);\n\n        preg_match_all('/(\\w+)/', $data, $matches, PREG_SET_ORDER);\n\n        foreach($matches as $match)\n        {\n            $word = strtolower($match[0]);\n\n            if(!array_key_exists($word, $invertedIndex)) $invertedIndex[$word] = [];\n            if(!in_array($filename, $invertedIndex[$word], true)) $invertedIndex[$word][] = $filename;\n        }\n    }\n\n    return $invertedIndex;\n}\n\nfunction lookupWord($invertedIndex, $word)\n{\n    return array_key_exists($word, $invertedIndex) ? $invertedIndex[$word] : false;\n}\n\n$invertedIndex = buildInvertedIndex2(['file1.txt', 'file2.txt', 'file3.txt']);\n\nforeach(['cat', 'is', 'banana', 'it'] as $word)\n{\n    $matches = lookupWord($invertedIndex, $word);\n\n    if($matches !== false)\n    {\n        echo \"Found the word \\\"$word\\\" in the following files: \" . implode(', ', $matches) . \"\\n\";\n    }\n    else\n    {\n        echo \"Unable to find the word \\\"$word\\\" in the index\\n\";\n    }\n}\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 299,
    "input": "Translate C to PHP:#include <stdio.h>\n\nstatic const char *dog = \"Benjamin\";\nstatic const char *Dog = \"Samba\";\nstatic const char *DOG = \"Bernie\";\n\nint main()\n{\n    printf(\"The three dogs are named %s, %s and %s.\\n\", dog, Dog, DOG);\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated PHP code.",
    "output": "<?php\n\n\n\n$dog = 'Benjamin';\n$Dog = 'Samba';\n$DOG = 'Bernie';\n\necho \"There are 3 dogs named {$dog}, {$Dog} and {$DOG}\\n\";\n\n\nfunction DOG() { return 'Bernie'; }\n\necho 'There is only 1 dog named ' . dog() . \"\\n\";\n",
    "input_language": "C",
    "output_language": "PHP"
  },
  {
    "id": 300,
    "input": "Translate C++ to Go:#include <iostream>\n#include <vector>\n\nstd::vector<int> smallPrimes;\n\nbool is_prime(size_t test) {\n    if (test < 2) {\n        return false;\n    }\n    if (test % 2 == 0) {\n        return test == 2;\n    }\n    for (size_t d = 3; d * d <= test; d += 2) {\n        if (test % d == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid init_small_primes(size_t numPrimes) {\n    smallPrimes.push_back(2);\n\n    int count = 0;\n    for (size_t n = 3; count < numPrimes; n += 2) {\n        if (is_prime(n)) {\n            smallPrimes.push_back(n);\n            count++;\n        }\n    }\n}\n\nsize_t divisor_count(size_t n) {\n    size_t count = 1;\n    while (n % 2 == 0) {\n        n /= 2;\n        count++;\n    }\n    for (size_t d = 3; d * d <= n; d += 2) {\n        size_t q = n / d;\n        size_t r = n % d;\n        size_t dc = 0;\n        while (r == 0) {\n            dc += count;\n            n = q;\n            q = n / d;\n            r = n % d;\n        }\n        count += dc;\n    }\n    if (n != 1) {\n        count *= 2;\n    }\n    return count;\n}\n\nuint64_t OEISA073916(size_t n) {\n    if (is_prime(n)) {\n        return (uint64_t) pow(smallPrimes[n - 1], n - 1);\n    }\n\n    size_t count = 0;\n    uint64_t result = 0;\n    for (size_t i = 1; count < n; i++) {\n        if (n % 2 == 1) {\n            \n            size_t root = (size_t) sqrt(i);\n            if (root * root != i) {\n                continue;\n            }\n        }\n        if (divisor_count(i) == n) {\n            count++;\n            result = i;\n        }\n    }\n    return result;\n}\n\nint main() {\n    const int MAX = 15;\n    init_small_primes(MAX);\n    for (size_t n = 1; n <= MAX; n++) {\n        if (n == 13) {\n            std::cout << \"A073916(\" << n << \") = One more bit needed to represent result.\\n\";\n        } else {\n            std::cout << \"A073916(\" << n << \") = \" << OEISA073916(n) << '\\n';\n        }\n    }\n\n    return 0;\n}\n\nDo not return anything including notes and the like except for one translated Go code.",
    "output": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/big\"\n)\n\nvar bi = new(big.Int)\n\nfunc isPrime(n int) bool {\n    bi.SetUint64(uint64(n))\n    return bi.ProbablyPrime(0)\n}\n\nfunc generateSmallPrimes(n int) []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    for i, count := 3, 1; count < n; i += 2 {\n        if isPrime(i) {\n            primes[count] = i\n            count++\n        }\n    }\n    return primes\n}\n\nfunc countDivisors(n int) int {\n    count := 1\n    for n%2 == 0 {\n        n >>= 1\n        count++\n    }\n    for d := 3; d*d <= n; d += 2 {\n        q, r := n/d, n%d\n        if r == 0 {\n            dc := 0\n            for r == 0 {\n                dc += count\n                n = q\n                q, r = n/d, n%d\n            }\n            count += dc\n        }\n    }\n    if n != 1 {\n        count *= 2\n    }\n    return count\n}\n\nfunc main() {\n    const max = 33\n    primes := generateSmallPrimes(max)\n    z := new(big.Int)\n    p := new(big.Int)\n    fmt.Println(\"The first\", max, \"terms in the sequence are:\")\n    for i := 1; i <= max; i++ {\n        if isPrime(i) {\n            z.SetUint64(uint64(primes[i-1]))\n            p.SetUint64(uint64(i - 1))\n            z.Exp(z, p, nil)\n            fmt.Printf(\"%2d : %d\\n\", i, z)\n        } else {\n            count := 0\n            for j := 1; ; j++ {\n                if i%2 == 1 {\n                    sq := int(math.Sqrt(float64(j)))\n                    if sq*sq != j {\n                        continue\n                    }\n                }\n                if countDivisors(j) == i {\n                    count++\n                    if count == i {\n                        fmt.Printf(\"%2d : %d\\n\", i, j)\n                        break\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "input_language": "C++",
    "output_language": "Go"
  }
]